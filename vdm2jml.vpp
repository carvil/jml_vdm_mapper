class Vdm2Jml

types

public ClassId = seq of char;

public TypeInfo = map ClassId to JmlType;

public Information ::
  access     : JmlAccessDefinition
  field_list : seq of JmlField
  invariant  : [JmlExpression];
  
public Error ::
  line : nat
  column  : nat
  constructor : seq of char;

instance variables

public hold_type_info : map ClassId to TypeInfo := {|->};

public interfaces_list : set of ClassId := {};

public classes_list : set of ClassId := {};

public to_class : map ClassId to Information := {|->};

public log : set of Error := {};

operations 


------------------------------------------------
-- MULTIPLE INHERITANCE ------------------------
------------------------------------------------


public init :
  OmlSpecifications ==>
  JmlSpecifications
init(specs) ==
  if preprocess(specs) 
  then return eliminateMI(specs)
  else return build_jml(specs);
	 
	 
public eliminateMI : 
  OmlSpecifications ==>
  JmlSpecifications
eliminateMI(specs) == 
  if canProceed(specs)
  then (eliminate(specs);
        checkInheritanceLost(specs);
        build_jml(specs))
  else return new JmlSpecifications([]);


public checkInheritanceLost :
  OmlSpecifications ==>
  ()
checkInheritanceLost(specs) ==
  let s = { checkInheritanceLostHelper(i,specs) | i in set interfaces_list},
      r = removeNil(s)
  in (log := log union r);


public removeNil :
  set of [Error] ==>
  set of Error
removeNil(s) ==
  return {i | i in set s & i <> nil};


public checkInheritanceLostHelper :
  ClassId *
  OmlSpecifications ==>
  [Error]
checkInheritanceLostHelper(c,specs) == 
  let l = specs.getClassList(),
      r = getRightClass(c,l)
  in return r;


public getRightClass :
  ClassId *
  seq of OmlClass ==>
  [Error]
getRightClass(c,s) == 
  let cl = getRightClassHelper(c,s)
  in if cl = false
     then return nil
	 else buildError(c);


public getRightClassHelper :
  ClassId *
  seq of OmlClass ==>
  bool
getRightClassHelper(c,s) ==
  if len s = 0
  then return false
  else let h = hd(s)
       in if h.getIdentifier() = c
	      then h.hasInheritanceClause()
		  else getRightClassHelper(c,tl s);



public buildError :
  ClassId ==>
  Error
buildError(c) == 
  return mk_Error(0,0,"Class " ^ c ^ 
  " will loose inheritance clause(s), because 
  it will be promoted to interface.");


public canProceed : 
  OmlSpecifications ==>
  bool
canProceed(specs) == 
  let cl = specs.getClassList(),
      s  = gatherInfo(cl)
  in result(s);
  
  
public result :
  seq of bool ==>
  bool
result(s) ==
  let c = countFalses(s)
  in if c > 1
     then return false
	 else return true;
	 
	 
public countFalses :
  seq of bool ==>
  nat
countFalses(s) ==
  if len s = 0
  then return 0
  else if hd(s) = false
       then return 1 + countFalses(tl(s))
	   else return countFalses(tl(s));
  
  
public gatherInfo :
  seq of OmlClass ==>
  seq of bool
gatherInfo(s) == 
  return [ gatherInfoHelper(s(i)) 
    | i in set inds s & hasMI(s(i))];


public gatherInfoHelper :
  OmlClass ==>
  bool
gatherInfoHelper(c) ==
  let body = c.getClassBody(),
      name = c.getIdentifier()
  in return gatherBlocksInfo(body,name);
  
  
public gatherBlocksInfo :
  seq of OmlDefinitionBlock *
  seq of char ==>
  bool
gatherBlocksInfo(s,n) ==
  let q = [ check(s(i),n) | i in set inds s]
  in return land(q);
  
  
public check : 
  IOmlDefinitionBlock *
  seq of char ==>
  bool
check(b,n) ==
  cases true:
    (isofclass(OmlOperationDefinitions,b))
	  -> return checkOperations(b,n),
	(isofclass(OmlInstanceVariableDefinitions,b))
	  -> return checkInstanceVars(b),
	(isofclass(OmlFunctionDefinitions,b))
	  -> return checkFunctions(b),
	others
	  -> return true
  end;


public checkOperations :
  OmlOperationDefinitions *
  seq of char ==>
  bool
checkOperations(op,n) == 
  let l = op.getOperationList(),
      s = [ checkOperation(l(i),n) | i in set inds l]
  in return land(s);
  
  
public checkOperation :
  OmlOperationDefinition *
  seq of char ==>
  bool
checkOperation(op,n) ==
  let s = op.getShape()
  in cases true:
       (isofclass(OmlExplicitOperation,s))
	     -> return checkExplicitOperation(s,n),
	   (isofclass(OmlImplicitOperation,s))
	     -> return checkImplicitOperation(s,n),
	   (isofclass(OmlExtendedExplicitOperation,s))
	     -> return checkExtendedExplicitOperation(s,n),
	   others 
	     -> return true
	 end;


public checkImplicitOperation :
  OmlImplicitOperation *
  seq of char ==>
  bool
checkImplicitOperation(op,n) == 
  let c = op.getIdentifier()
  in if(n = c)
     then return false
     else return true;


public checkExplicitOperation :
  OmlExplicitOperation *
  seq of char ==>
  bool
checkExplicitOperation(op,n) == 
  let name = op.getIdentifier(),
      body = op.getBody(),
	  b = body.hasStatement()
  in return 
      not(name = n) and 
	  not(b) and 
	  ( body.getNotYetSpecified() or
		body.getSubclassResponsibility());


public checkExtendedExplicitOperation :
  OmlExtendedExplicitOperation *
  seq of char ==>
  bool
checkExtendedExplicitOperation(op,n) == 
  let name = op.getIdentifier(),
      body = op.getBody(),
	  b = body.hasStatement()
  in return 
      not(name = n) and 
	  not(b) and 
	  ( body.getNotYetSpecified() or
		body.getSubclassResponsibility());


public checkInstanceVars :
  OmlInstanceVariableDefinitions ==>
  bool
checkInstanceVars(iv) == 
  let l = iv.getVariablesList()
  in if len l = 0 
     then return true
	 else return false;


public checkFunctions :
  OmlFunctionDefinitions ==>
  bool
checkFunctions(fu) == 
  let l = fu.getFunctionList(),
      s = [ checkFunction(l(i)) | i in set inds l]
  in land(s);


public checkFunction :
  OmlFunctionDefinition ==>
  bool
checkFunction(fd) ==
  let s = fd.getShape()
  in cases true:
       (isofclass(OmlExplicitFunction,s))
	     -> return checkExplicitFunction(s),
       (isofclass(OmlImplicitFunction,s))
	     -> return true,
       (isofclass(OmlExtendedExplicitFunction,s))
	     -> return checkExtendedExplicitFunction(s),
       (isofclass(OmlTypelessExplicitFunction,s))
	     -> return checkTypelessExplicitFunction(s),
	   others
	     -> return true
	 end;


public checkExplicitFunction :
  OmlExplicitFunction ==>
  bool
checkExplicitFunction(f) == 
  let body = f.getBody()
  in if (body.hasFunctionBody() and 
         (body.getNotYetSpecified() or 
		  body.getSubclassResponsibility()))
     then return false
	 else return true;


public checkExtendedExplicitFunction :
  OmlExtendedExplicitFunction ==>
  bool
checkExtendedExplicitFunction(f) == 
  let body = f.getBody()
  in if (body.hasFunctionBody() and 
         (body.getNotYetSpecified() or 
		  body.getSubclassResponsibility()))
     then return false
	 else return true;


public checkTypelessExplicitFunction :
  OmlTypelessExplicitFunction ==>
  bool
checkTypelessExplicitFunction(f) == 
  let body = f.getBody()
  in if (body.hasFunctionBody() and 
         (body.getNotYetSpecified() or 
		  body.getSubclassResponsibility()))
     then return false
	 else return true;


public eliminate :  
  OmlSpecifications ==>
  ()
eliminate(specs) == 
  (interfaces_list := updateInterfaceList(specs);
   classes_list := updateClassList(specs))
  ;


public updateInterfaceList :
  OmlSpecifications ==>
  set of ClassId
updateInterfaceList(specs) == 
  let s = specs.getClassList(),
      l = [ let q = s(i).getInheritanceClause(),
	            k = q.getIdentifierList(),
				t = getInterfaces(k,specs)
			in t
	      | i in set inds s & hasMI(s(i))],
	  q = conc l
  in return elems q;


public getInterfaces :
  seq of (seq of char) *
  OmlSpecifications ==>
  seq of (seq of char)
getInterfaces(s,specs) == 
  let c = specs.getClassList(),
      l = [ s(i) | i in set inds s 
	        & isInterfaceIn(s(i),c)]
  in return l;
  
  
public isInterfaceIn :
  seq of char * 
  seq of OmlClass ==>
  bool
isInterfaceIn(name,cls) == 
  let c = getClass(name,cls)
  in return gatherInfoHelper(c);
  
  
public getClass : 
  seq of char *
  seq of OmlClass ==>
  OmlClass
getClass(n,s) == 
  if len s > 0
  then let head = hd(s) in 
       if head.getIdentifier() = n
       then return hd(s)
       else getClass(n,tl(s))
  else return new OmlClass();


public updateClassList :
  OmlSpecifications ==>
  set of ClassId
updateClassList(specs) == 
  let s = specs.getClassList(),
      l = [ let q = s(i).getInheritanceClause(),
	            k = q.getIdentifierList(),
				t = getClasses(k,specs)
			in t
	      | i in set inds s & hasMI(s(i))],
	  q = conc l
  in return elems q;
  
  
public getClasses :
  seq of (seq of char) *
  OmlSpecifications ==>
  seq of (seq of char)
getClasses(s,specs) == 
  let c = specs.getClassList(),
      l = [ s(i) | i in set inds s 
	        & isClassIn(s(i),c)]
  in return l;
  
  
public isClassIn :
  seq of char * 
  seq of OmlClass ==>
  bool
isClassIn(name,cls) == 
  let c = getClass(name,cls)
  in return not gatherInfoHelper(c);


------------------------------------------------
-- PRE-PROCESSOR (INHERITANCE) -----------------
------------------------------------------------


public preprocess : 
  OmlSpecifications ==>
  bool
preprocess(specs) == 
  let l = specs.getClassList()
  in return hasMultipleInheritance(l);


public hasMultipleInheritance :
  seq of OmlClass ==>
  bool
hasMultipleInheritance(s) ==
  let q = [ hasMI(s(i)) | i in set inds s]
  in lor(q); 


public lor :
  seq of bool ==>
  bool
lor(s) == 
  if len s = 0 
  then return false
  else return hd(s) or lor(tl(s));


public hasMI :
  OmlClass ==>
  bool
hasMI(c) == 
  let ic = c.getInheritanceClause()
  in if c.hasInheritanceClause()
     then let l = len ic.getIdentifierList()
	      in if l > 1 
			 then return true
			 else return false
	 else return false;


------------------------------------------------
-- PRE-PROCESSOR (TYPES) -----------------------
------------------------------------------------


public gatherTypeInfo :
  OmlSpecifications ==>
  bool
gatherTypeInfo(specs) ==
  let classes = specs.getClassList(),
      s = [ buildClassEntry(classes(i)) 
	      | i in set inds classes ]
  in return land(s);
  
  
public land :
  seq of bool ==>
  bool
land(s) == 
  if len s = 0
  then return true
  else return hd(s) and land(tl(s));


public buildClassEntry :
  OmlClass ==>
  bool
buildClassEntry(c) ==
  let cn = c.getIdentifier(),
      bl = c.getClassBody(),
      ts = buildTypeInfo(bl),
	  cl = toClassInformation(bl)
  in (
        hold_type_info := hold_type_info ++ { cn |-> ts };
		to_class := to_class ++ cl;
		return true;
     );
  
  
public toClassInformation :
  seq of IOmlDefinitionBlock ==>
  map ClassId to Information
toClassInformation(s) ==
  let l = [ s(i) | i in set inds s &
          isofclass(OmlTypeDefinitions,s(i))]
  in return buildToClassInfo(l);
  
  
public buildToClassInfo :
  seq of OmlTypeDefinitions ==>
  map ClassId to Information
buildToClassInfo(s) ==
  let l = [ s(i).getTypeList() | i in set inds s]
  in return buildToClass(conc l);
  
  
public buildToClass :
  seq of OmlTypeDefinition ==>
  map ClassId to Information
buildToClass(s) ==
  let l = [ s(i) | i in set inds s & selectShape(s(i).getShape())]
  in buildClassMap(l);
  
  
public buildClassMap :
  seq of OmlTypeDefinition ==>
  map ClassId to Information
buildClassMap(s) == 
  if len s = 0 then return {|->} else
  let fst = hd s,
      tail = tl s,
      shp = fst.getShape(),
	  access = fst.getAccess(),
	  val = buildMapValue(shp,access),
	  key = getKey(shp)
  in return { key |-> val} ++ buildClassMap(tail);
  
  
public buildMapValue :
  IOmlTypeShape * 
  OmlAccessDefinition ==>
  Information
buildMapValue(s,access) == 
  cases true:
    (isofclass(OmlComplexType,s))
	  -> return getMapValue(s,access),
	others 
	  -> return mk_Information(new JmlAccessDefinition(),[],nil)
  end;
  
  
public getMapValue :
  OmlComplexType *
  OmlAccessDefinition ==>
  Information
getMapValue(c,access) ==
  let fld = c.getFieldList(),
      iv = c.getInvariant(),
	  field = convertFieldList(fld),
	  ninv = convertInvariant(iv),
	  naccess = buildJmlAccess(access)
  in return mk_Information(naccess,field,ninv);
  
  
public convertFieldList :
  seq of OmlField ==>
  seq of JmlField
convertFieldList(s) == 
  return [ convertField(s(i)) | i in set inds s];


public convertField :
  OmlField ==>
  JmlField
convertField(f) ==
  let id = f.getIdentifier(),
      tp = f.getType(),
	  ntp = convertType(tp),
	  nid = convertId(id)
  in return new JmlField(nid,ntp);


public convertId :
  [seq of char] ==>
  seq of char
convertId(s) ==
  if s = nil then return [] else return s;


public convertInvariant :
  [OmlInvariant] ==>
  [JmlExpression]
convertInvariant(invar) == 
  if invar = nil then return nil else
  let iv = invar.getExpression(),
      ex = convertExpression(iv)
  in return ex;
  

public getKey :
  IOmlTypeShape ==>
  seq of char
getKey(s) == 
  cases true:
    (isofclass(OmlComplexType,s))
	  -> return getKeyValue(s),
	others 
	  -> return []
  end;
	
	
public getKeyValue :
  OmlComplexType ==>
  seq of char
getKeyValue(c) ==
  return c.getIdentifier();
	
	    
public selectShape :
  IOmlTypeShape ==>
  bool
selectShape(s) ==
  cases true:
    (isofclass(OmlComplexType,s))
	  -> return true,
	others
	  -> return false
  end;
  
  
public buildTypeInfo :
  seq of OmlDefinitionBlock ==>
  TypeInfo
buildTypeInfo(s) == 
  let q = collectTypeBlocks(s),
      r = collectTypeInfo(q)
  in return r;
  
  
public collectTypeBlocks :
  seq of IOmlDefinitionBlock ==>
  seq of IOmlTypeDefinitions
collectTypeBlocks(s) ==
  return [ s(i) | i in set inds s & 
    isofclass(OmlTypeDefinitions,s(i))];

  
public collectTypeInfo :
  seq of OmlTypeDefinitions ==>
  TypeInfo
collectTypeInfo(s) ==
  let q = mergeTypeDefs(s),
      l = constructTypeInfo(q),
	  m = mergeTypeInfos(l)
  in return m;


public mergeTypeDefs :
  seq of OmlTypeDefinitions ==>
  seq of OmlTypeDefinition
mergeTypeDefs(s) == 
  return conc [ s(i).getTypeList() | i in set inds s ];


public constructTypeInfo :
  seq of OmlTypeDefinition ==>
  seq of TypeInfo
constructTypeInfo(s) ==
  return [ buildTypeInfoElement(s(i)) | i in set inds s];


public buildTypeInfoElement :
  OmlTypeDefinition ==>
  TypeInfo
buildTypeInfoElement(e) ==
  let name = getTypeName(e),
      val = getConvertedType(e)
  in return {name |-> val};


public getTypeName :
  OmlTypeDefinition ==>
  seq of char
getTypeName(e) == 
  let s = e.getShape(),
      n = getNameFromShape(s)
  in return n;


public getNameFromShape :
  IOmlTypeShape ==>
  seq of char
getNameFromShape(s) == 
  cases true:
    (isofclass(OmlSimpleType,s))
	  -> return getSimpleName(s),
	(isofclass(OmlComplexType,s))
	  -> return getComplexName(s),
	others
	  -> return []
  end;


public getSimpleName :
  OmlSimpleType ==>
  seq of char
getSimpleName(s) == 
  return s.getIdentifier();


public getComplexName :
  OmlComplexType ==>
  seq of char
getComplexName(s) ==
  return s.getIdentifier();


public getConvertedType :
  OmlTypeDefinition ==> 
  JmlType
getConvertedType(e) == 
  let s = e.getShape()
  in cases true:
       (isofclass(OmlSimpleType,s))
	     -> return getConvertedTypeHelper(s),
	   others
	     -> return getClassInformation(s)
     end;


public getConvertedTypeHelper :
  OmlSimpleType ==>
  JmlType
getConvertedTypeHelper(t) == 
  let tp = t.getType(),
      nt = convertType(tp)
  in return nt;


public getClassInformation :
  OmlComplexType ==>
  IJmlType
getClassInformation(t) ==
  let id = t.getIdentifier(),
      n = new JmlName(nil,id),
	  c = new JmlClassName(n)
  in return c;


public mergeTypeInfos :
  seq of TypeInfo ==>
  TypeInfo
mergeTypeInfos(s) ==
  let r = elems s
  in return merge r;


------------------------------------------------
-- MAPPER: VDM++ TO JML ------------------------
------------------------------------------------

public build_jml : 
  OmlSpecifications ==> 
  JmlSpecifications
build_jml(specs) == 
  let classes = specs.getClassList(),
	  jml_classes = convertVdm2JmlClasses(classes)
  in return new JmlSpecifications(jml_classes);
					
					
public convertVdm2JmlClasses : 
  seq of OmlClass ==> 
  seq of JmlWrappedJmlClass
convertVdm2JmlClasses(classes) == 
  return [ convertVdm2JmlClass(classes(i)) | i in set inds classes ];


public convertVdm2JmlClass : 
  OmlClass ==> 
  JmlWrappedJmlClass
convertVdm2JmlClass(c) == 
  let id   = c.getIdentifier(),
	  inh  = c.getInheritanceClause(),
	  body = c.getClassBody(),
	  jmlclass = build_class(id, inh, body),
	  jmlimports = getJmlImports(),
	  javaimports = getJavaImports()
  in return new JmlWrappedJmlClass("","",javaimports,jmlimports,jmlclass);


--FIXME: should search jml types, and add them
public getJmlImports : 
  () ==> 
  seq of JmlModelImport
getJmlImports() == return [];


--FIXME: should search java types, and add them
public getJavaImports : 
  () ==> 
  seq of JmlImport
getJavaImports() == return [];


public build_class : 
  seq of char * 
  OmlInheritanceClause * 
  seq of OmlDefinitionBlock ==> 
  JmlClass
build_class(id,inh,body) == 
  let scope = new JmlScope(3),
	  access = new JmlAccessDefinition(scope),
	  kind = buildClassKind(id),
	  class_inh = getSuperClasses(inh),
	  inter_inh = getInterfaces(inh),
	  def_blocks = build_def_blocks(body)
  in return new JmlClass(access, kind, id, class_inh, inter_inh, def_blocks);


public buildClassKind :
  seq of char ==>
  JmlClassKind
buildClassKind(s) ==
  cases true:
    (s in set interfaces_list)
	  -> return new JmlClassKind(1),
    (s in set classes_list)
	  -> return new JmlClassKind(0),
	others
	  -> return new JmlClassKind(0)
  end;


public getInterfaces :
  [OmlInheritanceClause] ==>
  [JmlInterfaceInheritanceClause]
getInterfaces(inh) == 
  if inh = nil then return nil else 
  let list = inh.getIdentifierList()
  in if len list = 0
     then return nil
	 else let lst = [ list(i) | i in set inds list 
	                & list(i) in set interfaces_list]
		  in return new JmlInterfaceInheritanceClause(lst);


public getSuperClasses :
  [OmlInheritanceClause] ==>
  [JmlClassInheritanceClause]
getSuperClasses(inh) == 
  if inh = nil then return nil else
  let list = inh.getIdentifierList()
  in if len list = 0
     then return nil
	 else let lst = [ list(i) 
	                | i in set inds list 
					& list(i) in set classes_list ]
		  in if len lst > 1 or len lst = 0
			 then return nil
			 else return new JmlClassInheritanceClause(hd lst);


public build_def_blocks : 
  seq of IOmlDefinitionBlock ==> 
  seq of IJmlDefinitionBlock
build_def_blocks(s) == 
  return [ build_def_block(s(i)) | i in set inds s];


public build_def_block :
  IOmlDefinitionBlock ==>
  IJmlDefinitionBlock
build_def_block(b) ==
  cases true:
    (isofclass(OmlValueDefinitions,b))
	  -> return build_def_block_values(b),
	(isofclass(OmlInstanceVariableDefinitions,b))
	  -> return build_def_block_iv(b),
	(isofclass(OmlOperationDefinitions,b))
	  -> return build_def_block_op(b),
	(isofclass(OmlFunctionDefinitions,b))
	  -> return build_def_block_fun(b),
	(isofclass(OmlSynchronizationDefinitions,b))
	  -> return build_def_block_sync(b),
	(isofclass(OmlThreadDefinition,b))
	  -> return build_def_block_thread(b),
	(isofclass(OmlTraceDefinitions,b))
	  -> return build_def_block_trace(b),
	others
	  -> ( log := log union {mk_Error(b.getLine(),b.getColumn(),b.identity())};
	       return build_def_block_type(b))
  end;


-----------------------------------------------------
-- Values -------------------------------------------
-----------------------------------------------------


public build_def_block_values : 
  OmlValueDefinitions ==> 
  JmlValueDefinitions
build_def_block_values(t) == 
  let val = t.getValueList(),
	  res = buildValueList(val)
  in return new JmlValueDefinitions(res);


public buildValueList : 
  seq of OmlValueDefinition ==> 
  seq of JmlValueDefinition
buildValueList(s) == 
  return [ buildJmlValue(s(i)) | i in set inds s];


public buildJmlValue : 
  OmlValueDefinition ==> 
  JmlValueDefinition
buildJmlValue(val) == 
  let access = val.getAccess(),
	  shape = val.getShape(),
	  newAccess = buildJmlAccess(access),
	  newShape = buildJmlShape(shape)
  in return new JmlValueDefinition(newAccess,true,true,newShape);
				
					  	  
public buildJmlAccess : 
  OmlAccessDefinition ==> 
  JmlAccessDefinition
buildJmlAccess(a) == 
  let scope = a.getScope(),
	  res   = buildJmlScope(scope)
      in return new JmlAccessDefinition(res);


public buildJmlScope : 
  OmlScope ==> 
  JmlScope
buildJmlScope(s) == 
  let val = s.getValue()
  in cases true:
       (val = 0)
	     -> return new JmlScope(0),
	   (val = 1)
	     -> return new JmlScope(1),
	   (val = 2)
	     -> return new JmlScope(3),
	   others
	     -> return new JmlScope(2)
     end;


public buildJmlShape : 
  OmlValueShape ==> 
  JmlValueShape
buildJmlShape(s) == 
  let p = s.getPattern(),
	  t = s.getType(),
	  e = s.getExpression(),
	  id = getIdentifier(p),
	  tp = convertType(t),
	  exp = convertExpression(e)
  in return new JmlValueShape(id, tp, exp);


public getIdentifier : 
  OmlPatternIdentifier ==> 
  seq of char
getIdentifier(p) == 
  return p.getIdentifier();


-----------------------------------------------------
-- Instance variables -------------------------------
-----------------------------------------------------


public build_def_block_iv : 
  OmlInstanceVariableDefinitions ==> 
  JmlInstanceVariableDefinitions
build_def_block_iv(v) == 
  let s = buildVariablesList(v)
  in return new JmlInstanceVariableDefinitions(s,[]);


public buildVariablesList : 
  OmlInstanceVariableDefinitions ==> 
  seq of [JmlVariable]
buildVariablesList(s) == 
  let q = s.getVariablesList()
  in return [ buildVariables(q(i)) | 
     i in set inds q & isofclass(OmlInstanceVariable,q(i)) ];


public buildVariables : 
  OmlInstanceVariable ==> 
  JmlVariable
buildVariables(var) == 
  let access = var.getAccess(),
      scope = access.getScope(),
      assign = var.getAssignmentDefinition(),
      newScope = new JmlScope(scope.getValue()),
      newAccess = new JmlAccessDefinition(newScope),
      stat = access.getStaticAccess(),
      tp = convertType(assign.getType()),
      id = assign.getIdentifier(),              
      expr = convertExpression(assign.getExpression())
  in return new JmlVariable(newAccess, true, stat, 
                            false, tp, id, expr);


-----------------------------------------------------
-- Operations ---------------------------------------
-----------------------------------------------------


public build_def_block_op : 
  OmlOperationDefinitions ==> 
  JmlOperationDefinitions
build_def_block_op(t) == 
  let s = t.getOperationList(),
	  res = convertOperationList(s)
  in return new JmlOperationDefinitions(res);


public convertOperationList : 
  seq of OmlOperationDefinition ==> 
  seq of JmlOperationDefinition
convertOperationList(s) == 
  return [ convertOperation(s(i)) | i in set inds s ];


public convertOperation : 
  OmlOperationDefinition ==> 
  JmlOperationDefinition
convertOperation(op) == 
  let access = op.getAccess(),
	  scope = access.getScope(),
	  static_val = access.getStaticAccess(),
	  newScope = buildJmlScope(scope),
	  newAccess = new JmlAccessDefinition(newScope),
	  shape = op.getShape()
  in return buildJmlOperation(newAccess,static_val,shape);
						

public buildJmlOperation :
  JmlAccessDefinition *
  bool *
  IOmlOperationShape ==>
  JmlOperationDefinition
buildJmlOperation(access,statickey,shape) ==
  cases true:
    (isofclass(OmlImplicitOperation,shape))
	  -> return buildImplicitJmlOperation(access,statickey,shape),
	(isofclass(OmlExplicitOperation,shape))
	  -> return buildExplicitJmlOperation(access,statickey,shape),
	(isofclass(OmlExtendedExplicitOperation,shape))
	  -> return buildExtendedJmlOperation(access,statickey,shape),
	others
	  -> ( log := log union {mk_Error(shape.getLine(),shape.getColumn(),shape.identity())};
	       return new JmlOperationDefinition())
  end;

public buildImplicitJmlOperation : 
  JmlAccessDefinition * 
  bool * 
  OmlImplicitOperation ==>
  JmlOperationDefinition
buildImplicitJmlOperation(access,statickey,shape) == 
  let id = shape.getIdentifier(),
	  params = shape.getPatternTypePairList(),
	  returns = shape.getIdentifierTypePairList(),
	  trailer = shape.getTrailer(),
	  newTrailer = buildOperationTrailer(trailer,access),
	  returnType = buildReturnType(returns),
	  newParams = buildParameters(params)
  in return new JmlOperationDefinition(newTrailer,access,
        true,statickey,false,returnType,id,newParams,nil);


public buildExplicitJmlOperation : 
  JmlAccessDefinition * 
  bool *
  OmlExplicitOperation ==>
  JmlOperationDefinition
buildExplicitJmlOperation(access,statickey,shape) == 
  let id = shape.getIdentifier(),
      tp = shape.getType(),
      type_rng = getRngType(tp),
      params = shape.getParameterList(),
      trailer = buildOperationTrailer(shape.getTrailer(),access),
      paramsList = buildOperationParameters(params,tp),
      body = "Body ignored in operation " ^ id,
	  res = new JmlOperationDefinition(trailer,access,true,
       statickey,false,type_rng,id,paramsList,nil)
  in if(shape.getBody().hasStatement())
     then (log := log union {mk_Error(shape.getLine(),shape.getColumn(),body)};
           return res)
	 else return res;


public buildExtendedJmlOperation : 
  JmlAccessDefinition * 
  bool *
  OmlExtendedExplicitOperation ==>
  JmlOperationDefinition
buildExtendedJmlOperation(access,statickey,shape) ==
  let id = shape.getIdentifier(),
      params = shape.getPatternTypePairList(),
	  returns = shape.getIdentifierTypePairList(),
	  trailer = shape.getTrailer(),
	  newTrailer = buildOperationTrailer(trailer,access),
	  returnType = buildReturnType(returns),
	  newParams = buildParameters(params),
      body = "Body ignored in operation " ^ id,
	  res = new JmlOperationDefinition(newTrailer,access,true,
         statickey,false,returnType,id,newParams,nil)
  in if(shape.getBody().hasStatement())
     then (log := log union {mk_Error(shape.getLine(),shape.getColumn(),body)};
           return res)
	 else return res;


public buildOperationParameters : 
  seq of OmlPattern * 
  OmlOperationType ==> 
  seq of JmlParameter
buildOperationParameters(s,t) == 
  let domtype = t.getDomType()
  in return buildOperationParameter(s,domtype);


public buildOperationParameter :
  seq of OmlPattern *
  IOmlType ==>
  seq of JmlParameter
buildOperationParameter(s,t) == 
  cases true:
    (isofclass(OmlProductType,t)) 
	  -> return unfoldProductType(s,t),
	others 
	  -> return buildJmlParameter(s,t)
  end;


public unfoldProductType : 
  seq of OmlPattern *
  OmlProductType ==>
  seq of JmlParameter
unfoldProductType(s,t) ==
  let ts = buildSeqTypes(t),
      p  = extractPatterns(s),
	  f  = buildParameterSeq(p,ts)
  in return f;


public buildSeqTypes :
  OmlProductType ==>
  seq of OmlType
buildSeqTypes(p) == 
  let rhs = p.getRhsType(),
      lhs = p.getLhsType()
  in return (extractProductType(rhs) ^ 
  extractProductType(lhs));


public extractProductType : 
  IOmlType ==>
  seq of OmlType
extractProductType(t) == 
  cases true:
    (isofclass(OmlProductType,t))
	  -> return buildSeqTypes(t),
	others
	  -> return [ t ]
  end;


public extractPatterns :
  seq of OmlPattern ==>
  seq of (seq of char)
extractPatterns(s) == 
  return [ extractPattern(s(i)) | i in set inds s];


public extractPattern :
  IOmlPattern ==>
  seq of char
extractPattern(p) ==
  cases true:
    (isofclass(OmlPatternIdentifier,p))
	  -> return getId(p),
	others
	  -> ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
	       return [])
  end;


public buildParameterSeq :
  seq of (seq of char) *
    seq of OmlType ==>
  seq of JmlParameter
buildParameterSeq(p,t) ==
  if len p <> len t 
  then return []
  else return 
    [ let nt = convertType(t(i)),
	      v = p(i)  
	  in new JmlParameter(nt,v)
	| i in set inds p];


public buildJmlParameter :
  seq of OmlPattern *
  OmlType ==>
  seq of JmlParameter
buildJmlParameter(s,t) == 
  if len s = 0 or len s > 1
  then return []
  else
  let tp = convertType(t),
      fst = hd(s),
	  id = getIds(fst),
	  par = new JmlParameter(tp,id)
  in return [par];
	  
	  
public getIds : 
  IOmlPattern ==>
  seq of char
getIds(p) ==
  cases true:
    (isofclass(OmlPatternIdentifier,p))
	  -> return getId(p),
	others 
	  -> ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
	       return [])
  end;
  
  
public getId :
  OmlPatternIdentifier ==>
  seq of char
getId(p) ==
  return p.getIdentifier();


public buildReturnType : 
  seq of OmlIdentifierTypePair ==> 
  IJmlType
buildReturnType(s) ==
  if len s > 1
  then let q = [ convertType(s(i).getType()) | i in set inds s ],
           t = new JmlTupleType(q)
	   in return t
  else let t = s(1).getType()
       in return convertType(t);


public buildParameters : 
  seq of OmlPatternTypePair ==> 
  seq of JmlParameter
buildParameters(s) == 
  return conc [ buildParameter(s(i)) | i in set inds s];


public buildParameter : 
  OmlPatternTypePair ==> 
  seq of JmlParameter
buildParameter(p) == 
  let s = p.getPatternList(),
	  t = p.getType()
  in return [ buildParam(s(i),t) | i in set inds s];


public buildParam : 
  OmlPatternIdentifier * 
  OmlType ==> 
  JmlParameter
buildParam(p,t) == 
  let tp = convertType(t),
	  id = p.getIdentifier()
  in return new JmlParameter(tp,id);


public buildOperationTrailer : 
  OmlOperationTrailer *
  JmlAccessDefinition ==> 
  [JmlMethodSpecifications]
buildOperationTrailer(trailer,access) ==
  let ex = trailer.getExternals(),
	  pr = trailer.getPreExpression(),
	  po = trailer.getPostExpression(),
	  ep = trailer.getExceptions()
  in let normal = buildNormalBehaviour(ex,pr,po,ep,
                  access.getScope().getValue()),
		 spec = new JmlSpecs(normal),
		 also = new JmlSpecs([])
	 in return new JmlMethodSpecifications(spec,also);


public buildError : 
  OmlError ==> 
  JmlRequiresClause
buildError(e) ==
  let expr = convertExpression(e.getLhs())
  in return new JmlRequiresClause(expr);


public buildNormalBehaviour : 
  [OmlExternals] *
  [OmlExpression] *
  [OmlExpression] *
  [OmlExceptions] *
  nat ==>
  seq of JmlNormalSpec
buildNormalBehaviour(ex,pr,po,ep,n) == 
  let externals = buildAssignableClause(ex),
      pres = buildRequiresClause(pr,ep),
	  posts = buildEnsuresClause(po,ep),
	  trailers = externals ^ pres ^ posts,
	  scope = new JmlScope(n)
  in return [new JmlNormalSpec(scope,trailers) ];


--------------------------
-- Assignable Clause -----
--------------------------


public buildAssignableClause : 
  [OmlExternals] ==> 
  seq of JmlAssignableClause
buildAssignableClause(e) == 
  if e = nil then return [] else
  let list = e.getExtList(),
      res = [ getExternalNames(list(i).getNameList()) 
	          | i in set inds list ]
  in return res;


public getExternalNames : 
  seq of OmlName ==> 
  JmlAssignableClause
getExternalNames(s) == 
  let l = [ s(i).getIdentifier() | i in set inds s]
  in return new JmlAssignableClause(l);


--------------------------
-- Requires Clause -------
--------------------------


public buildRequiresClause : 
  [OmlExpression] * 
  [OmlExceptions] ==> 
  seq of JmlRequiresClause
buildRequiresClause(pres,exc) ==
  if (pres = nil and exc = nil) then return [] else 
  let exceptions = buildDisjunctions(exc),
      precond = convertExpression(pres),
	  final_pre = chooserDisj(exceptions,precond),
	  req = new JmlRequiresClause(final_pre)
  in return [ req ];


public chooserDisj :
  [IJmlExpression] *
  [IJmlExpression] ==>
  IJmlExpression
chooserDisj(exc,expr) ==
  cases true:
    (exc = nil) -> return expr,
	(expr = nil) -> return exc,
	others -> 
	  let op = new JmlBinaryOperator(1),
	  final_pre = new JmlBinaryExpression(expr,op,exc)
	in return final_pre
  end;


public buildDisjunctions : 
  [OmlExceptions] ==> 
  [IJmlExpression]
buildDisjunctions(exc) == 
  if exc = nil then return nil else 
  let l = exc.getErrorList()
  in if len l = 0 
     then let lit = new JmlBooleanLiteral(true),
	          expr = new JmlLiteralExpression(lit)
		  in return expr
     else return buildDisjunction(l);


public buildDisjunction : 
  seq of OmlError ==> 
  IJmlExpression
buildDisjunction(s) == 
  if len s = 0 
  then let lit = new JmlBooleanLiteral(true),
           exp = new JmlLiteralExpression(lit)
	   in return exp
  else let erro = hd(s),
           e = erro.getLhs(),
		   expr = convertExpression(e),
		   op = new JmlBinaryOperator(1),
		   rhs = buildDisjunction(tl(s))
	   in return new JmlBinaryExpression(expr,op, rhs);


--------------------------
-- Ensures Clause --------
--------------------------


public buildEnsuresClause : 
  [OmlExpression] * 
  [OmlExceptions] ==> 
  seq of JmlEnsuresClause
buildEnsuresClause(po,ex) ==
  if (po = nil and ex = nil) then return [] else 
  let postexpr = convertExpression(po),
      conj = buildConjunctions(ex),
	  finalpost = chooserConj(conj,postexpr),
	  ens = new JmlEnsuresClause(finalpost)
  in return [ ens ];
  
  
public chooserConj :
  [IJmlExpression] *
  [IJmlExpression] ==>
  IJmlExpression
chooserConj(exc,expr) ==
  cases true:
    (exc = nil) -> return expr,
	(expr = nil) -> return exc,
	others -> 
	  let op = new JmlBinaryOperator(11),
	      finalpost = new JmlBinaryExpression(expr,op,exc)
	in return finalpost
  end;
  
  
public buildConjunctions : 
  [OmlExceptions] ==>
  [IJmlExpression]
buildConjunctions(except) ==
  if except = nil then return nil else 
  let errlst = except.getErrorList()
  in if len errlst = 0
     then let lit = new JmlBooleanLiteral(true),
	          expr = new JmlLiteralExpression(lit)
		  in return expr
     else return buildConjunction(errlst);
	 
	 
public buildConjunction :
  seq of OmlError ==>
  IJmlExpression
buildConjunction(s) ==
  if len s = 0 
  then let lit = new JmlBooleanLiteral(true),
           exp = new JmlLiteralExpression(lit)
	   in return exp
  else let erro = hd(s),
           e = erro.getLhs(),
		   expr = convertExpression(e),
		   op = new JmlBinaryOperator(11),
		   rhs = buildConjunction(tl(s))
	   in return new JmlBinaryExpression(expr,op, rhs);

-----------------------------------------------------
-- Other constructs ---------------------------------
-----------------------------------------------------


--FIXME: a function can be mapped. Think about this.
public build_def_block_fun : 
  OmlFunctionDefinitions ==> 
  JmlOtherDefinitions
build_def_block_fun(p) == 
  ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
    return new JmlOtherDefinitions());


public build_def_block_sync : 
  OmlSynchronizationDefinitions ==> 
  JmlOtherDefinitions
build_def_block_sync(p) == 
  ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
    return new JmlOtherDefinitions());


public build_def_block_thread : 
  OmlThreadDefinition ==> 
  JmlOtherDefinitions
build_def_block_thread(p) == 
  ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
    return new JmlOtherDefinitions());


public build_def_block_trace : 
  OmlTraceDefinitions ==> 
  JmlOtherDefinitions
build_def_block_trace(p) == 
  ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
    return new JmlOtherDefinitions());


public build_def_block_type : 
  OmlTypeDefinitions ==> 
  JmlOtherDefinitions
build_def_block_type(-) == 
  return new JmlOtherDefinitions();


-----------------------------------------------------
-- Convert Types ------------------------------------
-----------------------------------------------------


public convertType : 
  IOmlType ==> 
  IJmlType
convertType(t) ==
  cases true:
    (isofclass(OmlBracketedType,t))
	  -> return convertBracketedType(t),
	(isofclass(OmlBoolType,t))
	  -> return new JmlBoolType(),
	(isofclass(OmlNatType,t))
	  -> return new JmlNatType(0),
	(isofclass(OmlNat1Type,t))
	  -> return new JmlNatType(1),
	(isofclass(OmlIntType,t))
	  -> return new JmlIntegerType(),
	(isofclass(OmlRealType,t))
	  -> return new JmlFloatType(),
	(isofclass(OmlCharType,t))
	  -> return new JmlCharType(),
	(isofclass(OmlTokenType,t))
	  -> return new JmlObjectType(),
	(isofclass(OmlQuoteType,t))
	  -> return convertQuoteType(t),
	(isofclass(OmlCompositeType,t))
	  -> return convertCompositeType(t), 
	(isofclass(OmlProductType,t))
	  -> return convertProductType(t),
	(isofclass(OmlSetType,t))
	  -> return convertSetType(t),
	(isofclass(OmlSeq0Type,t))
	  -> return convertSeq0Type(t),
	(isofclass(OmlSeq1Type,t))
	  -> return convertSeq1Type(t),
	(isofclass(OmlGeneralMapType,t))
	  -> return convertMapType(t),
	(isofclass(OmlEmptyType,t))
	  -> return new JmlVoidType(),
	(isofclass(OmlTypeName,t))
	  -> convertTypeName(t),
	others 
	  -> ( log := log union {mk_Error(t.getLine(),t.getColumn(),t.identity())};
	       return new JmlVoidType())
  end;


public convertBracketedType :
  OmlBracketedType ==>
  JmlType
convertBracketedType(t) ==
  return convertType(t.getType());


public convertQuoteType :
  OmlQuoteType ==>
  JmlEnumerationType
convertQuoteType(t) ==
  let q = t.getQuoteLiteral(),
      id = q.getVal(),
      l = new JmlEnumLiteral(id)
  in return new JmlEnumerationType(l);


public convertProductType :
  OmlProductType ==>
  JmlTupleType
convertProductType(t) ==
  let tp = buildSeqTypes(t),
      sq = [ convertType(tp(i)) | i in set inds tp ]
  in return new JmlTupleType(sq);


public convertCompositeType :
  OmlCompositeType ==>
  JmlClassType
convertCompositeType(t) ==
  let id = t.getIdentifier()
  in return new JmlClassType(id,[]);


public convertSetType :
  OmlSetType ==>
  JmlSetValueType
convertSetType(t) == 
  let tp = t.getType(),
      newtp = convertType(tp)
  in return new JmlSetValueType(newtp);


public convertSeq0Type :
  OmlSeq0Type ==>
  JmlSeqValueType
convertSeq0Type(t) ==
  let tp = t.getType(),
      newtp = convertType(tp)
  in return new JmlSeqValueType(newtp,0);
  
  
public convertSeq1Type :
  OmlSeq0Type ==>
  JmlSeqValueType
convertSeq1Type(t) ==
  let tp = t.getType(),
      newtp = convertType(tp)
  in return new JmlSeqValueType(newtp,1);


public convertMapType :
  OmlGeneralMapType ==>
  JmlMapValueToValueType
convertMapType(t) ==
  let mapdom = t.getDomType(),
	  maprng = t.getRngType(),
      newdom = convertType(mapdom),
      newrng = convertType(maprng)
  in return new JmlMapValueToValueType(newdom,newrng);


public convertTypeName :
  OmlTypeName ==>
  JmlClassName
convertTypeName(t) ==
  let id = t.getName(),
      newid = convertName(id)
  in return new JmlClassName(newid);


public getDomType : 
  OmlOperationType ==> 
  JmlType
getDomType(op) == 
  return convertType(op.getDomType());


public getRngType : 
  OmlOperationType ==> 
  JmlType
getRngType(op) == 
  return convertType(op.getRngType());


-----------------------------------------------------
-- Convert Expressions ------------------------------
-----------------------------------------------------


public convertExpression : 
  [IOmlExpression] ==> 
  [IJmlExpression]
convertExpression(e) ==
  if e = nil then return nil else
  cases true:
    (isofclass(OmlBracketedExpression,e))
	  -> return convertBracketedExpression(e),
    (isofclass(OmlLetExpression,e))
	  -> return convertLetExpression(e),
	(isofclass(OmlIfExpression,e))
	  -> return convertIfExpression(e),
	(isofclass(OmlUnaryExpression,e))
	  -> return convertUnaryExpression(e),
	(isofclass(OmlBinaryExpression,e))
	  -> return convertBinaryExpression(e),
	(isofclass(OmlForAllExpression,e))
	  -> return convertForAllExpression(e),
	(isofclass(OmlExistsExpression,e))
	  -> return convertExistsExpression(e),
	(isofclass(OmlSetEnumeration,e))
	  -> return convertSetEnumeration(e),
	(isofclass(OmlSequenceEnumeration,e))
	  -> return convertSequenceEnumeration(e),
	(isofclass(OmlMapEnumeration,e))
	  -> return convertMapEnumeration(e),
	(isofclass(OmlTupleConstructor,e))
	  -> return convertTupleConstructor(e),
	(isofclass(OmlRecordConstructor,e))
	  -> return convertRecordExpression(e),
	(isofclass(OmlApplyExpression,e))
	  -> return convertApplyExpression(e),
	(isofclass(OmlFieldSelect,e))
	  -> return convertFieldSelect(e),
	(isofclass(OmlNewExpression,e))
	  -> return convertNewExpression(e),
	(isofclass(OmlSelfExpression,e))
	  -> return convertSelfExpression(e),
	(isofclass(OmlIsExpression,e))
	  -> return convertIsExpression(e),
	(isofclass(OmlUndefinedExpression,e))
	  -> return convertUndefinedExpression(e),
	(isofclass(OmlIsofclassExpression,e))
	  -> return convertIsOfClassExpression(e),
	(isofclass(OmlName,e))
	  -> return convertName(e),
	(isofclass(OmlOldName,e))
	  -> return convertOldName(e),
	(isofclass(OmlSymbolicLiteralExpression,e))
	  -> return convertLiteralExpression(e),
	others
	  -> ( log := log union {mk_Error(e.getLine(),e.getColumn(),e.identity())};
	       return nil)
  end;
  
  
public convertBracketedExpression :
  OmlBracketedExpression ==>
  JmlBracketedExpression
convertBracketedExpression(e) ==
  let exp = e.getExpression(),
      newexpr = convertExpression(exp)
  in return new JmlBracketedExpression(newexpr);
  
  
public convertLetExpression :
  OmlLetExpression ==>
  JmlBlockExpression
convertLetExpression(e) ==
  let bind = e.getDefinitionList(),
      newbind = buildJmlShapes(bind),
	  expr = e.getExpression(),
	  res = convertExpression(expr)
  in return new JmlBlockExpression(newbind,res);
  
  
public buildJmlShapes :
  seq of OmlValueShape ==>
  seq of JmlValueShape
buildJmlShapes(s) ==
  return [ buildJmlShape(s(i)) | i in set inds s];
  
  
public convertIfExpression :
  OmlIfExpression ==>
  JmlIfExpression
convertIfExpression(e) ==
  let if_expr = e.getIfExpression(),
      then_expr = e.getThenExpression(),
	  else_expr = e.getElseExpression(),
	  newif = convertExpression(if_expr),
	  newthen = convertExpression(then_expr),
	  newelse = convertExpression(else_expr)
  in return new JmlIfExpression(newif,newthen,newelse);
  
  
public convertUnaryExpression :
  OmlUnaryExpression ==>
  JmlUnaryExpression
convertUnaryExpression(e) ==
  let op = e.getOperator(),
      newop = convertUnaryOperator(op),
	  expr = e.getExpression(),
	  newexpr = convertExpression(expr)
  in return new JmlUnaryExpression(newop,newexpr);
  
  
public convertUnaryOperator :
  OmlUnaryOperator ==>
  JmlUnaryOperator
convertUnaryOperator(op) == 
  let val = op.getValue()
  in cases true:
       (val = 0) -> return new JmlUnaryOperator(4),
	   (val = 1) -> return new JmlUnaryOperator(5),
	   (val = 2) -> return new JmlUnaryOperator(10),
	   (val = 3) -> return new JmlUnaryOperator(7),
	   (val = 5) -> return new JmlUnaryOperator(2),
	   (val = 6) -> return new JmlUnaryOperator(0),
	   (val = 8) -> return new JmlUnaryOperator(6),
	   (val = 9) -> return new JmlUnaryOperator(14),
	   (val = 10) -> return new JmlUnaryOperator(12),
	   (val = 11) -> return new JmlUnaryOperator(8),
	   (val = 14) -> return new JmlUnaryOperator(15),
	   (val = 15) -> return new JmlUnaryOperator(1),
	   (val = 16) -> return new JmlUnaryOperator(13),
	   (val = 17) -> return new JmlUnaryOperator(3),
	   others -> ( log := log union {mk_Error(op.getLine(),op.getColumn(),op.identity())};
	               return new JmlUnaryOperator())
     end ;
  
  
public convertBinaryExpression :
  OmlBinaryExpression ==>
  JmlBinaryExpression
convertBinaryExpression(e) ==
  let lhs = e.getLhsExpression(),
      op = e.getOperator(),
	  rhs = e.getRhsExpression(),
	  newlhs = convertExpression(lhs),
	  newrhs = convertExpression(rhs),
	  newop = convertBinaryOperator(op)
  in return new JmlBinaryExpression(newlhs,newop,newrhs);
  
  
public convertBinaryOperator :
  OmlBinaryOperator ==>
  JmlBinaryOperator
convertBinaryOperator(op) ==
  let val = op.getValue()
  in cases true:
       (val = 1) -> return new JmlBinaryOperator(18),
	   (val = 2) -> return new JmlBinaryOperator(23),
	   (val = 3) -> return new JmlBinaryOperator(13),
	   (val = 6) -> return new JmlBinaryOperator(22),
	   (val = 7) -> return new JmlBinaryOperator(33),
	   (val = 8) -> return new JmlBinaryOperator(1),
	   (val = 10) -> return new JmlBinaryOperator(16),
	   (val = 11) -> return new JmlBinaryOperator(0),
	   (val = 12) -> return new JmlBinaryOperator(12),
	   (val = 13) -> return new JmlBinaryOperator(4),
	   (val = 14) -> return new JmlBinaryOperator(15),
	   (val = 16) -> return new JmlBinaryOperator(28),
	   (val = 19) -> return new JmlBinaryOperator(6),
	   (val = 20) -> return new JmlBinaryOperator(34),
	   (val = 21) -> return new JmlBinaryOperator(32),
	   (val = 22) -> return new JmlBinaryOperator(2),
	   (val = 23) -> return new JmlBinaryOperator(8),
	   (val = 24) -> return new JmlBinaryOperator(30),
	   (val = 25) -> return new JmlBinaryOperator(31),
	   (val = 26) -> return new JmlBinaryOperator(14),
	   (val = 27) -> return new JmlBinaryOperator(7),
	   (val = 30) -> return new JmlBinaryOperator(21),
	   (val = 31) -> return new JmlBinaryOperator(24),
	   (val = 32) -> return new JmlBinaryOperator(19),
	   (val = 33) -> return new JmlBinaryOperator(9),
	   others -> ( log := log union {mk_Error(op.getLine(),op.getColumn(),op.identity())};
	               return new JmlBinaryOperator())
     end;
  
  
public convertForAllExpression :
  OmlForAllExpression ==>
  JmlForAllExpression
convertForAllExpression(e) ==
  let bind = e.getBindList(),
      expr = e.getExpression(),
	  newexpr = convertExpression(expr)
  in return buildForAllExpression(bind,newexpr);
  
  
public buildForAllExpression :
  seq of OmlBind * 
  JmlExpression ==>
  JmlForAllExpression
buildForAllExpression(bind,expr) ==
  if len bind > 1
  then let b = buildBind(hd bind),
	       e = buildForAllExpression(tl bind,expr)
	   in return new JmlForAllExpression(b,[e])
  else let b = buildBind(hd bind)
       in return new JmlForAllExpression(b,[expr]);
  
  
public buildBind :
  IOmlBind ==>
  JmlQuantifierDeclaration
buildBind(b) == 
  cases true:
    (isofclass(OmlTypeBind,b))
	  -> return buildTypeBinds(b),
	others 
	  -> return new JmlQuantifierDeclaration()
  end;
  
  
public buildTypeBinds :
  OmlTypeBind ==>
  JmlQuantifierDeclaration
buildTypeBinds(b) == 
  let p = b.getPattern(),
      t = b.getType()
  in buildTypeBind(p,t);
  
  
public buildTypeBind :
  seq of IOmlPattern *
  IOmlType ==>
  JmlQuantifierDeclaration
buildTypeBind(p,t) ==
  let s = getVars(p),
      t1 = convertType(t)
  in return new JmlQuantifierDeclaration(nil,t1,s);
  
  
public getVars :
  seq of IOmlPattern ==>
  seq of (seq of char)
getVars(s) ==
  return [ getVar(s(i)) | i in set inds s];


public getVar :
  IOmlPattern ==>
  seq of char
getVar(p) ==
  cases true:
    (isofclass(OmlPatternIdentifier,p))
	  -> return getId(p),
	others
	  -> ( log := log union {mk_Error(p.getLine(),p.getColumn(),p.identity())};
	       return [])
  end;

  
public convertExistsExpression :
  OmlExistsExpression ==>
  JmlExistsExpression
convertExistsExpression(e) == 
  let bind = e.getBindList(),
      expr = e.getExpression(),
	  newexpr = convertExpression(expr)
  in return buildExistsExpression(bind,newexpr);
  

public buildExistsExpression :
  seq of OmlBind * 
  JmlExpression ==>
  JmlExistsExpression
buildExistsExpression(bind,expr) ==
  if len bind > 1
  then let b = buildBind(hd bind),
	       e = buildExistsExpression(tl bind,expr)
	   in return new JmlExistsExpression(b,[e])
  else let b = buildBind(hd bind)
       in return new JmlExistsExpression(b,[expr]);
  
  
public convertSetEnumeration :
  OmlSetEnumeration ==>
  JmlSetEnumeration
convertSetEnumeration(e) ==
  let v = e.getExpressionList(),
      s = [ convertExpression(v(i)) | i in set inds v]
  in return new JmlSetEnumeration(s);
  
  
public convertSequenceEnumeration :
  OmlSequenceEnumeration ==>
  JmlSequenceEnumeration
convertSequenceEnumeration(e) ==
  let v = e.getExpressionList(),
      s = [ convertExpression(v(i)) | i in set inds v]
  in return new JmlSequenceEnumeration(s);
  
  
public convertMapEnumeration :
  OmlMapEnumeration ==>
  JmlMapEnumeration
convertMapEnumeration(e) ==
  let m = e.getMapletList(),
      s = convertMapLetList(m)
  in return new JmlMapEnumeration(s);
  
  
public convertMapLetList :
  seq of OmlMaplet ==>
  seq of JmlMapLet
convertMapLetList(s) ==
  return [ convertMapLet(s(i)) | i in set inds s];
  
  
public convertMapLet :
  OmlMaplet ==>
  JmlMapLet
convertMapLet(e) ==
  let d = e.getDomExpression(),
      r = e.getRngExpression(),
	  dm = convertExpression(d),
	  rn = convertExpression(r)
  in return new JmlMapLet(dm,rn);
  
  
public convertTupleConstructor :
  OmlTupleConstructor ==>
  JmlNewExpression
convertTupleConstructor(e) ==
  let s = e.getExpressionList(),
      q = convertExpressionList(s),
	  t = new JmlTupleType()
  in return new JmlNewExpression(t,q);
  
  
public convertExpressionList :
  seq of OmlExpression ==>
  seq of JmlExpression
convertExpressionList(s) ==
  return [ convertExpression(s(i)) | i in set inds s];
  
  
public convertRecordExpression :
  OmlRecordConstructor ==>
  JmlNewExpression
convertRecordExpression(e) ==
  let n = e.getName(),
      s = e.getExpressionList(),
	  q = convertExpressionList(s),
	  nn = convertName(n),
	  t = new JmlClassName(nn)
  in return new JmlNewExpression(t,q);
  

public convertApplyExpression :
  OmlApplyExpression ==>
  JmlApplyExpression
convertApplyExpression(e) ==
  let exp = e.getExpression(),
      lst = e.getExpressionList(),
	  nexp = convertExpression(exp),
	  nlst = convertExpressionList(lst)
  in return new JmlApplyExpression(nexp,nlst);
  
  
public convertFieldSelect :
  OmlFieldSelect ==>
  JmlFieldSelectExpression
convertFieldSelect(e) ==
  let exp = e.getExpression(),
      n = e.getName(),
      nexp = convertExpression(exp),
	  nn = convertName(n)
  in return new JmlFieldSelectExpression(nexp,nn);


public convertName :
  OmlName ==>
  JmlName
convertName(n) ==
  let c = n.getClassIdentifier(),
      id = n.getIdentifier()
  in return new JmlName(c,id);


public convertNewExpression :
  OmlNewExpression ==>
  JmlNewExpression
convertNewExpression(e) ==
  let n = e.getName(),
      l = e.getExpressionList(),
	  nn = convertName(n),
	  t = new JmlClassName(nn),
	  nl = convertExpressionList(l)
  in return new JmlNewExpression(t,nl);

  
public convertSelfExpression :
  OmlSelfExpression ==>
  JmlThisExpression
convertSelfExpression(-) ==
  return new JmlThisExpression();
  
  
public convertIsExpression :
  OmlIsExpression ==>
  JmlInstanceOfExpression
convertIsExpression(e) ==
  let t = e.getType(),
      exp = e.getExpression(),
	  nt = convertType(t),
	  nexp = convertExpression(exp)
  in return new JmlInstanceOfExpression(nt,nexp);
  

public convertUndefinedExpression :
  OmlUndefinedExpression ==>
  JmlUndefinedExpression
convertUndefinedExpression(-) ==
  return new JmlUndefinedExpression();


public convertIsOfClassExpression :
  OmlIsofclassExpression ==>
  JmlInstanceOfExpression
convertIsOfClassExpression(e) ==
  let n = e.getName(),
      nn = convertName(n),
	  t = new JmlClassName(nn),
	  exp = e.getExpression(),
	  nexp = convertExpression(exp)
  in return new JmlInstanceOfExpression(t,nexp);


public convertOldName :
  OmlOldName ==>
  JmlOldName
convertOldName(n) ==
  return new JmlOldName(n.getIdentifier());
  
  
public convertLiteralExpression :
  OmlSymbolicLiteralExpression ==>
  JmlLiteralExpression
convertLiteralExpression(e) ==
  let lit = e.getLiteral(),
      nlit = convertLiteral(lit)
  in return new JmlLiteralExpression(nlit);


-----------------------------------------------------
-- Convert Literals ---------------------------------
-----------------------------------------------------
  
  
public convertLiteral :
  IOmlLiteral ==>
  IJmlLiteral
convertLiteral(l) ==
  cases true:
    (isofclass(OmlNumericLiteral,l))
	  -> convertNumericLiteral(l),
	(isofclass(OmlRealLiteral,l))
	  -> convertRealLiteral(l),
	(isofclass(OmlBooleanLiteral,l))
	  -> convertBooleanLiteral(l),
	(isofclass(OmlNilLiteral,l))
	  -> convertNilLiteral(l),
	(isofclass(OmlCharacterLiteral,l))
	  -> convertCharacterLiteral(l),
	(isofclass(OmlTextLiteral,l))
	  -> convertTextLiteral(l),
	(isofclass(OmlQuoteLiteral,l))
	  -> convertQuoteLiteral(l),
	others 
	  -> ( log := log union {mk_Error(l.getLine(),l.getColumn(),l.identity())};
		   return new JmlNullLiteral())
  end;
  
  
public convertNumericLiteral :
  OmlNumericLiteral ==>
  JmlNumericalLiteral
convertNumericLiteral(n) ==
  let val = n.getVal()
  in return new JmlNumericalLiteral(val);
  
  
public convertRealLiteral :
  OmlRealLiteral ==>
  JmlFloatLiteral
convertRealLiteral(n) ==
  let val = n.getVal()
  in return new JmlFloatLiteral(val);
  
  
public convertBooleanLiteral :
  OmlBooleanLiteral ==>
  JmlBooleanLiteral
convertBooleanLiteral(n) ==
  let val = n.getVal()
  in return new JmlBooleanLiteral(val);
  
  
public convertNilLiteral :
  OmlNilLiteral ==>
  JmlNullLiteral
convertNilLiteral(-) ==
  return new JmlNullLiteral();
  
  
public convertCharacterLiteral :
  OmlCharacterLiteral ==>
  JmlCharacterLiteral
convertCharacterLiteral(n) ==
  let val = n.getVal()
  in return new JmlCharacterLiteral(val);
  
  
public convertTextLiteral :
  OmlTextLiteral ==>
  JmlStringLiteral
convertTextLiteral(n) ==
  let val = n.getVal()
  in return new JmlStringLiteral(val);
  
  
public convertQuoteLiteral :
  OmlQuoteLiteral ==>
  JmlEnumLiteral
convertQuoteLiteral(n) ==
  let val = n.getVal()
  in return new JmlEnumLiteral(val);
  

end Vdm2Jml