\begin{vdm_al}
class OmlAccessDefinition is subclass of IOmlAccessDefinition
operations
  public identity: () ==> seq of char
  identity () == return "AccessDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAccessDefinition(self);

  public OmlAccessDefinition:
    (bool) *
    (bool) *
    (IOmlScope) ==> OmlAccessDefinition
  OmlAccessDefinition (p1,p2,p3) == 
    ( setAsyncAccess(p1);
      setStaticAccess(p2);
      setScope(p3) );

  public OmlAccessDefinition:
    (bool) *
    (bool) *
    (IOmlScope) *
    nat *
    nat ==> OmlAccessDefinition
  OmlAccessDefinition (p1,p2,p3,line,column) == 
    ( setAsyncAccess(p1);
      setStaticAccess(p2);
      setScope(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "async_access" in
        if fname in set dom data
        then setAsyncAccess(data(fname));
      let fname = "static_access" in
        if fname in set dom data
        then setStaticAccess(data(fname));
      let fname = "scope" in
        if fname in set dom data
        then setScope(data(fname)) );

instance variables
  private ivAsyncAccess : [bool] := nil

operations
  public getAsyncAccess: () ==> bool
  getAsyncAccess() == return ivAsyncAccess;

  public setAsyncAccess: bool ==> ()
  setAsyncAccess(parg) == ivAsyncAccess := parg;

instance variables
  private ivStaticAccess : [bool] := nil

operations
  public getStaticAccess: () ==> bool
  getStaticAccess() == return ivStaticAccess;

  public setStaticAccess: bool ==> ()
  setStaticAccess(parg) == ivStaticAccess := parg;

instance variables
  private ivScope : [IOmlScope] := nil

operations
  public getScope: () ==> IOmlScope
  getScope() == return ivScope;

  public setScope: IOmlScope ==> ()
  setScope(parg) == ivScope := parg;

end OmlAccessDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlActExpression is subclass of IOmlActExpression
operations
  public identity: () ==> seq of char
  identity () == return "ActExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitActExpression(self);

  public OmlActExpression:
    (seq of IOmlName) ==> OmlActExpression
  OmlActExpression (p1) == 
    ( setNameList(p1) );

  public OmlActExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlActExpression
  OmlActExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlActExpression
\end{vdm_al}

\begin{vdm_al}
class OmlActiveExpression is subclass of IOmlActiveExpression
operations
  public identity: () ==> seq of char
  identity () == return "ActiveExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitActiveExpression(self);

  public OmlActiveExpression:
    (seq of IOmlName) ==> OmlActiveExpression
  OmlActiveExpression (p1) == 
    ( setNameList(p1) );

  public OmlActiveExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlActiveExpression
  OmlActiveExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlActiveExpression
\end{vdm_al}

\begin{vdm_al}
class OmlAlwaysStatement is subclass of IOmlAlwaysStatement
operations
  public identity: () ==> seq of char
  identity () == return "AlwaysStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAlwaysStatement(self);

  public OmlAlwaysStatement:
    (IOmlStatement) *
    (IOmlStatement) ==> OmlAlwaysStatement
  OmlAlwaysStatement (p1,p2) == 
    ( setAlwaysPart(p1);
      setInPart(p2) );

  public OmlAlwaysStatement:
    (IOmlStatement) *
    (IOmlStatement) *
    nat *
    nat ==> OmlAlwaysStatement
  OmlAlwaysStatement (p1,p2,line,column) == 
    ( setAlwaysPart(p1);
      setInPart(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "always_part" in
        if fname in set dom data
        then setAlwaysPart(data(fname));
      let fname = "in_part" in
        if fname in set dom data
        then setInPart(data(fname)) );

instance variables
  private ivAlwaysPart : [IOmlStatement] := nil

operations
  public getAlwaysPart: () ==> IOmlStatement
  getAlwaysPart() == return ivAlwaysPart;

  public setAlwaysPart: IOmlStatement ==> ()
  setAlwaysPart(parg) == ivAlwaysPart := parg;

instance variables
  private ivInPart : [IOmlStatement] := nil

operations
  public getInPart: () ==> IOmlStatement
  getInPart() == return ivInPart;

  public setInPart: IOmlStatement ==> ()
  setInPart(parg) == ivInPart := parg;

end OmlAlwaysStatement
\end{vdm_al}

\begin{vdm_al}
class OmlApplyExpression is subclass of IOmlApplyExpression
operations
  public identity: () ==> seq of char
  identity () == return "ApplyExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitApplyExpression(self);

  public OmlApplyExpression:
    (IOmlExpression) *
    (seq of IOmlExpression) ==> OmlApplyExpression
  OmlApplyExpression (p1,p2) == 
    ( setExpression(p1);
      setExpressionList(p2) );

  public OmlApplyExpression:
    (IOmlExpression) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlApplyExpression
  OmlApplyExpression (p1,p2,line,column) == 
    ( setExpression(p1);
      setExpressionList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlApplyExpression
\end{vdm_al}

\begin{vdm_al}
class OmlAssignStatement is subclass of IOmlAssignStatement
operations
  public identity: () ==> seq of char
  identity () == return "AssignStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAssignStatement(self);

  public OmlAssignStatement:
    (IOmlStateDesignator) *
    (IOmlExpression) ==> OmlAssignStatement
  OmlAssignStatement (p1,p2) == 
    ( setStateDesignator(p1);
      setExpression(p2) );

  public OmlAssignStatement:
    (IOmlStateDesignator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlAssignStatement
  OmlAssignStatement (p1,p2,line,column) == 
    ( setStateDesignator(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "state_designator" in
        if fname in set dom data
        then setStateDesignator(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivStateDesignator : [IOmlStateDesignator] := nil

operations
  public getStateDesignator: () ==> IOmlStateDesignator
  getStateDesignator() == return ivStateDesignator;

  public setStateDesignator: IOmlStateDesignator ==> ()
  setStateDesignator(parg) == ivStateDesignator := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlAssignStatement
\end{vdm_al}

\begin{vdm_al}
class OmlAssignmentDefinition is subclass of IOmlAssignmentDefinition
operations
  public identity: () ==> seq of char
  identity () == return "AssignmentDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAssignmentDefinition(self);

  public OmlAssignmentDefinition:
    (seq of char) *
    (IOmlType) *
    [IOmlExpression] ==> OmlAssignmentDefinition
  OmlAssignmentDefinition (p1,p2,p3) == 
    ( setIdentifier(p1);
      setType(p2);
      setExpression(p3) );

  public OmlAssignmentDefinition:
    (seq of char) *
    (IOmlType) *
    [IOmlExpression] *
    nat *
    nat ==> OmlAssignmentDefinition
  OmlAssignmentDefinition (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression
    pre hasExpression();

  public hasExpression: () ==> bool
  hasExpression () == return ivExpression <> nil;

  public setExpression: [ IOmlExpression ] ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlAssignmentDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlAtomicStatement is subclass of IOmlAtomicStatement
operations
  public identity: () ==> seq of char
  identity () == return "AtomicStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitAtomicStatement(self);

  public OmlAtomicStatement:
    (seq of IOmlAssignStatement) ==> OmlAtomicStatement
  OmlAtomicStatement (p1) == 
    ( setAssignmentList(p1) );

  public OmlAtomicStatement:
    (seq of IOmlAssignStatement) *
    nat *
    nat ==> OmlAtomicStatement
  OmlAtomicStatement (p1,line,column) == 
    ( setAssignmentList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "assignment_list" in
        if fname in set dom data
        then setAssignmentList(data(fname)) );

instance variables
  private ivAssignmentList : seq of IOmlAssignStatement := []

operations
  public getAssignmentList: () ==> seq of IOmlAssignStatement
  getAssignmentList() == return ivAssignmentList;

  public setAssignmentList: seq of IOmlAssignStatement ==> ()
  setAssignmentList(parg) == ivAssignmentList := parg;

  public addAssignmentList: IOmlNode ==> ()
  addAssignmentList (parg) == ivAssignmentList := ivAssignmentList ^ [parg];

end OmlAtomicStatement
\end{vdm_al}

\begin{vdm_al}
class OmlBinaryExpression is subclass of IOmlBinaryExpression
operations
  public identity: () ==> seq of char
  identity () == return "BinaryExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBinaryExpression(self);

  public OmlBinaryExpression:
    (IOmlExpression) *
    (IOmlBinaryOperator) *
    (IOmlExpression) ==> OmlBinaryExpression
  OmlBinaryExpression (p1,p2,p3) == 
    ( setLhsExpression(p1);
      setOperator(p2);
      setRhsExpression(p3) );

  public OmlBinaryExpression:
    (IOmlExpression) *
    (IOmlBinaryOperator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlBinaryExpression
  OmlBinaryExpression (p1,p2,p3,line,column) == 
    ( setLhsExpression(p1);
      setOperator(p2);
      setRhsExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_expression" in
        if fname in set dom data
        then setLhsExpression(data(fname));
      let fname = "operator" in
        if fname in set dom data
        then setOperator(data(fname));
      let fname = "rhs_expression" in
        if fname in set dom data
        then setRhsExpression(data(fname)) );

instance variables
  private ivLhsExpression : [IOmlExpression] := nil

operations
  public getLhsExpression: () ==> IOmlExpression
  getLhsExpression() == return ivLhsExpression;

  public setLhsExpression: IOmlExpression ==> ()
  setLhsExpression(parg) == ivLhsExpression := parg;

instance variables
  private ivOperator : [IOmlBinaryOperator] := nil

operations
  public getOperator: () ==> IOmlBinaryOperator
  getOperator() == return ivOperator;

  public setOperator: IOmlBinaryOperator ==> ()
  setOperator(parg) == ivOperator := parg;

instance variables
  private ivRhsExpression : [IOmlExpression] := nil

operations
  public getRhsExpression: () ==> IOmlExpression
  getRhsExpression() == return ivRhsExpression;

  public setRhsExpression: IOmlExpression ==> ()
  setRhsExpression(parg) == ivRhsExpression := parg;

end OmlBinaryExpression
\end{vdm_al}

\begin{vdm_al}
class OmlBinaryOperator is subclass of IOmlBinaryOperator
operations
  public identity: () ==> seq of char
  identity () == return "BinaryOperator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBinaryOperator(self);

  public OmlBinaryOperator: nat ==> OmlBinaryOperator
  OmlBinaryOperator (pv) == setValue(pv);

  public OmlBinaryOperator: nat * nat * nat ==> OmlBinaryOperator
  OmlBinaryOperator (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlBinaryOperatorQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlBinaryOperatorQuotes`getQuoteName(val)
    pre val <> nil;

end OmlBinaryOperator
\end{vdm_al}
\begin{vdm_al}
class OmlBinaryOperatorQuotes
instance variables
  static public IQMODIFY : nat := 0;
  static public IQGE : nat := 1;
  static public IQLT : nat := 2;
  static public IQPSUBSET : nat := 3;
  static public IQMOD : nat := 4;
  static public IQMAPDOMRESBY : nat := 5;
  static public IQINTER : nat := 6;
  static public IQCOMP : nat := 7;
  static public IQMINUS : nat := 8;
  static public IQREM : nat := 9;
  static public IQAND : nat := 10;
  static public IQUNION : nat := 11;
  static public IQINSET : nat := 12;
  static public IQEQUIV : nat := 13;
  static public IQMAPRNGRESTO : nat := 14;
  static public IQITERATE : nat := 15;
  static public IQSUBSET : nat := 16;
  static public IQMAPRNGRESBY : nat := 17;
  static public IQTUPSEL : nat := 18;
  static public IQNOTINSET : nat := 19;
  static public IQMULTIPLY : nat := 20;
  static public IQIMPLY : nat := 21;
  static public IQOR : nat := 22;
  static public IQGT : nat := 23;
  static public IQPLUS : nat := 24;
  static public IQMUNION : nat := 25;
  static public IQMAPDOMRESTO : nat := 26;
  static public IQEQ : nat := 27;
  static public IQDIV : nat := 28;
  static public IQDIFFERENCE : nat := 29;
  static public IQCONC : nat := 30;
  static public IQLE : nat := 31;
  static public IQDIVIDE : nat := 32;
  static public IQNE : nat := 33;

  static private qmap : map nat to seq of char :=
    { IQMODIFY |-> "<MODIFY>",
      IQGE |-> "<GE>",
      IQLT |-> "<LT>",
      IQPSUBSET |-> "<PSUBSET>",
      IQMOD |-> "<MOD>",
      IQMAPDOMRESBY |-> "<MAPDOMRESBY>",
      IQINTER |-> "<INTER>",
      IQCOMP |-> "<COMP>",
      IQMINUS |-> "<MINUS>",
      IQREM |-> "<REM>",
      IQAND |-> "<AND>",
      IQUNION |-> "<UNION>",
      IQINSET |-> "<INSET>",
      IQEQUIV |-> "<EQUIV>",
      IQMAPRNGRESTO |-> "<MAPRNGRESTO>",
      IQITERATE |-> "<ITERATE>",
      IQSUBSET |-> "<SUBSET>",
      IQMAPRNGRESBY |-> "<MAPRNGRESBY>",
      IQTUPSEL |-> "<TUPSEL>",
      IQNOTINSET |-> "<NOTINSET>",
      IQMULTIPLY |-> "<MULTIPLY>",
      IQIMPLY |-> "<IMPLY>",
      IQOR |-> "<OR>",
      IQGT |-> "<GT>",
      IQPLUS |-> "<PLUS>",
      IQMUNION |-> "<MUNION>",
      IQMAPDOMRESTO |-> "<MAPDOMRESTO>",
      IQEQ |-> "<EQ>",
      IQDIV |-> "<DIV>",
      IQDIFFERENCE |-> "<DIFFERENCE>",
      IQCONC |-> "<CONC>",
      IQLE |-> "<LE>",
      IQDIVIDE |-> "<DIVIDE>",
      IQNE |-> "<NE>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlBinaryOperatorQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlBind is subclass of IOmlBind
operations
  public identity: () ==> seq of char
  identity () == return "Bind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBind(self);

end OmlBind
\end{vdm_al}
\begin{vdm_al}
class OmlBlockStatement is subclass of IOmlBlockStatement
operations
  public identity: () ==> seq of char
  identity () == return "BlockStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBlockStatement(self);

  public OmlBlockStatement:
    (seq of IOmlDclStatement) *
    (seq of IOmlStatement) ==> OmlBlockStatement
  OmlBlockStatement (p1,p2) == 
    ( setDclStatementList(p1);
      setStatementList(p2) );

  public OmlBlockStatement:
    (seq of IOmlDclStatement) *
    (seq of IOmlStatement) *
    nat *
    nat ==> OmlBlockStatement
  OmlBlockStatement (p1,p2,line,column) == 
    ( setDclStatementList(p1);
      setStatementList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dcl_statement_list" in
        if fname in set dom data
        then setDclStatementList(data(fname));
      let fname = "statement_list" in
        if fname in set dom data
        then setStatementList(data(fname)) );

instance variables
  private ivDclStatementList : seq of IOmlDclStatement := []

operations
  public getDclStatementList: () ==> seq of IOmlDclStatement
  getDclStatementList() == return ivDclStatementList;

  public setDclStatementList: seq of IOmlDclStatement ==> ()
  setDclStatementList(parg) == ivDclStatementList := parg;

  public addDclStatementList: IOmlNode ==> ()
  addDclStatementList (parg) == ivDclStatementList := ivDclStatementList ^ [parg];

instance variables
  private ivStatementList : seq of IOmlStatement := []

operations
  public getStatementList: () ==> seq of IOmlStatement
  getStatementList() == return ivStatementList;

  public setStatementList: seq of IOmlStatement ==> ()
  setStatementList(parg) == ivStatementList := parg;

  public addStatementList: IOmlNode ==> ()
  addStatementList (parg) == ivStatementList := ivStatementList ^ [parg];

end OmlBlockStatement
\end{vdm_al}

\begin{vdm_al}
class OmlBoolType is subclass of IOmlBoolType
operations
  public identity: () ==> seq of char
  identity () == return "BoolType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBoolType(self);

  public OmlBoolType:
    () ==> OmlBoolType
  OmlBoolType () == 
    skip;

  public OmlBoolType:
    nat *
    nat ==> OmlBoolType
  OmlBoolType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlBoolType
\end{vdm_al}

\begin{vdm_al}
class OmlBooleanLiteral is subclass of IOmlBooleanLiteral
operations
  public identity: () ==> seq of char
  identity () == return "BooleanLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBooleanLiteral(self);

  public OmlBooleanLiteral:
    (bool) ==> OmlBooleanLiteral
  OmlBooleanLiteral (p1) == 
    ( setVal(p1) );

  public OmlBooleanLiteral:
    (bool) *
    nat *
    nat ==> OmlBooleanLiteral
  OmlBooleanLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [bool] := nil

operations
  public getVal: () ==> bool
  getVal() == return ivVal;

  public setVal: bool ==> ()
  setVal(parg) == ivVal := parg;

end OmlBooleanLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlBracketedExpression is subclass of IOmlBracketedExpression
operations
  public identity: () ==> seq of char
  identity () == return "BracketedExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBracketedExpression(self);

  public OmlBracketedExpression:
    (IOmlExpression) ==> OmlBracketedExpression
  OmlBracketedExpression (p1) == 
    ( setExpression(p1) );

  public OmlBracketedExpression:
    (IOmlExpression) *
    nat *
    nat ==> OmlBracketedExpression
  OmlBracketedExpression (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlBracketedExpression
\end{vdm_al}

\begin{vdm_al}
class OmlBracketedType is subclass of IOmlBracketedType
operations
  public identity: () ==> seq of char
  identity () == return "BracketedType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitBracketedType(self);

  public OmlBracketedType:
    (IOmlType) ==> OmlBracketedType
  OmlBracketedType (p1) == 
    ( setType(p1) );

  public OmlBracketedType:
    (IOmlType) *
    nat *
    nat ==> OmlBracketedType
  OmlBracketedType (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlBracketedType
\end{vdm_al}

\begin{vdm_al}
class OmlCallStatement is subclass of IOmlCallStatement
operations
  public identity: () ==> seq of char
  identity () == return "CallStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCallStatement(self);

  public OmlCallStatement:
    [IOmlObjectDesignator] *
    (IOmlName) *
    (seq of IOmlExpression) ==> OmlCallStatement
  OmlCallStatement (p1,p2,p3) == 
    ( setObjectDesignator(p1);
      setName(p2);
      setExpressionList(p3) );

  public OmlCallStatement:
    [IOmlObjectDesignator] *
    (IOmlName) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlCallStatement
  OmlCallStatement (p1,p2,p3,line,column) == 
    ( setObjectDesignator(p1);
      setName(p2);
      setExpressionList(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "object_designator" in
        if fname in set dom data
        then setObjectDesignator(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivObjectDesignator : [IOmlObjectDesignator] := nil

operations
  public getObjectDesignator: () ==> IOmlObjectDesignator
  getObjectDesignator() == return ivObjectDesignator
    pre hasObjectDesignator();

  public hasObjectDesignator: () ==> bool
  hasObjectDesignator () == return ivObjectDesignator <> nil;

  public setObjectDesignator: [ IOmlObjectDesignator ] ==> ()
  setObjectDesignator(parg) == ivObjectDesignator := parg;

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlCallStatement
\end{vdm_al}

\begin{vdm_al}
class OmlCasesExpression is subclass of IOmlCasesExpression
operations
  public identity: () ==> seq of char
  identity () == return "CasesExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesExpression(self);

  public OmlCasesExpression:
    (IOmlExpression) *
    (seq of IOmlCasesExpressionAlternative) *
    [IOmlExpression] ==> OmlCasesExpression
  OmlCasesExpression (p1,p2,p3) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersExpression(p3) );

  public OmlCasesExpression:
    (IOmlExpression) *
    (seq of IOmlCasesExpressionAlternative) *
    [IOmlExpression] *
    nat *
    nat ==> OmlCasesExpression
  OmlCasesExpression (p1,p2,p3,line,column) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "match_expression" in
        if fname in set dom data
        then setMatchExpression(data(fname));
      let fname = "alternative_list" in
        if fname in set dom data
        then setAlternativeList(data(fname));
      let fname = "others_expression" in
        if fname in set dom data
        then setOthersExpression(data(fname)) );

instance variables
  private ivMatchExpression : [IOmlExpression] := nil

operations
  public getMatchExpression: () ==> IOmlExpression
  getMatchExpression() == return ivMatchExpression;

  public setMatchExpression: IOmlExpression ==> ()
  setMatchExpression(parg) == ivMatchExpression := parg;

instance variables
  private ivAlternativeList : seq of IOmlCasesExpressionAlternative := []

operations
  public getAlternativeList: () ==> seq of IOmlCasesExpressionAlternative
  getAlternativeList() == return ivAlternativeList;

  public setAlternativeList: seq of IOmlCasesExpressionAlternative ==> ()
  setAlternativeList(parg) == ivAlternativeList := parg;

  public addAlternativeList: IOmlNode ==> ()
  addAlternativeList (parg) == ivAlternativeList := ivAlternativeList ^ [parg];

instance variables
  private ivOthersExpression : [IOmlExpression] := nil

operations
  public getOthersExpression: () ==> IOmlExpression
  getOthersExpression() == return ivOthersExpression
    pre hasOthersExpression();

  public hasOthersExpression: () ==> bool
  hasOthersExpression () == return ivOthersExpression <> nil;

  public setOthersExpression: [ IOmlExpression ] ==> ()
  setOthersExpression(parg) == ivOthersExpression := parg;

end OmlCasesExpression
\end{vdm_al}

\begin{vdm_al}
class OmlCasesExpressionAlternative is subclass of IOmlCasesExpressionAlternative
operations
  public identity: () ==> seq of char
  identity () == return "CasesExpressionAlternative";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesExpressionAlternative(self);

  public OmlCasesExpressionAlternative:
    (seq of IOmlPattern) *
    (IOmlExpression) ==> OmlCasesExpressionAlternative
  OmlCasesExpressionAlternative (p1,p2) == 
    ( setPatternList(p1);
      setExpression(p2) );

  public OmlCasesExpressionAlternative:
    (seq of IOmlPattern) *
    (IOmlExpression) *
    nat *
    nat ==> OmlCasesExpressionAlternative
  OmlCasesExpressionAlternative (p1,p2,line,column) == 
    ( setPatternList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlCasesExpressionAlternative
\end{vdm_al}

\begin{vdm_al}
class OmlCasesStatement is subclass of IOmlCasesStatement
operations
  public identity: () ==> seq of char
  identity () == return "CasesStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesStatement(self);

  public OmlCasesStatement:
    (IOmlExpression) *
    (seq of IOmlCasesStatementAlternative) *
    [IOmlStatement] ==> OmlCasesStatement
  OmlCasesStatement (p1,p2,p3) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersStatement(p3) );

  public OmlCasesStatement:
    (IOmlExpression) *
    (seq of IOmlCasesStatementAlternative) *
    [IOmlStatement] *
    nat *
    nat ==> OmlCasesStatement
  OmlCasesStatement (p1,p2,p3,line,column) == 
    ( setMatchExpression(p1);
      setAlternativeList(p2);
      setOthersStatement(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "match_expression" in
        if fname in set dom data
        then setMatchExpression(data(fname));
      let fname = "alternative_list" in
        if fname in set dom data
        then setAlternativeList(data(fname));
      let fname = "others_statement" in
        if fname in set dom data
        then setOthersStatement(data(fname)) );

instance variables
  private ivMatchExpression : [IOmlExpression] := nil

operations
  public getMatchExpression: () ==> IOmlExpression
  getMatchExpression() == return ivMatchExpression;

  public setMatchExpression: IOmlExpression ==> ()
  setMatchExpression(parg) == ivMatchExpression := parg;

instance variables
  private ivAlternativeList : seq of IOmlCasesStatementAlternative := []

operations
  public getAlternativeList: () ==> seq of IOmlCasesStatementAlternative
  getAlternativeList() == return ivAlternativeList;

  public setAlternativeList: seq of IOmlCasesStatementAlternative ==> ()
  setAlternativeList(parg) == ivAlternativeList := parg;

  public addAlternativeList: IOmlNode ==> ()
  addAlternativeList (parg) == ivAlternativeList := ivAlternativeList ^ [parg];

instance variables
  private ivOthersStatement : [IOmlStatement] := nil

operations
  public getOthersStatement: () ==> IOmlStatement
  getOthersStatement() == return ivOthersStatement
    pre hasOthersStatement();

  public hasOthersStatement: () ==> bool
  hasOthersStatement () == return ivOthersStatement <> nil;

  public setOthersStatement: [ IOmlStatement ] ==> ()
  setOthersStatement(parg) == ivOthersStatement := parg;

end OmlCasesStatement
\end{vdm_al}

\begin{vdm_al}
class OmlCasesStatementAlternative is subclass of IOmlCasesStatementAlternative
operations
  public identity: () ==> seq of char
  identity () == return "CasesStatementAlternative";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCasesStatementAlternative(self);

  public OmlCasesStatementAlternative:
    (seq of IOmlPattern) *
    (IOmlStatement) ==> OmlCasesStatementAlternative
  OmlCasesStatementAlternative (p1,p2) == 
    ( setPatternList(p1);
      setStatement(p2) );

  public OmlCasesStatementAlternative:
    (seq of IOmlPattern) *
    (IOmlStatement) *
    nat *
    nat ==> OmlCasesStatementAlternative
  OmlCasesStatementAlternative (p1,p2,line,column) == 
    ( setPatternList(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlCasesStatementAlternative
\end{vdm_al}

\begin{vdm_al}
class OmlCharType is subclass of IOmlCharType
operations
  public identity: () ==> seq of char
  identity () == return "CharType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCharType(self);

  public OmlCharType:
    () ==> OmlCharType
  OmlCharType () == 
    skip;

  public OmlCharType:
    nat *
    nat ==> OmlCharType
  OmlCharType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlCharType
\end{vdm_al}

\begin{vdm_al}
class OmlCharacterLiteral is subclass of IOmlCharacterLiteral
operations
  public identity: () ==> seq of char
  identity () == return "CharacterLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCharacterLiteral(self);

  public OmlCharacterLiteral:
    (char) ==> OmlCharacterLiteral
  OmlCharacterLiteral (p1) == 
    ( setVal(p1) );

  public OmlCharacterLiteral:
    (char) *
    nat *
    nat ==> OmlCharacterLiteral
  OmlCharacterLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [char] := nil

operations
  public getVal: () ==> char
  getVal() == return ivVal;

  public setVal: char ==> ()
  setVal(parg) == ivVal := parg;

end OmlCharacterLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlClass is subclass of IOmlClass
operations
  public identity: () ==> seq of char
  identity () == return "Class";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitClass(self);

  public OmlClass:
    (seq of char) *
    (seq of IOmlType) *
    [IOmlInheritanceClause] *
    (seq of IOmlDefinitionBlock) *
    (bool) ==> OmlClass
  OmlClass (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setGenericTypes(p2);
      setInheritanceClause(p3);
      setClassBody(p4);
      setSystemSpec(p5) );

  public OmlClass:
    (seq of char) *
    (seq of IOmlType) *
    [IOmlInheritanceClause] *
    (seq of IOmlDefinitionBlock) *
    (bool) *
    nat *
    nat ==> OmlClass
  OmlClass (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setGenericTypes(p2);
      setInheritanceClause(p3);
      setClassBody(p4);
      setSystemSpec(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "generic_types" in
        if fname in set dom data
        then setGenericTypes(data(fname));
      let fname = "inheritance_clause" in
        if fname in set dom data
        then setInheritanceClause(data(fname));
      let fname = "class_body" in
        if fname in set dom data
        then setClassBody(data(fname));
      let fname = "system_spec" in
        if fname in set dom data
        then setSystemSpec(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivGenericTypes : seq of IOmlType := []

operations
  public getGenericTypes: () ==> seq of IOmlType
  getGenericTypes() == return ivGenericTypes;

  public setGenericTypes: seq of IOmlType ==> ()
  setGenericTypes(parg) == ivGenericTypes := parg;

  public addGenericTypes: IOmlNode ==> ()
  addGenericTypes (parg) == ivGenericTypes := ivGenericTypes ^ [parg];

instance variables
  private ivInheritanceClause : [IOmlInheritanceClause] := nil

operations
  public getInheritanceClause: () ==> IOmlInheritanceClause
  getInheritanceClause() == return ivInheritanceClause
    pre hasInheritanceClause();

  public hasInheritanceClause: () ==> bool
  hasInheritanceClause () == return ivInheritanceClause <> nil;

  public setInheritanceClause: [ IOmlInheritanceClause ] ==> ()
  setInheritanceClause(parg) == ivInheritanceClause := parg;

instance variables
  private ivClassBody : seq of IOmlDefinitionBlock := []

operations
  public getClassBody: () ==> seq of IOmlDefinitionBlock
  getClassBody() == return ivClassBody;

  public setClassBody: seq of IOmlDefinitionBlock ==> ()
  setClassBody(parg) == ivClassBody := parg;

  public addClassBody: IOmlNode ==> ()
  addClassBody (parg) == ivClassBody := ivClassBody ^ [parg];

instance variables
  private ivSystemSpec : [bool] := nil

operations
  public getSystemSpec: () ==> bool
  getSystemSpec() == return ivSystemSpec;

  public setSystemSpec: bool ==> ()
  setSystemSpec(parg) == ivSystemSpec := parg;

end OmlClass
\end{vdm_al}

\begin{vdm_al}
class OmlClassTypeInstantiation is subclass of IOmlClassTypeInstantiation
operations
  public identity: () ==> seq of char
  identity () == return "ClassTypeInstantiation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitClassTypeInstantiation(self);

  public OmlClassTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) ==> OmlClassTypeInstantiation
  OmlClassTypeInstantiation (p1,p2) == 
    ( setName(p1);
      setGenericTypes(p2) );

  public OmlClassTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) *
    nat *
    nat ==> OmlClassTypeInstantiation
  OmlClassTypeInstantiation (p1,p2,line,column) == 
    ( setName(p1);
      setGenericTypes(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "generic_types" in
        if fname in set dom data
        then setGenericTypes(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivGenericTypes : seq of IOmlType := []

operations
  public getGenericTypes: () ==> seq of IOmlType
  getGenericTypes() == return ivGenericTypes;

  public setGenericTypes: seq of IOmlType ==> ()
  setGenericTypes(parg) == ivGenericTypes := parg;

  public addGenericTypes: IOmlNode ==> ()
  addGenericTypes (parg) == ivGenericTypes := ivGenericTypes ^ [parg];

end OmlClassTypeInstantiation
\end{vdm_al}

\begin{vdm_al}
class OmlComplexType is subclass of IOmlComplexType
operations
  public identity: () ==> seq of char
  identity () == return "ComplexType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitComplexType(self);

  public OmlComplexType:
    (seq of char) *
    (seq of IOmlField) *
    [IOmlInvariant] ==> OmlComplexType
  OmlComplexType (p1,p2,p3) == 
    ( setIdentifier(p1);
      setFieldList(p2);
      setInvariant(p3) );

  public OmlComplexType:
    (seq of char) *
    (seq of IOmlField) *
    [IOmlInvariant] *
    nat *
    nat ==> OmlComplexType
  OmlComplexType (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setFieldList(p2);
      setInvariant(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "field_list" in
        if fname in set dom data
        then setFieldList(data(fname));
      let fname = "invariant" in
        if fname in set dom data
        then setInvariant(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivFieldList : seq of IOmlField := []

operations
  public getFieldList: () ==> seq of IOmlField
  getFieldList() == return ivFieldList;

  public setFieldList: seq of IOmlField ==> ()
  setFieldList(parg) == ivFieldList := parg;

  public addFieldList: IOmlNode ==> ()
  addFieldList (parg) == ivFieldList := ivFieldList ^ [parg];

instance variables
  private ivInvariant : [IOmlInvariant] := nil

operations
  public getInvariant: () ==> IOmlInvariant
  getInvariant() == return ivInvariant
    pre hasInvariant();

  public hasInvariant: () ==> bool
  hasInvariant () == return ivInvariant <> nil;

  public setInvariant: [ IOmlInvariant ] ==> ()
  setInvariant(parg) == ivInvariant := parg;

end OmlComplexType
\end{vdm_al}

\begin{vdm_al}
class OmlCompositeType is subclass of IOmlCompositeType
operations
  public identity: () ==> seq of char
  identity () == return "CompositeType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCompositeType(self);

  public OmlCompositeType:
    (seq of char) *
    (seq of IOmlField) ==> OmlCompositeType
  OmlCompositeType (p1,p2) == 
    ( setIdentifier(p1);
      setFieldList(p2) );

  public OmlCompositeType:
    (seq of char) *
    (seq of IOmlField) *
    nat *
    nat ==> OmlCompositeType
  OmlCompositeType (p1,p2,line,column) == 
    ( setIdentifier(p1);
      setFieldList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "field_list" in
        if fname in set dom data
        then setFieldList(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivFieldList : seq of IOmlField := []

operations
  public getFieldList: () ==> seq of IOmlField
  getFieldList() == return ivFieldList;

  public setFieldList: seq of IOmlField ==> ()
  setFieldList(parg) == ivFieldList := parg;

  public addFieldList: IOmlNode ==> ()
  addFieldList (parg) == ivFieldList := ivFieldList ^ [parg];

end OmlCompositeType
\end{vdm_al}

\begin{vdm_al}
class OmlCyclesStatement is subclass of IOmlCyclesStatement
operations
  public identity: () ==> seq of char
  identity () == return "CyclesStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitCyclesStatement(self);

  public OmlCyclesStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) ==> OmlCyclesStatement
  OmlCyclesStatement (p1,p2) == 
    ( setCyclesExpression(p1);
      setStatement(p2) );

  public OmlCyclesStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlCyclesStatement
  OmlCyclesStatement (p1,p2,line,column) == 
    ( setCyclesExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "cycles_expression" in
        if fname in set dom data
        then setCyclesExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivCyclesExpression : seq of IOmlExpression := []

operations
  public getCyclesExpression: () ==> seq of IOmlExpression
  getCyclesExpression() == return ivCyclesExpression;

  public setCyclesExpression: seq of IOmlExpression ==> ()
  setCyclesExpression(parg) == ivCyclesExpression := parg;

  public addCyclesExpression: IOmlNode ==> ()
  addCyclesExpression (parg) == ivCyclesExpression := ivCyclesExpression ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlCyclesStatement
\end{vdm_al}

\begin{vdm_al}
class OmlDclStatement is subclass of IOmlDclStatement
operations
  public identity: () ==> seq of char
  identity () == return "DclStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDclStatement(self);

  public OmlDclStatement:
    (seq of IOmlAssignmentDefinition) ==> OmlDclStatement
  OmlDclStatement (p1) == 
    ( setDefinitionList(p1) );

  public OmlDclStatement:
    (seq of IOmlAssignmentDefinition) *
    nat *
    nat ==> OmlDclStatement
  OmlDclStatement (p1,line,column) == 
    ( setDefinitionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlAssignmentDefinition := []

operations
  public getDefinitionList: () ==> seq of IOmlAssignmentDefinition
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlAssignmentDefinition ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

end OmlDclStatement
\end{vdm_al}

\begin{vdm_al}
class OmlDefExpression is subclass of IOmlDefExpression
operations
  public identity: () ==> seq of char
  identity () == return "DefExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefExpression(self);

  public OmlDefExpression:
    (seq of IOmlPatternBindExpression) *
    (IOmlExpression) ==> OmlDefExpression
  OmlDefExpression (p1,p2) == 
    ( setPatternBindList(p1);
      setExpression(p2) );

  public OmlDefExpression:
    (seq of IOmlPatternBindExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlDefExpression
  OmlDefExpression (p1,p2,line,column) == 
    ( setPatternBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind_list" in
        if fname in set dom data
        then setPatternBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternBindList : seq of IOmlPatternBindExpression := []

operations
  public getPatternBindList: () ==> seq of IOmlPatternBindExpression
  getPatternBindList() == return ivPatternBindList;

  public setPatternBindList: seq of IOmlPatternBindExpression ==> ()
  setPatternBindList(parg) == ivPatternBindList := parg;

  public addPatternBindList: IOmlNode ==> ()
  addPatternBindList (parg) == ivPatternBindList := ivPatternBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlDefExpression
\end{vdm_al}

\begin{vdm_al}
class OmlDefStatement is subclass of IOmlDefStatement
operations
  public identity: () ==> seq of char
  identity () == return "DefStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefStatement(self);

  public OmlDefStatement:
    (seq of IOmlEqualsDefinition) *
    (IOmlStatement) ==> OmlDefStatement
  OmlDefStatement (p1,p2) == 
    ( setDefinitionList(p1);
      setStatement(p2) );

  public OmlDefStatement:
    (seq of IOmlEqualsDefinition) *
    (IOmlStatement) *
    nat *
    nat ==> OmlDefStatement
  OmlDefStatement (p1,p2,line,column) == 
    ( setDefinitionList(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlEqualsDefinition := []

operations
  public getDefinitionList: () ==> seq of IOmlEqualsDefinition
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlEqualsDefinition ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlDefStatement
\end{vdm_al}

\begin{vdm_al}
class OmlDefinitionBlock is subclass of IOmlDefinitionBlock
operations
  public identity: () ==> seq of char
  identity () == return "DefinitionBlock";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDefinitionBlock(self);

end OmlDefinitionBlock
\end{vdm_al}
\begin{vdm_al}
class OmlDocument is subclass of IOmlDocument

instance variables
  private ivFilename : seq of char := []

operations
  public getFilename: () ==> seq of char
  getFilename () == return ivFilename;

  public setFilename: seq of char ==> ()
  setFilename (pfilename) == ivFilename := pfilename;

instance variables
  private ivTopNode : [ IOmlNode ] := nil

operations
  public hasSpecifications: () ==> bool
  hasSpecifications () == return isofclass(IOmlSpecifications,ivTopNode);

  public getSpecifications: () ==> IOmlSpecifications
  getSpecifications () == return ivTopNode
    pre hasSpecifications();

  public setSpecifications: IOmlSpecifications ==> ()
  setSpecifications (pNode) == ivTopNode := pNode
    pre ivTopNode = nil;

  public hasExpression: () ==> bool
  hasExpression () == return isofclass(IOmlExpression,ivTopNode);

  public getExpression: () ==> IOmlExpression
  getExpression () == return ivTopNode
    pre hasExpression();

  public setExpression: IOmlExpression ==> ()
  setExpression (pNode) == ivTopNode := pNode
    pre ivTopNode = nil;

instance variables
  private ivLexems : seq of IOmlLexem := []

operations
  public getLexems : () ==> seq of IOmlLexem
  getLexems () == return ivLexems;

  public setLexems : seq of IOmlLexem ==> ()
  setLexems (plexems) == ivLexems := plexems;

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDocument(self);

  public toVdmSlValue: () ==> seq of char
  toVdmSlValue () ==
    ( dcl visitor : VdmSlVisitor := new VdmSlVisitor();
      accept(visitor);
      return visitor.result );

  public toVdmPpValue: () ==> seq of char
  toVdmPpValue () ==
    ( dcl visitor : VdmPpVisitor := new VdmPpVisitor();
      accept(visitor);
      return visitor.result );

  public OmlDocument: seq of char * IOmlNode * seq of IOmlLexem ==> OmlDocument
  OmlDocument (pfilename, pnode, plexems) ==
    ( setFilename(pfilename);
      ivTopNode := pnode;
      setLexems(plexems) )
    pre isofclass(IOmlSpecifications,pnode) or isofclass(IOmlExpression,pnode)

end OmlDocument
\end{vdm_al}
\begin{vdm_al}
class OmlDontCarePattern is subclass of IOmlDontCarePattern
operations
  public identity: () ==> seq of char
  identity () == return "DontCarePattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDontCarePattern(self);

  public OmlDontCarePattern:
    () ==> OmlDontCarePattern
  OmlDontCarePattern () == 
    skip;

  public OmlDontCarePattern:
    nat *
    nat ==> OmlDontCarePattern
  OmlDontCarePattern (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlDontCarePattern
\end{vdm_al}

\begin{vdm_al}
class OmlDurationStatement is subclass of IOmlDurationStatement
operations
  public identity: () ==> seq of char
  identity () == return "DurationStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitDurationStatement(self);

  public OmlDurationStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) ==> OmlDurationStatement
  OmlDurationStatement (p1,p2) == 
    ( setDurationExpression(p1);
      setStatement(p2) );

  public OmlDurationStatement:
    (seq of IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlDurationStatement
  OmlDurationStatement (p1,p2,line,column) == 
    ( setDurationExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "duration_expression" in
        if fname in set dom data
        then setDurationExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivDurationExpression : seq of IOmlExpression := []

operations
  public getDurationExpression: () ==> seq of IOmlExpression
  getDurationExpression() == return ivDurationExpression;

  public setDurationExpression: seq of IOmlExpression ==> ()
  setDurationExpression(parg) == ivDurationExpression := parg;

  public addDurationExpression: IOmlNode ==> ()
  addDurationExpression (parg) == ivDurationExpression := ivDurationExpression ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlDurationStatement
\end{vdm_al}

\begin{vdm_al}
class OmlElseIfExpression is subclass of IOmlElseIfExpression
operations
  public identity: () ==> seq of char
  identity () == return "ElseIfExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitElseIfExpression(self);

  public OmlElseIfExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlElseIfExpression
  OmlElseIfExpression (p1,p2) == 
    ( setElseifExpression(p1);
      setThenExpression(p2) );

  public OmlElseIfExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlElseIfExpression
  OmlElseIfExpression (p1,p2,line,column) == 
    ( setElseifExpression(p1);
      setThenExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "elseif_expression" in
        if fname in set dom data
        then setElseifExpression(data(fname));
      let fname = "then_expression" in
        if fname in set dom data
        then setThenExpression(data(fname)) );

instance variables
  private ivElseifExpression : [IOmlExpression] := nil

operations
  public getElseifExpression: () ==> IOmlExpression
  getElseifExpression() == return ivElseifExpression;

  public setElseifExpression: IOmlExpression ==> ()
  setElseifExpression(parg) == ivElseifExpression := parg;

instance variables
  private ivThenExpression : [IOmlExpression] := nil

operations
  public getThenExpression: () ==> IOmlExpression
  getThenExpression() == return ivThenExpression;

  public setThenExpression: IOmlExpression ==> ()
  setThenExpression(parg) == ivThenExpression := parg;

end OmlElseIfExpression
\end{vdm_al}

\begin{vdm_al}
class OmlElseIfStatement is subclass of IOmlElseIfStatement
operations
  public identity: () ==> seq of char
  identity () == return "ElseIfStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitElseIfStatement(self);

  public OmlElseIfStatement:
    (IOmlExpression) *
    (IOmlStatement) ==> OmlElseIfStatement
  OmlElseIfStatement (p1,p2) == 
    ( setExpression(p1);
      setStatement(p2) );

  public OmlElseIfStatement:
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlElseIfStatement
  OmlElseIfStatement (p1,p2,line,column) == 
    ( setExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlElseIfStatement
\end{vdm_al}

\begin{vdm_al}
class OmlEmptyType is subclass of IOmlEmptyType
operations
  public identity: () ==> seq of char
  identity () == return "EmptyType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitEmptyType(self);

  public OmlEmptyType:
    () ==> OmlEmptyType
  OmlEmptyType () == 
    skip;

  public OmlEmptyType:
    nat *
    nat ==> OmlEmptyType
  OmlEmptyType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlEmptyType
\end{vdm_al}

\begin{vdm_al}
class OmlEqualsDefinition is subclass of IOmlEqualsDefinition
operations
  public identity: () ==> seq of char
  identity () == return "EqualsDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitEqualsDefinition(self);

  public OmlEqualsDefinition:
    (IOmlPatternBind) *
    (IOmlExpression) ==> OmlEqualsDefinition
  OmlEqualsDefinition (p1,p2) == 
    ( setPatternBind(p1);
      setExpression(p2) );

  public OmlEqualsDefinition:
    (IOmlPatternBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlEqualsDefinition
  OmlEqualsDefinition (p1,p2,line,column) == 
    ( setPatternBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlEqualsDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlError is subclass of IOmlError
operations
  public identity: () ==> seq of char
  identity () == return "Error";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitError(self);

  public OmlError:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) ==> OmlError
  OmlError (p1,p2,p3) == 
    ( setIdentifier(p1);
      setLhs(p2);
      setRhs(p3) );

  public OmlError:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlError
  OmlError (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setLhs(p2);
      setRhs(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "lhs" in
        if fname in set dom data
        then setLhs(data(fname));
      let fname = "rhs" in
        if fname in set dom data
        then setRhs(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivLhs : [IOmlExpression] := nil

operations
  public getLhs: () ==> IOmlExpression
  getLhs() == return ivLhs;

  public setLhs: IOmlExpression ==> ()
  setLhs(parg) == ivLhs := parg;

instance variables
  private ivRhs : [IOmlExpression] := nil

operations
  public getRhs: () ==> IOmlExpression
  getRhs() == return ivRhs;

  public setRhs: IOmlExpression ==> ()
  setRhs(parg) == ivRhs := parg;

end OmlError
\end{vdm_al}

\begin{vdm_al}
class OmlErrorStatement is subclass of IOmlErrorStatement
operations
  public identity: () ==> seq of char
  identity () == return "ErrorStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitErrorStatement(self);

  public OmlErrorStatement:
    () ==> OmlErrorStatement
  OmlErrorStatement () == 
    skip;

  public OmlErrorStatement:
    nat *
    nat ==> OmlErrorStatement
  OmlErrorStatement (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlErrorStatement
\end{vdm_al}

\begin{vdm_al}
class OmlExceptions is subclass of IOmlExceptions
operations
  public identity: () ==> seq of char
  identity () == return "Exceptions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExceptions(self);

  public OmlExceptions:
    (seq of IOmlError) ==> OmlExceptions
  OmlExceptions (p1) == 
    ( setErrorList(p1) );

  public OmlExceptions:
    (seq of IOmlError) *
    nat *
    nat ==> OmlExceptions
  OmlExceptions (p1,line,column) == 
    ( setErrorList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "error_list" in
        if fname in set dom data
        then setErrorList(data(fname)) );

instance variables
  private ivErrorList : seq of IOmlError := []

operations
  public getErrorList: () ==> seq of IOmlError
  getErrorList() == return ivErrorList;

  public setErrorList: seq of IOmlError ==> ()
  setErrorList(parg) == ivErrorList := parg;

  public addErrorList: IOmlNode ==> ()
  addErrorList (parg) == ivErrorList := ivErrorList ^ [parg];

end OmlExceptions
\end{vdm_al}

\begin{vdm_al}
class OmlExistsExpression is subclass of IOmlExistsExpression
operations
  public identity: () ==> seq of char
  identity () == return "ExistsExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExistsExpression(self);

  public OmlExistsExpression:
    (seq of IOmlBind) *
    (IOmlExpression) ==> OmlExistsExpression
  OmlExistsExpression (p1,p2) == 
    ( setBindList(p1);
      setExpression(p2) );

  public OmlExistsExpression:
    (seq of IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlExistsExpression
  OmlExistsExpression (p1,p2,line,column) == 
    ( setBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlExistsExpression
\end{vdm_al}

\begin{vdm_al}
class OmlExistsUniqueExpression is subclass of IOmlExistsUniqueExpression
operations
  public identity: () ==> seq of char
  identity () == return "ExistsUniqueExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExistsUniqueExpression(self);

  public OmlExistsUniqueExpression:
    (IOmlBind) *
    (IOmlExpression) ==> OmlExistsUniqueExpression
  OmlExistsUniqueExpression (p1,p2) == 
    ( setBind(p1);
      setExpression(p2) );

  public OmlExistsUniqueExpression:
    (IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlExistsUniqueExpression
  OmlExistsUniqueExpression (p1,p2,line,column) == 
    ( setBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlExistsUniqueExpression
\end{vdm_al}

\begin{vdm_al}
class OmlExitStatement is subclass of IOmlExitStatement
operations
  public identity: () ==> seq of char
  identity () == return "ExitStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExitStatement(self);

  public OmlExitStatement:
    [IOmlExpression] ==> OmlExitStatement
  OmlExitStatement (p1) == 
    ( setExpression(p1) );

  public OmlExitStatement:
    [IOmlExpression] *
    nat *
    nat ==> OmlExitStatement
  OmlExitStatement (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression
    pre hasExpression();

  public hasExpression: () ==> bool
  hasExpression () == return ivExpression <> nil;

  public setExpression: [ IOmlExpression ] ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlExitStatement
\end{vdm_al}

\begin{vdm_al}
class OmlExplicitFunction is subclass of IOmlExplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "ExplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExplicitFunction(self);

  public OmlExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (IOmlType) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) ==> OmlExplicitFunction
  OmlExplicitFunction (p1,p2,p3,p4,p5,p6) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setType(p3);
      setParameterList(p4);
      setBody(p5);
      setTrailer(p6) );

  public OmlExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (IOmlType) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlExplicitFunction
  OmlExplicitFunction (p1,p2,p3,p4,p5,p6,line,column) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setType(p3);
      setParameterList(p4);
      setBody(p5);
      setTrailer(p6);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type_variable_list" in
        if fname in set dom data
        then setTypeVariableList(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "parameter_list" in
        if fname in set dom data
        then setParameterList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivTypeVariableList : seq of IOmlTypeVariable := []

operations
  public getTypeVariableList: () ==> seq of IOmlTypeVariable
  getTypeVariableList() == return ivTypeVariableList;

  public setTypeVariableList: seq of IOmlTypeVariable ==> ()
  setTypeVariableList(parg) == ivTypeVariableList := parg;

  public addTypeVariableList: IOmlNode ==> ()
  addTypeVariableList (parg) == ivTypeVariableList := ivTypeVariableList ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivParameterList : seq of IOmlParameter := []

operations
  public getParameterList: () ==> seq of IOmlParameter
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IOmlParameter ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IOmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

instance variables
  private ivBody : [IOmlFunctionBody] := nil

operations
  public getBody: () ==> IOmlFunctionBody
  getBody() == return ivBody;

  public setBody: IOmlFunctionBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlExplicitOperation is subclass of IOmlExplicitOperation
operations
  public identity: () ==> seq of char
  identity () == return "ExplicitOperation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExplicitOperation(self);

  public OmlExplicitOperation:
    (seq of char) *
    (IOmlType) *
    (seq of IOmlPattern) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) ==> OmlExplicitOperation
  OmlExplicitOperation (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setType(p2);
      setParameterList(p3);
      setBody(p4);
      setTrailer(p5) );

  public OmlExplicitOperation:
    (seq of char) *
    (IOmlType) *
    (seq of IOmlPattern) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) *
    nat *
    nat ==> OmlExplicitOperation
  OmlExplicitOperation (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setParameterList(p3);
      setBody(p4);
      setTrailer(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "parameter_list" in
        if fname in set dom data
        then setParameterList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivParameterList : seq of IOmlPattern := []

operations
  public getParameterList: () ==> seq of IOmlPattern
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IOmlPattern ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IOmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

instance variables
  private ivBody : [IOmlOperationBody] := nil

operations
  public getBody: () ==> IOmlOperationBody
  getBody() == return ivBody;

  public setBody: IOmlOperationBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlOperationTrailer] := nil

operations
  public getTrailer: () ==> IOmlOperationTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlOperationTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExplicitOperation
\end{vdm_al}

\begin{vdm_al}
class OmlExpression is subclass of IOmlExpression
operations
  public identity: () ==> seq of char
  identity () == return "Expression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExpression(self);

end OmlExpression
\end{vdm_al}
\begin{vdm_al}
class OmlExtendedExplicitFunction is subclass of IOmlExtendedExplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "ExtendedExplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExtendedExplicitFunction(self);

  public OmlExtendedExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) ==> OmlExtendedExplicitFunction
  OmlExtendedExplicitFunction (p1,p2,p3,p4,p5,p6) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setBody(p5);
      setTrailer(p6) );

  public OmlExtendedExplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlExtendedExplicitFunction
  OmlExtendedExplicitFunction (p1,p2,p3,p4,p5,p6,line,column) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setBody(p5);
      setTrailer(p6);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type_variable_list" in
        if fname in set dom data
        then setTypeVariableList(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivTypeVariableList : seq of IOmlTypeVariable := []

operations
  public getTypeVariableList: () ==> seq of IOmlTypeVariable
  getTypeVariableList() == return ivTypeVariableList;

  public setTypeVariableList: seq of IOmlTypeVariable ==> ()
  setTypeVariableList(parg) == ivTypeVariableList := parg;

  public addTypeVariableList: IOmlNode ==> ()
  addTypeVariableList (parg) == ivTypeVariableList := ivTypeVariableList ^ [parg];

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivBody : [IOmlFunctionBody] := nil

operations
  public getBody: () ==> IOmlFunctionBody
  getBody() == return ivBody;

  public setBody: IOmlFunctionBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExtendedExplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlExtendedExplicitOperation is subclass of IOmlExtendedExplicitOperation
operations
  public identity: () ==> seq of char
  identity () == return "ExtendedExplicitOperation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExtendedExplicitOperation(self);

  public OmlExtendedExplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) ==> OmlExtendedExplicitOperation
  OmlExtendedExplicitOperation (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setBody(p4);
      setTrailer(p5) );

  public OmlExtendedExplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationBody) *
    (IOmlOperationTrailer) *
    nat *
    nat ==> OmlExtendedExplicitOperation
  OmlExtendedExplicitOperation (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setBody(p4);
      setTrailer(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivBody : [IOmlOperationBody] := nil

operations
  public getBody: () ==> IOmlOperationBody
  getBody() == return ivBody;

  public setBody: IOmlOperationBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlOperationTrailer] := nil

operations
  public getTrailer: () ==> IOmlOperationTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlOperationTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlExtendedExplicitOperation
\end{vdm_al}

\begin{vdm_al}
class OmlExternals is subclass of IOmlExternals
operations
  public identity: () ==> seq of char
  identity () == return "Externals";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitExternals(self);

  public OmlExternals:
    (seq of IOmlVarInformation) ==> OmlExternals
  OmlExternals (p1) == 
    ( setExtList(p1) );

  public OmlExternals:
    (seq of IOmlVarInformation) *
    nat *
    nat ==> OmlExternals
  OmlExternals (p1,line,column) == 
    ( setExtList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "ext_list" in
        if fname in set dom data
        then setExtList(data(fname)) );

instance variables
  private ivExtList : seq of IOmlVarInformation := []

operations
  public getExtList: () ==> seq of IOmlVarInformation
  getExtList() == return ivExtList;

  public setExtList: seq of IOmlVarInformation ==> ()
  setExtList(parg) == ivExtList := parg;

  public addExtList: IOmlNode ==> ()
  addExtList (parg) == ivExtList := ivExtList ^ [parg];

end OmlExternals
\end{vdm_al}

\begin{vdm_al}
class OmlField is subclass of IOmlField
operations
  public identity: () ==> seq of char
  identity () == return "Field";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitField(self);

  public OmlField:
    [seq of char] *
    (IOmlType) *
    (bool) ==> OmlField
  OmlField (p1,p2,p3) == 
    ( setIdentifier(p1);
      setType(p2);
      setIgnore(p3) );

  public OmlField:
    [seq of char] *
    (IOmlType) *
    (bool) *
    nat *
    nat ==> OmlField
  OmlField (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setIgnore(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "ignore" in
        if fname in set dom data
        then setIgnore(data(fname)) );

instance variables
  private ivIdentifier : [seq of char] := nil

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier
    pre hasIdentifier();

  public hasIdentifier: () ==> bool
  hasIdentifier () == return ivIdentifier <> nil;

  public setIdentifier: [ seq of char ] ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivIgnore : [bool] := nil

operations
  public getIgnore: () ==> bool
  getIgnore() == return ivIgnore;

  public setIgnore: bool ==> ()
  setIgnore(parg) == ivIgnore := parg;

end OmlField
\end{vdm_al}

\begin{vdm_al}
class OmlFieldReference is subclass of IOmlFieldReference
operations
  public identity: () ==> seq of char
  identity () == return "FieldReference";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFieldReference(self);

  public OmlFieldReference:
    (IOmlStateDesignator) *
    (seq of char) ==> OmlFieldReference
  OmlFieldReference (p1,p2) == 
    ( setStateDesignator(p1);
      setIdentifier(p2) );

  public OmlFieldReference:
    (IOmlStateDesignator) *
    (seq of char) *
    nat *
    nat ==> OmlFieldReference
  OmlFieldReference (p1,p2,line,column) == 
    ( setStateDesignator(p1);
      setIdentifier(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "state_designator" in
        if fname in set dom data
        then setStateDesignator(data(fname));
      let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivStateDesignator : [IOmlStateDesignator] := nil

operations
  public getStateDesignator: () ==> IOmlStateDesignator
  getStateDesignator() == return ivStateDesignator;

  public setStateDesignator: IOmlStateDesignator ==> ()
  setStateDesignator(parg) == ivStateDesignator := parg;

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlFieldReference
\end{vdm_al}

\begin{vdm_al}
class OmlFieldSelect is subclass of IOmlFieldSelect
operations
  public identity: () ==> seq of char
  identity () == return "FieldSelect";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFieldSelect(self);

  public OmlFieldSelect:
    (IOmlExpression) *
    (IOmlName) ==> OmlFieldSelect
  OmlFieldSelect (p1,p2) == 
    ( setExpression(p1);
      setName(p2) );

  public OmlFieldSelect:
    (IOmlExpression) *
    (IOmlName) *
    nat *
    nat ==> OmlFieldSelect
  OmlFieldSelect (p1,p2,line,column) == 
    ( setExpression(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlFieldSelect
\end{vdm_al}

\begin{vdm_al}
class OmlFinExpression is subclass of IOmlFinExpression
operations
  public identity: () ==> seq of char
  identity () == return "FinExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFinExpression(self);

  public OmlFinExpression:
    (seq of IOmlName) ==> OmlFinExpression
  OmlFinExpression (p1) == 
    ( setNameList(p1) );

  public OmlFinExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlFinExpression
  OmlFinExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlFinExpression
\end{vdm_al}

\begin{vdm_al}
class OmlForAllExpression is subclass of IOmlForAllExpression
operations
  public identity: () ==> seq of char
  identity () == return "ForAllExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitForAllExpression(self);

  public OmlForAllExpression:
    (seq of IOmlBind) *
    (IOmlExpression) ==> OmlForAllExpression
  OmlForAllExpression (p1,p2) == 
    ( setBindList(p1);
      setExpression(p2) );

  public OmlForAllExpression:
    (seq of IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlForAllExpression
  OmlForAllExpression (p1,p2,line,column) == 
    ( setBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlForAllExpression
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionBody is subclass of IOmlFunctionBody
operations
  public identity: () ==> seq of char
  identity () == return "FunctionBody";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionBody(self);

  public OmlFunctionBody:
    [IOmlExpression] *
    (bool) *
    (bool) ==> OmlFunctionBody
  OmlFunctionBody (p1,p2,p3) == 
    ( setFunctionBody(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3) );

  public OmlFunctionBody:
    [IOmlExpression] *
    (bool) *
    (bool) *
    nat *
    nat ==> OmlFunctionBody
  OmlFunctionBody (p1,p2,p3,line,column) == 
    ( setFunctionBody(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "function_body" in
        if fname in set dom data
        then setFunctionBody(data(fname));
      let fname = "not_yet_specified" in
        if fname in set dom data
        then setNotYetSpecified(data(fname));
      let fname = "subclass_responsibility" in
        if fname in set dom data
        then setSubclassResponsibility(data(fname)) );

instance variables
  private ivFunctionBody : [IOmlExpression] := nil

operations
  public getFunctionBody: () ==> IOmlExpression
  getFunctionBody() == return ivFunctionBody
    pre hasFunctionBody();

  public hasFunctionBody: () ==> bool
  hasFunctionBody () == return ivFunctionBody <> nil;

  public setFunctionBody: [ IOmlExpression ] ==> ()
  setFunctionBody(parg) == ivFunctionBody := parg;

instance variables
  private ivNotYetSpecified : [bool] := nil

operations
  public getNotYetSpecified: () ==> bool
  getNotYetSpecified() == return ivNotYetSpecified;

  public setNotYetSpecified: bool ==> ()
  setNotYetSpecified(parg) == ivNotYetSpecified := parg;

instance variables
  private ivSubclassResponsibility : [bool] := nil

operations
  public getSubclassResponsibility: () ==> bool
  getSubclassResponsibility() == return ivSubclassResponsibility;

  public setSubclassResponsibility: bool ==> ()
  setSubclassResponsibility(parg) == ivSubclassResponsibility := parg;

end OmlFunctionBody
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionDefinition is subclass of IOmlFunctionDefinition
operations
  public identity: () ==> seq of char
  identity () == return "FunctionDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionDefinition(self);

  public OmlFunctionDefinition:
    (IOmlAccessDefinition) *
    (IOmlFunctionShape) ==> OmlFunctionDefinition
  OmlFunctionDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlFunctionDefinition:
    (IOmlAccessDefinition) *
    (IOmlFunctionShape) *
    nat *
    nat ==> OmlFunctionDefinition
  OmlFunctionDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlFunctionShape] := nil

operations
  public getShape: () ==> IOmlFunctionShape
  getShape() == return ivShape;

  public setShape: IOmlFunctionShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlFunctionDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionDefinitions is subclass of IOmlFunctionDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "FunctionDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionDefinitions(self);

  public OmlFunctionDefinitions:
    (seq of IOmlFunctionDefinition) ==> OmlFunctionDefinitions
  OmlFunctionDefinitions (p1) == 
    ( setFunctionList(p1) );

  public OmlFunctionDefinitions:
    (seq of IOmlFunctionDefinition) *
    nat *
    nat ==> OmlFunctionDefinitions
  OmlFunctionDefinitions (p1,line,column) == 
    ( setFunctionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "function_list" in
        if fname in set dom data
        then setFunctionList(data(fname)) );

instance variables
  private ivFunctionList : seq of IOmlFunctionDefinition := []

operations
  public getFunctionList: () ==> seq of IOmlFunctionDefinition
  getFunctionList() == return ivFunctionList;

  public setFunctionList: seq of IOmlFunctionDefinition ==> ()
  setFunctionList(parg) == ivFunctionList := parg;

  public addFunctionList: IOmlNode ==> ()
  addFunctionList (parg) == ivFunctionList := ivFunctionList ^ [parg];

end OmlFunctionDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionShape is subclass of IOmlFunctionShape
operations
  public identity: () ==> seq of char
  identity () == return "FunctionShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionShape(self);

end OmlFunctionShape
\end{vdm_al}
\begin{vdm_al}
class OmlFunctionTrailer is subclass of IOmlFunctionTrailer
operations
  public identity: () ==> seq of char
  identity () == return "FunctionTrailer";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionTrailer(self);

  public OmlFunctionTrailer:
    [IOmlExpression] *
    [IOmlExpression] ==> OmlFunctionTrailer
  OmlFunctionTrailer (p1,p2) == 
    ( setPreExpression(p1);
      setPostExpression(p2) );

  public OmlFunctionTrailer:
    [IOmlExpression] *
    [IOmlExpression] *
    nat *
    nat ==> OmlFunctionTrailer
  OmlFunctionTrailer (p1,p2,line,column) == 
    ( setPreExpression(p1);
      setPostExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pre_expression" in
        if fname in set dom data
        then setPreExpression(data(fname));
      let fname = "post_expression" in
        if fname in set dom data
        then setPostExpression(data(fname)) );

instance variables
  private ivPreExpression : [IOmlExpression] := nil

operations
  public getPreExpression: () ==> IOmlExpression
  getPreExpression() == return ivPreExpression
    pre hasPreExpression();

  public hasPreExpression: () ==> bool
  hasPreExpression () == return ivPreExpression <> nil;

  public setPreExpression: [ IOmlExpression ] ==> ()
  setPreExpression(parg) == ivPreExpression := parg;

instance variables
  private ivPostExpression : [IOmlExpression] := nil

operations
  public getPostExpression: () ==> IOmlExpression
  getPostExpression() == return ivPostExpression
    pre hasPostExpression();

  public hasPostExpression: () ==> bool
  hasPostExpression () == return ivPostExpression <> nil;

  public setPostExpression: [ IOmlExpression ] ==> ()
  setPostExpression(parg) == ivPostExpression := parg;

end OmlFunctionTrailer
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionTypeInstantiation is subclass of IOmlFunctionTypeInstantiation
operations
  public identity: () ==> seq of char
  identity () == return "FunctionTypeInstantiation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionTypeInstantiation(self);

  public OmlFunctionTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) ==> OmlFunctionTypeInstantiation
  OmlFunctionTypeInstantiation (p1,p2) == 
    ( setName(p1);
      setTypeList(p2) );

  public OmlFunctionTypeInstantiation:
    (IOmlName) *
    (seq of IOmlType) *
    nat *
    nat ==> OmlFunctionTypeInstantiation
  OmlFunctionTypeInstantiation (p1,p2,line,column) == 
    ( setName(p1);
      setTypeList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "type_list" in
        if fname in set dom data
        then setTypeList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivTypeList : seq of IOmlType := []

operations
  public getTypeList: () ==> seq of IOmlType
  getTypeList() == return ivTypeList;

  public setTypeList: seq of IOmlType ==> ()
  setTypeList(parg) == ivTypeList := parg;

  public addTypeList: IOmlNode ==> ()
  addTypeList (parg) == ivTypeList := ivTypeList ^ [parg];

end OmlFunctionTypeInstantiation
\end{vdm_al}

\begin{vdm_al}
class OmlFunctionTypeSelect is subclass of IOmlFunctionTypeSelect
operations
  public identity: () ==> seq of char
  identity () == return "FunctionTypeSelect";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitFunctionTypeSelect(self);

  public OmlFunctionTypeSelect:
    (IOmlExpression) *
    (IOmlFunctionTypeInstantiation) ==> OmlFunctionTypeSelect
  OmlFunctionTypeSelect (p1,p2) == 
    ( setExpression(p1);
      setFunctionTypeInstantiation(p2) );

  public OmlFunctionTypeSelect:
    (IOmlExpression) *
    (IOmlFunctionTypeInstantiation) *
    nat *
    nat ==> OmlFunctionTypeSelect
  OmlFunctionTypeSelect (p1,p2,line,column) == 
    ( setExpression(p1);
      setFunctionTypeInstantiation(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "function_type_instantiation" in
        if fname in set dom data
        then setFunctionTypeInstantiation(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivFunctionTypeInstantiation : [IOmlFunctionTypeInstantiation] := nil

operations
  public getFunctionTypeInstantiation: () ==> IOmlFunctionTypeInstantiation
  getFunctionTypeInstantiation() == return ivFunctionTypeInstantiation;

  public setFunctionTypeInstantiation: IOmlFunctionTypeInstantiation ==> ()
  setFunctionTypeInstantiation(parg) == ivFunctionTypeInstantiation := parg;

end OmlFunctionTypeSelect
\end{vdm_al}

\begin{vdm_al}
class OmlGeneralMapType is subclass of IOmlGeneralMapType
operations
  public identity: () ==> seq of char
  identity () == return "GeneralMapType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitGeneralMapType(self);

  public OmlGeneralMapType:
    (IOmlType) *
    (IOmlType) ==> OmlGeneralMapType
  OmlGeneralMapType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlGeneralMapType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlGeneralMapType
  OmlGeneralMapType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlGeneralMapType
\end{vdm_al}

\begin{vdm_al}
class OmlIdentifierTypePair is subclass of IOmlIdentifierTypePair
operations
  public identity: () ==> seq of char
  identity () == return "IdentifierTypePair";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIdentifierTypePair(self);

  public OmlIdentifierTypePair:
    (seq of char) *
    (IOmlType) ==> OmlIdentifierTypePair
  OmlIdentifierTypePair (p1,p2) == 
    ( setIdentifier(p1);
      setType(p2) );

  public OmlIdentifierTypePair:
    (seq of char) *
    (IOmlType) *
    nat *
    nat ==> OmlIdentifierTypePair
  OmlIdentifierTypePair (p1,p2,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlIdentifierTypePair
\end{vdm_al}

\begin{vdm_al}
class OmlIfExpression is subclass of IOmlIfExpression
operations
  public identity: () ==> seq of char
  identity () == return "IfExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIfExpression(self);

  public OmlIfExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (seq of IOmlElseIfExpression) *
    (IOmlExpression) ==> OmlIfExpression
  OmlIfExpression (p1,p2,p3,p4) == 
    ( setIfExpression(p1);
      setThenExpression(p2);
      setElseifExpressionList(p3);
      setElseExpression(p4) );

  public OmlIfExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (seq of IOmlElseIfExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIfExpression
  OmlIfExpression (p1,p2,p3,p4,line,column) == 
    ( setIfExpression(p1);
      setThenExpression(p2);
      setElseifExpressionList(p3);
      setElseExpression(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "if_expression" in
        if fname in set dom data
        then setIfExpression(data(fname));
      let fname = "then_expression" in
        if fname in set dom data
        then setThenExpression(data(fname));
      let fname = "elseif_expression_list" in
        if fname in set dom data
        then setElseifExpressionList(data(fname));
      let fname = "else_expression" in
        if fname in set dom data
        then setElseExpression(data(fname)) );

instance variables
  private ivIfExpression : [IOmlExpression] := nil

operations
  public getIfExpression: () ==> IOmlExpression
  getIfExpression() == return ivIfExpression;

  public setIfExpression: IOmlExpression ==> ()
  setIfExpression(parg) == ivIfExpression := parg;

instance variables
  private ivThenExpression : [IOmlExpression] := nil

operations
  public getThenExpression: () ==> IOmlExpression
  getThenExpression() == return ivThenExpression;

  public setThenExpression: IOmlExpression ==> ()
  setThenExpression(parg) == ivThenExpression := parg;

instance variables
  private ivElseifExpressionList : seq of IOmlElseIfExpression := []

operations
  public getElseifExpressionList: () ==> seq of IOmlElseIfExpression
  getElseifExpressionList() == return ivElseifExpressionList;

  public setElseifExpressionList: seq of IOmlElseIfExpression ==> ()
  setElseifExpressionList(parg) == ivElseifExpressionList := parg;

  public addElseifExpressionList: IOmlNode ==> ()
  addElseifExpressionList (parg) == ivElseifExpressionList := ivElseifExpressionList ^ [parg];

instance variables
  private ivElseExpression : [IOmlExpression] := nil

operations
  public getElseExpression: () ==> IOmlExpression
  getElseExpression() == return ivElseExpression;

  public setElseExpression: IOmlExpression ==> ()
  setElseExpression(parg) == ivElseExpression := parg;

end OmlIfExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIfStatement is subclass of IOmlIfStatement
operations
  public identity: () ==> seq of char
  identity () == return "IfStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIfStatement(self);

  public OmlIfStatement:
    (IOmlExpression) *
    (IOmlStatement) *
    (seq of IOmlElseIfStatement) *
    [IOmlStatement] ==> OmlIfStatement
  OmlIfStatement (p1,p2,p3,p4) == 
    ( setExpression(p1);
      setThenStatement(p2);
      setElseifStatement(p3);
      setElseStatement(p4) );

  public OmlIfStatement:
    (IOmlExpression) *
    (IOmlStatement) *
    (seq of IOmlElseIfStatement) *
    [IOmlStatement] *
    nat *
    nat ==> OmlIfStatement
  OmlIfStatement (p1,p2,p3,p4,line,column) == 
    ( setExpression(p1);
      setThenStatement(p2);
      setElseifStatement(p3);
      setElseStatement(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "then_statement" in
        if fname in set dom data
        then setThenStatement(data(fname));
      let fname = "elseif_statement" in
        if fname in set dom data
        then setElseifStatement(data(fname));
      let fname = "else_statement" in
        if fname in set dom data
        then setElseStatement(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivThenStatement : [IOmlStatement] := nil

operations
  public getThenStatement: () ==> IOmlStatement
  getThenStatement() == return ivThenStatement;

  public setThenStatement: IOmlStatement ==> ()
  setThenStatement(parg) == ivThenStatement := parg;

instance variables
  private ivElseifStatement : seq of IOmlElseIfStatement := []

operations
  public getElseifStatement: () ==> seq of IOmlElseIfStatement
  getElseifStatement() == return ivElseifStatement;

  public setElseifStatement: seq of IOmlElseIfStatement ==> ()
  setElseifStatement(parg) == ivElseifStatement := parg;

  public addElseifStatement: IOmlNode ==> ()
  addElseifStatement (parg) == ivElseifStatement := ivElseifStatement ^ [parg];

instance variables
  private ivElseStatement : [IOmlStatement] := nil

operations
  public getElseStatement: () ==> IOmlStatement
  getElseStatement() == return ivElseStatement
    pre hasElseStatement();

  public hasElseStatement: () ==> bool
  hasElseStatement () == return ivElseStatement <> nil;

  public setElseStatement: [ IOmlStatement ] ==> ()
  setElseStatement(parg) == ivElseStatement := parg;

end OmlIfStatement
\end{vdm_al}

\begin{vdm_al}
class OmlImplicitFunction is subclass of IOmlImplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "ImplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitImplicitFunction(self);

  public OmlImplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionTrailer) ==> OmlImplicitFunction
  OmlImplicitFunction (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setTrailer(p5) );

  public OmlImplicitFunction:
    (seq of char) *
    (seq of IOmlTypeVariable) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlImplicitFunction
  OmlImplicitFunction (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setTypeVariableList(p2);
      setPatternTypePairList(p3);
      setIdentifierTypePairList(p4);
      setTrailer(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type_variable_list" in
        if fname in set dom data
        then setTypeVariableList(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivTypeVariableList : seq of IOmlTypeVariable := []

operations
  public getTypeVariableList: () ==> seq of IOmlTypeVariable
  getTypeVariableList() == return ivTypeVariableList;

  public setTypeVariableList: seq of IOmlTypeVariable ==> ()
  setTypeVariableList(parg) == ivTypeVariableList := parg;

  public addTypeVariableList: IOmlNode ==> ()
  addTypeVariableList (parg) == ivTypeVariableList := ivTypeVariableList ^ [parg];

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlImplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlImplicitOperation is subclass of IOmlImplicitOperation
operations
  public identity: () ==> seq of char
  identity () == return "ImplicitOperation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitImplicitOperation(self);

  public OmlImplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationTrailer) ==> OmlImplicitOperation
  OmlImplicitOperation (p1,p2,p3,p4) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setTrailer(p4) );

  public OmlImplicitOperation:
    (seq of char) *
    (seq of IOmlPatternTypePair) *
    (seq of IOmlIdentifierTypePair) *
    (IOmlOperationTrailer) *
    nat *
    nat ==> OmlImplicitOperation
  OmlImplicitOperation (p1,p2,p3,p4,line,column) == 
    ( setIdentifier(p1);
      setPatternTypePairList(p2);
      setIdentifierTypePairList(p3);
      setTrailer(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "pattern_type_pair_list" in
        if fname in set dom data
        then setPatternTypePairList(data(fname));
      let fname = "identifier_type_pair_list" in
        if fname in set dom data
        then setIdentifierTypePairList(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivPatternTypePairList : seq of IOmlPatternTypePair := []

operations
  public getPatternTypePairList: () ==> seq of IOmlPatternTypePair
  getPatternTypePairList() == return ivPatternTypePairList;

  public setPatternTypePairList: seq of IOmlPatternTypePair ==> ()
  setPatternTypePairList(parg) == ivPatternTypePairList := parg;

  public addPatternTypePairList: IOmlNode ==> ()
  addPatternTypePairList (parg) == ivPatternTypePairList := ivPatternTypePairList ^ [parg];

instance variables
  private ivIdentifierTypePairList : seq of IOmlIdentifierTypePair := []

operations
  public getIdentifierTypePairList: () ==> seq of IOmlIdentifierTypePair
  getIdentifierTypePairList() == return ivIdentifierTypePairList;

  public setIdentifierTypePairList: seq of IOmlIdentifierTypePair ==> ()
  setIdentifierTypePairList(parg) == ivIdentifierTypePairList := parg;

  public addIdentifierTypePairList: IOmlNode ==> ()
  addIdentifierTypePairList (parg) == ivIdentifierTypePairList := ivIdentifierTypePairList ^ [parg];

instance variables
  private ivTrailer : [IOmlOperationTrailer] := nil

operations
  public getTrailer: () ==> IOmlOperationTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlOperationTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlImplicitOperation
\end{vdm_al}

\begin{vdm_al}
class OmlIndexForLoop is subclass of IOmlIndexForLoop
operations
  public identity: () ==> seq of char
  identity () == return "IndexForLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIndexForLoop(self);

  public OmlIndexForLoop:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) *
    [IOmlExpression] *
    (IOmlStatement) ==> OmlIndexForLoop
  OmlIndexForLoop (p1,p2,p3,p4,p5) == 
    ( setIdentifier(p1);
      setInitExpression(p2);
      setLimitExpression(p3);
      setByExpression(p4);
      setStatement(p5) );

  public OmlIndexForLoop:
    (seq of char) *
    (IOmlExpression) *
    (IOmlExpression) *
    [IOmlExpression] *
    (IOmlStatement) *
    nat *
    nat ==> OmlIndexForLoop
  OmlIndexForLoop (p1,p2,p3,p4,p5,line,column) == 
    ( setIdentifier(p1);
      setInitExpression(p2);
      setLimitExpression(p3);
      setByExpression(p4);
      setStatement(p5);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "init_expression" in
        if fname in set dom data
        then setInitExpression(data(fname));
      let fname = "limit_expression" in
        if fname in set dom data
        then setLimitExpression(data(fname));
      let fname = "by_expression" in
        if fname in set dom data
        then setByExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivInitExpression : [IOmlExpression] := nil

operations
  public getInitExpression: () ==> IOmlExpression
  getInitExpression() == return ivInitExpression;

  public setInitExpression: IOmlExpression ==> ()
  setInitExpression(parg) == ivInitExpression := parg;

instance variables
  private ivLimitExpression : [IOmlExpression] := nil

operations
  public getLimitExpression: () ==> IOmlExpression
  getLimitExpression() == return ivLimitExpression;

  public setLimitExpression: IOmlExpression ==> ()
  setLimitExpression(parg) == ivLimitExpression := parg;

instance variables
  private ivByExpression : [IOmlExpression] := nil

operations
  public getByExpression: () ==> IOmlExpression
  getByExpression() == return ivByExpression
    pre hasByExpression();

  public hasByExpression: () ==> bool
  hasByExpression () == return ivByExpression <> nil;

  public setByExpression: [ IOmlExpression ] ==> ()
  setByExpression(parg) == ivByExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlIndexForLoop
\end{vdm_al}

\begin{vdm_al}
class OmlInheritanceClause is subclass of IOmlInheritanceClause
operations
  public identity: () ==> seq of char
  identity () == return "InheritanceClause";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInheritanceClause(self);

  public OmlInheritanceClause:
    (seq of seq of char) ==> OmlInheritanceClause
  OmlInheritanceClause (p1) == 
    ( setIdentifierList(p1) );

  public OmlInheritanceClause:
    (seq of seq of char) *
    nat *
    nat ==> OmlInheritanceClause
  OmlInheritanceClause (p1,line,column) == 
    ( setIdentifierList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier_list" in
        if fname in set dom data
        then setIdentifierList(data(fname)) );

instance variables
  private ivIdentifierList : seq of seq of char := []

operations
  public getIdentifierList: () ==> seq of seq of char
  getIdentifierList() == return ivIdentifierList;

  public setIdentifierList: seq of seq of char ==> ()
  setIdentifierList(parg) == ivIdentifierList := parg;

  public addIdentifierList: seq of char ==> ()
  addIdentifierList (parg) == ivIdentifierList := ivIdentifierList ^ [parg];

end OmlInheritanceClause
\end{vdm_al}

\begin{vdm_al}
class OmlInjectiveMapType is subclass of IOmlInjectiveMapType
operations
  public identity: () ==> seq of char
  identity () == return "InjectiveMapType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInjectiveMapType(self);

  public OmlInjectiveMapType:
    (IOmlType) *
    (IOmlType) ==> OmlInjectiveMapType
  OmlInjectiveMapType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlInjectiveMapType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlInjectiveMapType
  OmlInjectiveMapType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlInjectiveMapType
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariable is subclass of IOmlInstanceVariable
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariable";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariable(self);

  public OmlInstanceVariable:
    (IOmlAccessDefinition) *
    (IOmlAssignmentDefinition) ==> OmlInstanceVariable
  OmlInstanceVariable (p1,p2) == 
    ( setAccess(p1);
      setAssignmentDefinition(p2) );

  public OmlInstanceVariable:
    (IOmlAccessDefinition) *
    (IOmlAssignmentDefinition) *
    nat *
    nat ==> OmlInstanceVariable
  OmlInstanceVariable (p1,p2,line,column) == 
    ( setAccess(p1);
      setAssignmentDefinition(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "assignment_definition" in
        if fname in set dom data
        then setAssignmentDefinition(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivAssignmentDefinition : [IOmlAssignmentDefinition] := nil

operations
  public getAssignmentDefinition: () ==> IOmlAssignmentDefinition
  getAssignmentDefinition() == return ivAssignmentDefinition;

  public setAssignmentDefinition: IOmlAssignmentDefinition ==> ()
  setAssignmentDefinition(parg) == ivAssignmentDefinition := parg;

end OmlInstanceVariable
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariableDefinitions is subclass of IOmlInstanceVariableDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariableDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariableDefinitions(self);

  public OmlInstanceVariableDefinitions:
    (seq of IOmlInstanceVariableShape) ==> OmlInstanceVariableDefinitions
  OmlInstanceVariableDefinitions (p1) == 
    ( setVariablesList(p1) );

  public OmlInstanceVariableDefinitions:
    (seq of IOmlInstanceVariableShape) *
    nat *
    nat ==> OmlInstanceVariableDefinitions
  OmlInstanceVariableDefinitions (p1,line,column) == 
    ( setVariablesList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "variables_list" in
        if fname in set dom data
        then setVariablesList(data(fname)) );

instance variables
  private ivVariablesList : seq of IOmlInstanceVariableShape := []

operations
  public getVariablesList: () ==> seq of IOmlInstanceVariableShape
  getVariablesList() == return ivVariablesList;

  public setVariablesList: seq of IOmlInstanceVariableShape ==> ()
  setVariablesList(parg) == ivVariablesList := parg;

  public addVariablesList: IOmlNode ==> ()
  addVariablesList (parg) == ivVariablesList := ivVariablesList ^ [parg];

end OmlInstanceVariableDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariableInvariant is subclass of IOmlInstanceVariableInvariant
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariableInvariant";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariableInvariant(self);

  public OmlInstanceVariableInvariant:
    (IOmlExpression) ==> OmlInstanceVariableInvariant
  OmlInstanceVariableInvariant (p1) == 
    ( setInvariant(p1) );

  public OmlInstanceVariableInvariant:
    (IOmlExpression) *
    nat *
    nat ==> OmlInstanceVariableInvariant
  OmlInstanceVariableInvariant (p1,line,column) == 
    ( setInvariant(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "invariant" in
        if fname in set dom data
        then setInvariant(data(fname)) );

instance variables
  private ivInvariant : [IOmlExpression] := nil

operations
  public getInvariant: () ==> IOmlExpression
  getInvariant() == return ivInvariant;

  public setInvariant: IOmlExpression ==> ()
  setInvariant(parg) == ivInvariant := parg;

end OmlInstanceVariableInvariant
\end{vdm_al}

\begin{vdm_al}
class OmlInstanceVariableShape is subclass of IOmlInstanceVariableShape
operations
  public identity: () ==> seq of char
  identity () == return "InstanceVariableShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInstanceVariableShape(self);

end OmlInstanceVariableShape
\end{vdm_al}
\begin{vdm_al}
class OmlIntType is subclass of IOmlIntType
operations
  public identity: () ==> seq of char
  identity () == return "IntType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIntType(self);

  public OmlIntType:
    () ==> OmlIntType
  OmlIntType () == 
    skip;

  public OmlIntType:
    nat *
    nat ==> OmlIntType
  OmlIntType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlIntType
\end{vdm_al}

\begin{vdm_al}
class OmlInvariant is subclass of IOmlInvariant
operations
  public identity: () ==> seq of char
  identity () == return "Invariant";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitInvariant(self);

  public OmlInvariant:
    (IOmlPattern) *
    (IOmlExpression) ==> OmlInvariant
  OmlInvariant (p1,p2) == 
    ( setPattern(p1);
      setExpression(p2) );

  public OmlInvariant:
    (IOmlPattern) *
    (IOmlExpression) *
    nat *
    nat ==> OmlInvariant
  OmlInvariant (p1,p2,line,column) == 
    ( setPattern(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPattern : [IOmlPattern] := nil

operations
  public getPattern: () ==> IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlInvariant
\end{vdm_al}

\begin{vdm_al}
class OmlIotaExpression is subclass of IOmlIotaExpression
operations
  public identity: () ==> seq of char
  identity () == return "IotaExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIotaExpression(self);

  public OmlIotaExpression:
    (IOmlBind) *
    (IOmlExpression) ==> OmlIotaExpression
  OmlIotaExpression (p1,p2) == 
    ( setBind(p1);
      setExpression(p2) );

  public OmlIotaExpression:
    (IOmlBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIotaExpression
  OmlIotaExpression (p1,p2,line,column) == 
    ( setBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIotaExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIsExpression is subclass of IOmlIsExpression
operations
  public identity: () ==> seq of char
  identity () == return "IsExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIsExpression(self);

  public OmlIsExpression:
    (IOmlType) *
    (IOmlExpression) ==> OmlIsExpression
  OmlIsExpression (p1,p2) == 
    ( setType(p1);
      setExpression(p2) );

  public OmlIsExpression:
    (IOmlType) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIsExpression
  OmlIsExpression (p1,p2,line,column) == 
    ( setType(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIsExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIsofbaseclassExpression is subclass of IOmlIsofbaseclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "IsofbaseclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIsofbaseclassExpression(self);

  public OmlIsofbaseclassExpression:
    (IOmlName) *
    (IOmlExpression) ==> OmlIsofbaseclassExpression
  OmlIsofbaseclassExpression (p1,p2) == 
    ( setName(p1);
      setExpression(p2) );

  public OmlIsofbaseclassExpression:
    (IOmlName) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIsofbaseclassExpression
  OmlIsofbaseclassExpression (p1,p2,line,column) == 
    ( setName(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIsofbaseclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlIsofclassExpression is subclass of IOmlIsofclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "IsofclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitIsofclassExpression(self);

  public OmlIsofclassExpression:
    (IOmlName) *
    (IOmlExpression) ==> OmlIsofclassExpression
  OmlIsofclassExpression (p1,p2) == 
    ( setName(p1);
      setExpression(p2) );

  public OmlIsofclassExpression:
    (IOmlName) *
    (IOmlExpression) *
    nat *
    nat ==> OmlIsofclassExpression
  OmlIsofclassExpression (p1,p2,line,column) == 
    ( setName(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlIsofclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLambdaExpression is subclass of IOmlLambdaExpression
operations
  public identity: () ==> seq of char
  identity () == return "LambdaExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLambdaExpression(self);

  public OmlLambdaExpression:
    (seq of IOmlTypeBind) *
    (IOmlExpression) ==> OmlLambdaExpression
  OmlLambdaExpression (p1,p2) == 
    ( setTypeBindList(p1);
      setExpression(p2) );

  public OmlLambdaExpression:
    (seq of IOmlTypeBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlLambdaExpression
  OmlLambdaExpression (p1,p2,line,column) == 
    ( setTypeBindList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type_bind_list" in
        if fname in set dom data
        then setTypeBindList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivTypeBindList : seq of IOmlTypeBind := []

operations
  public getTypeBindList: () ==> seq of IOmlTypeBind
  getTypeBindList() == return ivTypeBindList;

  public setTypeBindList: seq of IOmlTypeBind ==> ()
  setTypeBindList(parg) == ivTypeBindList := parg;

  public addTypeBindList: IOmlNode ==> ()
  addTypeBindList (parg) == ivTypeBindList := ivTypeBindList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlLambdaExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLetBeExpression is subclass of IOmlLetBeExpression
operations
  public identity: () ==> seq of char
  identity () == return "LetBeExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetBeExpression(self);

  public OmlLetBeExpression:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlExpression) ==> OmlLetBeExpression
  OmlLetBeExpression (p1,p2,p3) == 
    ( setBind(p1);
      setBest(p2);
      setExpression(p3) );

  public OmlLetBeExpression:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlExpression) *
    nat *
    nat ==> OmlLetBeExpression
  OmlLetBeExpression (p1,p2,p3,line,column) == 
    ( setBind(p1);
      setBest(p2);
      setExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "best" in
        if fname in set dom data
        then setBest(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivBest : [IOmlExpression] := nil

operations
  public getBest: () ==> IOmlExpression
  getBest() == return ivBest
    pre hasBest();

  public hasBest: () ==> bool
  hasBest () == return ivBest <> nil;

  public setBest: [ IOmlExpression ] ==> ()
  setBest(parg) == ivBest := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlLetBeExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLetBeStatement is subclass of IOmlLetBeStatement
operations
  public identity: () ==> seq of char
  identity () == return "LetBeStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetBeStatement(self);

  public OmlLetBeStatement:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlStatement) ==> OmlLetBeStatement
  OmlLetBeStatement (p1,p2,p3) == 
    ( setBind(p1);
      setBest(p2);
      setStatement(p3) );

  public OmlLetBeStatement:
    (IOmlBind) *
    [IOmlExpression] *
    (IOmlStatement) *
    nat *
    nat ==> OmlLetBeStatement
  OmlLetBeStatement (p1,p2,p3,line,column) == 
    ( setBind(p1);
      setBest(p2);
      setStatement(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "best" in
        if fname in set dom data
        then setBest(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivBest : [IOmlExpression] := nil

operations
  public getBest: () ==> IOmlExpression
  getBest() == return ivBest
    pre hasBest();

  public hasBest: () ==> bool
  hasBest () == return ivBest <> nil;

  public setBest: [ IOmlExpression ] ==> ()
  setBest(parg) == ivBest := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlLetBeStatement
\end{vdm_al}

\begin{vdm_al}
class OmlLetExpression is subclass of IOmlLetExpression
operations
  public identity: () ==> seq of char
  identity () == return "LetExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetExpression(self);

  public OmlLetExpression:
    (seq of IOmlValueShape) *
    (IOmlExpression) ==> OmlLetExpression
  OmlLetExpression (p1,p2) == 
    ( setDefinitionList(p1);
      setExpression(p2) );

  public OmlLetExpression:
    (seq of IOmlValueShape) *
    (IOmlExpression) *
    nat *
    nat ==> OmlLetExpression
  OmlLetExpression (p1,p2,line,column) == 
    ( setDefinitionList(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlValueShape := []

operations
  public getDefinitionList: () ==> seq of IOmlValueShape
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlValueShape ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlLetExpression
\end{vdm_al}

\begin{vdm_al}
class OmlLetStatement is subclass of IOmlLetStatement
operations
  public identity: () ==> seq of char
  identity () == return "LetStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLetStatement(self);

  public OmlLetStatement:
    (seq of IOmlValueShape) *
    (IOmlStatement) ==> OmlLetStatement
  OmlLetStatement (p1,p2) == 
    ( setDefinitionList(p1);
      setStatement(p2) );

  public OmlLetStatement:
    (seq of IOmlValueShape) *
    (IOmlStatement) *
    nat *
    nat ==> OmlLetStatement
  OmlLetStatement (p1,p2,line,column) == 
    ( setDefinitionList(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlValueShape := []

operations
  public getDefinitionList: () ==> seq of IOmlValueShape
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlValueShape ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlLetStatement
\end{vdm_al}

\begin{vdm_al}
class OmlLexem is subclass of IOmlLexem

instance variables
  private ivLine : nat := 0

operations
  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLexem(self);

  public getLine: () ==> nat
  getLine () == return ivLine;

  public setLine: nat ==> ()
  setLine (pline) == ivLine := pline

instance variables
  private ivColumn : nat := 0

operations
  public getColumn: () ==> nat
  getColumn () == return ivColumn;

  public setColumn: nat ==> ()
  setColumn (pcolumn) == ivColumn := pcolumn

instance variables
  private ivLexval : nat := 0

operations
  public getLexval: () ==> nat
  getLexval () == return ivLexval;

  public setLexval: nat ==> ()
  setLexval (plexval) == ivLexval := plexval

instance variables
  private ivText : seq of char := []

operations
  public getText: () ==> seq of char
  getText () == return ivText;

  public setText: seq of char ==> ()
  setText (ptext) == ivText := ptext

instance variables
  private ivType : nat := ILEXEMUNKNOWN

operations
  public getType: () ==> nat
  getType () == return ivType;

  public isKeyword: () ==> bool
  isKeyword () == return ivType = ILEXEMKEYWORD;

  public isIdentifier: () ==> bool
  isIdentifier () == return ivType = ILEXEMIDENTIFIER;

  public isComment: () ==> bool
  isComment () == return (ivType = ILEXEMLINECOMMENT) or (ivType = ILEXEMBLOCKCOMMENT);

  public isLineComment: () ==> bool
  isLineComment () == return ivType = ILEXEMLINECOMMENT;

  public isBlockComment: () ==> bool
  isBlockComment () == return ivType = ILEXEMBLOCKCOMMENT;

  public OmlLexem: nat * nat * nat * seq of char * nat ==> OmlLexem
  OmlLexem (pline, pcolumn, plexval, ptext, ptype) ==
    ( ivLine := pline;
      ivColumn := pcolumn;
      ivLexval := plexval;
      ivText := ptext;
      ivType := ptype )

end OmlLexem
\end{vdm_al}
\begin{vdm_al}
class OmlLiteral is subclass of IOmlLiteral
operations
  public identity: () ==> seq of char
  identity () == return "Literal";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitLiteral(self);

end OmlLiteral
\end{vdm_al}
\begin{vdm_al}
class OmlMapComprehension is subclass of IOmlMapComprehension
operations
  public identity: () ==> seq of char
  identity () == return "MapComprehension";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMapComprehension(self);

  public OmlMapComprehension:
    (IOmlMaplet) *
    (seq of IOmlBind) *
    [IOmlExpression] ==> OmlMapComprehension
  OmlMapComprehension (p1,p2,p3) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3) );

  public OmlMapComprehension:
    (IOmlMaplet) *
    (seq of IOmlBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlMapComprehension
  OmlMapComprehension (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivExpression : [IOmlMaplet] := nil

operations
  public getExpression: () ==> IOmlMaplet
  getExpression() == return ivExpression;

  public setExpression: IOmlMaplet ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivGuard : [IOmlExpression] := nil

operations
  public getGuard: () ==> IOmlExpression
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IOmlExpression ] ==> ()
  setGuard(parg) == ivGuard := parg;

end OmlMapComprehension
\end{vdm_al}

\begin{vdm_al}
class OmlMapEnumeration is subclass of IOmlMapEnumeration
operations
  public identity: () ==> seq of char
  identity () == return "MapEnumeration";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMapEnumeration(self);

  public OmlMapEnumeration:
    (seq of IOmlMaplet) ==> OmlMapEnumeration
  OmlMapEnumeration (p1) == 
    ( setMapletList(p1) );

  public OmlMapEnumeration:
    (seq of IOmlMaplet) *
    nat *
    nat ==> OmlMapEnumeration
  OmlMapEnumeration (p1,line,column) == 
    ( setMapletList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "maplet_list" in
        if fname in set dom data
        then setMapletList(data(fname)) );

instance variables
  private ivMapletList : seq of IOmlMaplet := []

operations
  public getMapletList: () ==> seq of IOmlMaplet
  getMapletList() == return ivMapletList;

  public setMapletList: seq of IOmlMaplet ==> ()
  setMapletList(parg) == ivMapletList := parg;

  public addMapletList: IOmlNode ==> ()
  addMapletList (parg) == ivMapletList := ivMapletList ^ [parg];

end OmlMapEnumeration
\end{vdm_al}

\begin{vdm_al}
class OmlMapOrSequenceReference is subclass of IOmlMapOrSequenceReference
operations
  public identity: () ==> seq of char
  identity () == return "MapOrSequenceReference";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMapOrSequenceReference(self);

  public OmlMapOrSequenceReference:
    (IOmlStateDesignator) *
    (IOmlExpression) ==> OmlMapOrSequenceReference
  OmlMapOrSequenceReference (p1,p2) == 
    ( setStateDesignator(p1);
      setExpression(p2) );

  public OmlMapOrSequenceReference:
    (IOmlStateDesignator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlMapOrSequenceReference
  OmlMapOrSequenceReference (p1,p2,line,column) == 
    ( setStateDesignator(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "state_designator" in
        if fname in set dom data
        then setStateDesignator(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivStateDesignator : [IOmlStateDesignator] := nil

operations
  public getStateDesignator: () ==> IOmlStateDesignator
  getStateDesignator() == return ivStateDesignator;

  public setStateDesignator: IOmlStateDesignator ==> ()
  setStateDesignator(parg) == ivStateDesignator := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlMapOrSequenceReference
\end{vdm_al}

\begin{vdm_al}
class OmlMaplet is subclass of IOmlMaplet
operations
  public identity: () ==> seq of char
  identity () == return "Maplet";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMaplet(self);

  public OmlMaplet:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlMaplet
  OmlMaplet (p1,p2) == 
    ( setDomExpression(p1);
      setRngExpression(p2) );

  public OmlMaplet:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlMaplet
  OmlMaplet (p1,p2,line,column) == 
    ( setDomExpression(p1);
      setRngExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_expression" in
        if fname in set dom data
        then setDomExpression(data(fname));
      let fname = "rng_expression" in
        if fname in set dom data
        then setRngExpression(data(fname)) );

instance variables
  private ivDomExpression : [IOmlExpression] := nil

operations
  public getDomExpression: () ==> IOmlExpression
  getDomExpression() == return ivDomExpression;

  public setDomExpression: IOmlExpression ==> ()
  setDomExpression(parg) == ivDomExpression := parg;

instance variables
  private ivRngExpression : [IOmlExpression] := nil

operations
  public getRngExpression: () ==> IOmlExpression
  getRngExpression() == return ivRngExpression;

  public setRngExpression: IOmlExpression ==> ()
  setRngExpression(parg) == ivRngExpression := parg;

end OmlMaplet
\end{vdm_al}

\begin{vdm_al}
class OmlMatchValue is subclass of IOmlMatchValue
operations
  public identity: () ==> seq of char
  identity () == return "MatchValue";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMatchValue(self);

  public OmlMatchValue:
    (IOmlExpression) ==> OmlMatchValue
  OmlMatchValue (p1) == 
    ( setExpression(p1) );

  public OmlMatchValue:
    (IOmlExpression) *
    nat *
    nat ==> OmlMatchValue
  OmlMatchValue (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlMatchValue
\end{vdm_al}

\begin{vdm_al}
class OmlMode is subclass of IOmlMode
operations
  public identity: () ==> seq of char
  identity () == return "Mode";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMode(self);

  public OmlMode: nat ==> OmlMode
  OmlMode (pv) == setValue(pv);

  public OmlMode: nat * nat * nat ==> OmlMode
  OmlMode (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlModeQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlModeQuotes`getQuoteName(val)
    pre val <> nil;

end OmlMode
\end{vdm_al}
\begin{vdm_al}
class OmlModeQuotes
instance variables
  static public IQWR : nat := 0;
  static public IQRD : nat := 1;

  static private qmap : map nat to seq of char :=
    { IQWR |-> "<WR>",
      IQRD |-> "<RD>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlModeQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlMuExpression is subclass of IOmlMuExpression
operations
  public identity: () ==> seq of char
  identity () == return "MuExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMuExpression(self);

  public OmlMuExpression:
    (IOmlExpression) *
    (seq of IOmlRecordModifier) ==> OmlMuExpression
  OmlMuExpression (p1,p2) == 
    ( setExpression(p1);
      setModifierList(p2) );

  public OmlMuExpression:
    (IOmlExpression) *
    (seq of IOmlRecordModifier) *
    nat *
    nat ==> OmlMuExpression
  OmlMuExpression (p1,p2,line,column) == 
    ( setExpression(p1);
      setModifierList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "modifier_list" in
        if fname in set dom data
        then setModifierList(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivModifierList : seq of IOmlRecordModifier := []

operations
  public getModifierList: () ==> seq of IOmlRecordModifier
  getModifierList() == return ivModifierList;

  public setModifierList: seq of IOmlRecordModifier ==> ()
  setModifierList(parg) == ivModifierList := parg;

  public addModifierList: IOmlNode ==> ()
  addModifierList (parg) == ivModifierList := ivModifierList ^ [parg];

end OmlMuExpression
\end{vdm_al}

\begin{vdm_al}
class OmlMutexAllPredicate is subclass of IOmlMutexAllPredicate
operations
  public identity: () ==> seq of char
  identity () == return "MutexAllPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMutexAllPredicate(self);

  public OmlMutexAllPredicate:
    () ==> OmlMutexAllPredicate
  OmlMutexAllPredicate () == 
    skip;

  public OmlMutexAllPredicate:
    nat *
    nat ==> OmlMutexAllPredicate
  OmlMutexAllPredicate (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlMutexAllPredicate
\end{vdm_al}

\begin{vdm_al}
class OmlMutexPredicate is subclass of IOmlMutexPredicate
operations
  public identity: () ==> seq of char
  identity () == return "MutexPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitMutexPredicate(self);

  public OmlMutexPredicate:
    (seq of IOmlName) ==> OmlMutexPredicate
  OmlMutexPredicate (p1) == 
    ( setNameList(p1) );

  public OmlMutexPredicate:
    (seq of IOmlName) *
    nat *
    nat ==> OmlMutexPredicate
  OmlMutexPredicate (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlMutexPredicate
\end{vdm_al}

\begin{vdm_al}
class OmlName is subclass of IOmlName
operations
  public identity: () ==> seq of char
  identity () == return "Name";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitName(self);

  public OmlName:
    [seq of char] *
    (seq of char) ==> OmlName
  OmlName (p1,p2) == 
    ( setClassIdentifier(p1);
      setIdentifier(p2) );

  public OmlName:
    [seq of char] *
    (seq of char) *
    nat *
    nat ==> OmlName
  OmlName (p1,p2,line,column) == 
    ( setClassIdentifier(p1);
      setIdentifier(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "class_identifier" in
        if fname in set dom data
        then setClassIdentifier(data(fname));
      let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivClassIdentifier : [seq of char] := nil

operations
  public getClassIdentifier: () ==> seq of char
  getClassIdentifier() == return ivClassIdentifier
    pre hasClassIdentifier();

  public hasClassIdentifier: () ==> bool
  hasClassIdentifier () == return ivClassIdentifier <> nil;

  public setClassIdentifier: [ seq of char ] ==> ()
  setClassIdentifier(parg) == ivClassIdentifier := parg;

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlName
\end{vdm_al}

\begin{vdm_al}
class OmlNamedTrace is subclass of IOmlNamedTrace
operations
  public identity: () ==> seq of char
  identity () == return "NamedTrace";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNamedTrace(self);

  public OmlNamedTrace:
    (seq of char) *
    (IOmlTraceDefinition) ==> OmlNamedTrace
  OmlNamedTrace (p1,p2) == 
    ( setName(p1);
      setDefs(p2) );

  public OmlNamedTrace:
    (seq of char) *
    (IOmlTraceDefinition) *
    nat *
    nat ==> OmlNamedTrace
  OmlNamedTrace (p1,p2,line,column) == 
    ( setName(p1);
      setDefs(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "defs" in
        if fname in set dom data
        then setDefs(data(fname)) );

instance variables
  private ivName : seq of char := []

operations
  public getName: () ==> seq of char
  getName() == return ivName;

  public setName: seq of char ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivDefs : [IOmlTraceDefinition] := nil

operations
  public getDefs: () ==> IOmlTraceDefinition
  getDefs() == return ivDefs;

  public setDefs: IOmlTraceDefinition ==> ()
  setDefs(parg) == ivDefs := parg;

end OmlNamedTrace
\end{vdm_al}

\begin{vdm_al}
class OmlNat1Type is subclass of IOmlNat1Type
operations
  public identity: () ==> seq of char
  identity () == return "Nat1Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNat1Type(self);

  public OmlNat1Type:
    () ==> OmlNat1Type
  OmlNat1Type () == 
    skip;

  public OmlNat1Type:
    nat *
    nat ==> OmlNat1Type
  OmlNat1Type (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlNat1Type
\end{vdm_al}

\begin{vdm_al}
class OmlNatType is subclass of IOmlNatType
operations
  public identity: () ==> seq of char
  identity () == return "NatType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNatType(self);

  public OmlNatType:
    () ==> OmlNatType
  OmlNatType () == 
    skip;

  public OmlNatType:
    nat *
    nat ==> OmlNatType
  OmlNatType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlNatType
\end{vdm_al}

\begin{vdm_al}
class OmlNewExpression is subclass of IOmlNewExpression
operations
  public identity: () ==> seq of char
  identity () == return "NewExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNewExpression(self);

  public OmlNewExpression:
    (IOmlName) *
    (seq of IOmlType) *
    (seq of IOmlExpression) ==> OmlNewExpression
  OmlNewExpression (p1,p2,p3) == 
    ( setName(p1);
      setGenericTypes(p2);
      setExpressionList(p3) );

  public OmlNewExpression:
    (IOmlName) *
    (seq of IOmlType) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlNewExpression
  OmlNewExpression (p1,p2,p3,line,column) == 
    ( setName(p1);
      setGenericTypes(p2);
      setExpressionList(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "generic_types" in
        if fname in set dom data
        then setGenericTypes(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivGenericTypes : seq of IOmlType := []

operations
  public getGenericTypes: () ==> seq of IOmlType
  getGenericTypes() == return ivGenericTypes;

  public setGenericTypes: seq of IOmlType ==> ()
  setGenericTypes(parg) == ivGenericTypes := parg;

  public addGenericTypes: IOmlNode ==> ()
  addGenericTypes (parg) == ivGenericTypes := ivGenericTypes ^ [parg];

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlNewExpression
\end{vdm_al}

\begin{vdm_al}
class OmlNilLiteral is subclass of IOmlNilLiteral
operations
  public identity: () ==> seq of char
  identity () == return "NilLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNilLiteral(self);

  public OmlNilLiteral:
    () ==> OmlNilLiteral
  OmlNilLiteral () == 
    skip;

  public OmlNilLiteral:
    nat *
    nat ==> OmlNilLiteral
  OmlNilLiteral (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlNilLiteral
\end{vdm_al}

\begin{vdm_al}
class IOmlContextInfo

operations
  public accept: IOmlVisitor ==> ()
  accept (-) == is subclass responsibility

end IOmlContextInfo
\end{vdm_al}

\begin{vdm_al}
-- important note: this class is renamed to OmlNode by the patch script!
class IOmlNode

values
  public static prefix : seq of char = "Oml"

types
  public FieldValue = 
    bool | char | nat | real | IOmlNode | 
    seq of FieldValue |
    set of FieldValue |
    map FieldValue to FieldValue

instance variables
  private ivInfo : map nat to IOmlContextInfo := {|->}

operations
  public identity: () ==> seq of char
  identity () == return "Node";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNode(self);

  public getContextInfo: nat ==> IOmlContextInfo
  getContextInfo (pci) == return ivInfo(pci)
    pre pci in set dom ivInfo;

  public getContextInfoCount: () ==> nat
  getContextInfoCount () == return card dom ivInfo;

  public addContextInfo: IOmlContextInfo ==> nat
  addContextInfo (pci) ==
    ( dcl res : nat := card dom ivInfo + 1;
      ivInfo := ivInfo munion {res |-> pci};
      return res )

instance variables
  private ivLine : nat := 0;
  private ivColumn : nat := 0;

operations
  public getLine : () ==> nat
  getLine () == return ivLine;

  public setLine : nat ==> ()
  setLine (pl) == ivLine := pl;

  public getColumn : () ==> nat
  getColumn () == return ivColumn;

  public setColumn : nat ==> ()
  setColumn (pc) == ivColumn := pc;

  public setPosition : nat * nat ==> ()
  setPosition (pl, pc) ==
    ( setLine(pl); setColumn(pc) );

  public setPosLexem : IOmlLexem ==> ()
  setPosLexem (pol) ==
    ( setLine(pol.getLine());
      setColumn(pol.getColumn()) );

  public setPosNode : IOmlNode ==> ()
  setPosNode (pnd) ==
    ( setLine(pnd.getLine());
      setColumn(pnd.getColumn()) )

end IOmlNode
\end{vdm_al}

\begin{vdm_al}
class OmlNondeterministicStatement is subclass of IOmlNondeterministicStatement
operations
  public identity: () ==> seq of char
  identity () == return "NondeterministicStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNondeterministicStatement(self);

  public OmlNondeterministicStatement:
    (seq of IOmlStatement) ==> OmlNondeterministicStatement
  OmlNondeterministicStatement (p1) == 
    ( setStatementList(p1) );

  public OmlNondeterministicStatement:
    (seq of IOmlStatement) *
    nat *
    nat ==> OmlNondeterministicStatement
  OmlNondeterministicStatement (p1,line,column) == 
    ( setStatementList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "statement_list" in
        if fname in set dom data
        then setStatementList(data(fname)) );

instance variables
  private ivStatementList : seq of IOmlStatement := []

operations
  public getStatementList: () ==> seq of IOmlStatement
  getStatementList() == return ivStatementList;

  public setStatementList: seq of IOmlStatement ==> ()
  setStatementList(parg) == ivStatementList := parg;

  public addStatementList: IOmlNode ==> ()
  addStatementList (parg) == ivStatementList := ivStatementList ^ [parg];

end OmlNondeterministicStatement
\end{vdm_al}

\begin{vdm_al}
class OmlNumericLiteral is subclass of IOmlNumericLiteral
operations
  public identity: () ==> seq of char
  identity () == return "NumericLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitNumericLiteral(self);

  public OmlNumericLiteral:
    (nat) ==> OmlNumericLiteral
  OmlNumericLiteral (p1) == 
    ( setVal(p1) );

  public OmlNumericLiteral:
    (nat) *
    nat *
    nat ==> OmlNumericLiteral
  OmlNumericLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [nat] := nil

operations
  public getVal: () ==> nat
  getVal() == return ivVal;

  public setVal: nat ==> ()
  setVal(parg) == ivVal := parg;

end OmlNumericLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlObjectApply is subclass of IOmlObjectApply
operations
  public identity: () ==> seq of char
  identity () == return "ObjectApply";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectApply(self);

  public OmlObjectApply:
    (IOmlObjectDesignator) *
    (seq of IOmlExpression) ==> OmlObjectApply
  OmlObjectApply (p1,p2) == 
    ( setObjectDesignator(p1);
      setExpressionList(p2) );

  public OmlObjectApply:
    (IOmlObjectDesignator) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlObjectApply
  OmlObjectApply (p1,p2,line,column) == 
    ( setObjectDesignator(p1);
      setExpressionList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "object_designator" in
        if fname in set dom data
        then setObjectDesignator(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivObjectDesignator : [IOmlObjectDesignator] := nil

operations
  public getObjectDesignator: () ==> IOmlObjectDesignator
  getObjectDesignator() == return ivObjectDesignator;

  public setObjectDesignator: IOmlObjectDesignator ==> ()
  setObjectDesignator(parg) == ivObjectDesignator := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlObjectApply
\end{vdm_al}

\begin{vdm_al}
class OmlObjectDesignator is subclass of IOmlObjectDesignator
operations
  public identity: () ==> seq of char
  identity () == return "ObjectDesignator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectDesignator(self);

end OmlObjectDesignator
\end{vdm_al}
\begin{vdm_al}
class OmlObjectDesignatorExpression is subclass of IOmlObjectDesignatorExpression
operations
  public identity: () ==> seq of char
  identity () == return "ObjectDesignatorExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectDesignatorExpression(self);

  public OmlObjectDesignatorExpression:
    (IOmlExpression) ==> OmlObjectDesignatorExpression
  OmlObjectDesignatorExpression (p1) == 
    ( setExpression(p1) );

  public OmlObjectDesignatorExpression:
    (IOmlExpression) *
    nat *
    nat ==> OmlObjectDesignatorExpression
  OmlObjectDesignatorExpression (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlObjectDesignatorExpression
\end{vdm_al}

\begin{vdm_al}
class OmlObjectFieldReference is subclass of IOmlObjectFieldReference
operations
  public identity: () ==> seq of char
  identity () == return "ObjectFieldReference";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitObjectFieldReference(self);

  public OmlObjectFieldReference:
    (IOmlObjectDesignator) *
    (IOmlName) ==> OmlObjectFieldReference
  OmlObjectFieldReference (p1,p2) == 
    ( setObjectDesignator(p1);
      setName(p2) );

  public OmlObjectFieldReference:
    (IOmlObjectDesignator) *
    (IOmlName) *
    nat *
    nat ==> OmlObjectFieldReference
  OmlObjectFieldReference (p1,p2,line,column) == 
    ( setObjectDesignator(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "object_designator" in
        if fname in set dom data
        then setObjectDesignator(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivObjectDesignator : [IOmlObjectDesignator] := nil

operations
  public getObjectDesignator: () ==> IOmlObjectDesignator
  getObjectDesignator() == return ivObjectDesignator;

  public setObjectDesignator: IOmlObjectDesignator ==> ()
  setObjectDesignator(parg) == ivObjectDesignator := parg;

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlObjectFieldReference
\end{vdm_al}

\begin{vdm_al}
class OmlOldName is subclass of IOmlOldName
operations
  public identity: () ==> seq of char
  identity () == return "OldName";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOldName(self);

  public OmlOldName:
    (seq of char) ==> OmlOldName
  OmlOldName (p1) == 
    ( setIdentifier(p1) );

  public OmlOldName:
    (seq of char) *
    nat *
    nat ==> OmlOldName
  OmlOldName (p1,line,column) == 
    ( setIdentifier(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlOldName
\end{vdm_al}

\begin{vdm_al}
class OmlOperationBody is subclass of IOmlOperationBody
operations
  public identity: () ==> seq of char
  identity () == return "OperationBody";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationBody(self);

  public OmlOperationBody:
    [IOmlStatement] *
    (bool) *
    (bool) ==> OmlOperationBody
  OmlOperationBody (p1,p2,p3) == 
    ( setStatement(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3) );

  public OmlOperationBody:
    [IOmlStatement] *
    (bool) *
    (bool) *
    nat *
    nat ==> OmlOperationBody
  OmlOperationBody (p1,p2,p3,line,column) == 
    ( setStatement(p1);
      setNotYetSpecified(p2);
      setSubclassResponsibility(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname));
      let fname = "not_yet_specified" in
        if fname in set dom data
        then setNotYetSpecified(data(fname));
      let fname = "subclass_responsibility" in
        if fname in set dom data
        then setSubclassResponsibility(data(fname)) );

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement
    pre hasStatement();

  public hasStatement: () ==> bool
  hasStatement () == return ivStatement <> nil;

  public setStatement: [ IOmlStatement ] ==> ()
  setStatement(parg) == ivStatement := parg;

instance variables
  private ivNotYetSpecified : [bool] := nil

operations
  public getNotYetSpecified: () ==> bool
  getNotYetSpecified() == return ivNotYetSpecified;

  public setNotYetSpecified: bool ==> ()
  setNotYetSpecified(parg) == ivNotYetSpecified := parg;

instance variables
  private ivSubclassResponsibility : [bool] := nil

operations
  public getSubclassResponsibility: () ==> bool
  getSubclassResponsibility() == return ivSubclassResponsibility;

  public setSubclassResponsibility: bool ==> ()
  setSubclassResponsibility(parg) == ivSubclassResponsibility := parg;

end OmlOperationBody
\end{vdm_al}

\begin{vdm_al}
class OmlOperationDefinition is subclass of IOmlOperationDefinition
operations
  public identity: () ==> seq of char
  identity () == return "OperationDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationDefinition(self);

  public OmlOperationDefinition:
    (IOmlAccessDefinition) *
    (IOmlOperationShape) ==> OmlOperationDefinition
  OmlOperationDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlOperationDefinition:
    (IOmlAccessDefinition) *
    (IOmlOperationShape) *
    nat *
    nat ==> OmlOperationDefinition
  OmlOperationDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlOperationShape] := nil

operations
  public getShape: () ==> IOmlOperationShape
  getShape() == return ivShape;

  public setShape: IOmlOperationShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlOperationDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlOperationDefinitions is subclass of IOmlOperationDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "OperationDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationDefinitions(self);

  public OmlOperationDefinitions:
    (seq of IOmlOperationDefinition) ==> OmlOperationDefinitions
  OmlOperationDefinitions (p1) == 
    ( setOperationList(p1) );

  public OmlOperationDefinitions:
    (seq of IOmlOperationDefinition) *
    nat *
    nat ==> OmlOperationDefinitions
  OmlOperationDefinitions (p1,line,column) == 
    ( setOperationList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "operation_list" in
        if fname in set dom data
        then setOperationList(data(fname)) );

instance variables
  private ivOperationList : seq of IOmlOperationDefinition := []

operations
  public getOperationList: () ==> seq of IOmlOperationDefinition
  getOperationList() == return ivOperationList;

  public setOperationList: seq of IOmlOperationDefinition ==> ()
  setOperationList(parg) == ivOperationList := parg;

  public addOperationList: IOmlNode ==> ()
  addOperationList (parg) == ivOperationList := ivOperationList ^ [parg];

end OmlOperationDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlOperationShape is subclass of IOmlOperationShape
operations
  public identity: () ==> seq of char
  identity () == return "OperationShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationShape(self);

end OmlOperationShape
\end{vdm_al}
\begin{vdm_al}
class OmlOperationTrailer is subclass of IOmlOperationTrailer
operations
  public identity: () ==> seq of char
  identity () == return "OperationTrailer";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationTrailer(self);

  public OmlOperationTrailer:
    [IOmlExternals] *
    [IOmlExpression] *
    [IOmlExpression] *
    [IOmlExceptions] ==> OmlOperationTrailer
  OmlOperationTrailer (p1,p2,p3,p4) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4) );

  public OmlOperationTrailer:
    [IOmlExternals] *
    [IOmlExpression] *
    [IOmlExpression] *
    [IOmlExceptions] *
    nat *
    nat ==> OmlOperationTrailer
  OmlOperationTrailer (p1,p2,p3,p4,line,column) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "externals" in
        if fname in set dom data
        then setExternals(data(fname));
      let fname = "pre_expression" in
        if fname in set dom data
        then setPreExpression(data(fname));
      let fname = "post_expression" in
        if fname in set dom data
        then setPostExpression(data(fname));
      let fname = "exceptions" in
        if fname in set dom data
        then setExceptions(data(fname)) );

instance variables
  private ivExternals : [IOmlExternals] := nil

operations
  public getExternals: () ==> IOmlExternals
  getExternals() == return ivExternals
    pre hasExternals();

  public hasExternals: () ==> bool
  hasExternals () == return ivExternals <> nil;

  public setExternals: [ IOmlExternals ] ==> ()
  setExternals(parg) == ivExternals := parg;

instance variables
  private ivPreExpression : [IOmlExpression] := nil

operations
  public getPreExpression: () ==> IOmlExpression
  getPreExpression() == return ivPreExpression
    pre hasPreExpression();

  public hasPreExpression: () ==> bool
  hasPreExpression () == return ivPreExpression <> nil;

  public setPreExpression: [ IOmlExpression ] ==> ()
  setPreExpression(parg) == ivPreExpression := parg;

instance variables
  private ivPostExpression : [IOmlExpression] := nil

operations
  public getPostExpression: () ==> IOmlExpression
  getPostExpression() == return ivPostExpression
    pre hasPostExpression();

  public hasPostExpression: () ==> bool
  hasPostExpression () == return ivPostExpression <> nil;

  public setPostExpression: [ IOmlExpression ] ==> ()
  setPostExpression(parg) == ivPostExpression := parg;

instance variables
  private ivExceptions : [IOmlExceptions] := nil

operations
  public getExceptions: () ==> IOmlExceptions
  getExceptions() == return ivExceptions
    pre hasExceptions();

  public hasExceptions: () ==> bool
  hasExceptions () == return ivExceptions <> nil;

  public setExceptions: [ IOmlExceptions ] ==> ()
  setExceptions(parg) == ivExceptions := parg;

end OmlOperationTrailer
\end{vdm_al}

\begin{vdm_al}
class OmlOperationType is subclass of IOmlOperationType
operations
  public identity: () ==> seq of char
  identity () == return "OperationType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOperationType(self);

  public OmlOperationType:
    (IOmlType) *
    (IOmlType) ==> OmlOperationType
  OmlOperationType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlOperationType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlOperationType
  OmlOperationType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlOperationType
\end{vdm_al}

\begin{vdm_al}
class OmlOptionalType is subclass of IOmlOptionalType
operations
  public identity: () ==> seq of char
  identity () == return "OptionalType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitOptionalType(self);

  public OmlOptionalType:
    (IOmlType) ==> OmlOptionalType
  OmlOptionalType (p1) == 
    ( setType(p1) );

  public OmlOptionalType:
    (IOmlType) *
    nat *
    nat ==> OmlOptionalType
  OmlOptionalType (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlOptionalType
\end{vdm_al}

\begin{vdm_al}
class OmlParameter is subclass of IOmlParameter
operations
  public identity: () ==> seq of char
  identity () == return "Parameter";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitParameter(self);

  public OmlParameter:
    (seq of IOmlPattern) ==> OmlParameter
  OmlParameter (p1) == 
    ( setPatternList(p1) );

  public OmlParameter:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlParameter
  OmlParameter (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlParameter
\end{vdm_al}

\begin{vdm_al}
class OmlPartialFunctionType is subclass of IOmlPartialFunctionType
operations
  public identity: () ==> seq of char
  identity () == return "PartialFunctionType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPartialFunctionType(self);

  public OmlPartialFunctionType:
    (IOmlType) *
    (IOmlType) ==> OmlPartialFunctionType
  OmlPartialFunctionType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlPartialFunctionType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlPartialFunctionType
  OmlPartialFunctionType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlPartialFunctionType
\end{vdm_al}

\begin{vdm_al}
class OmlPattern is subclass of IOmlPattern
operations
  public identity: () ==> seq of char
  identity () == return "Pattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPattern(self);

end OmlPattern
\end{vdm_al}
\begin{vdm_al}
class OmlPatternBind is subclass of IOmlPatternBind
operations
  public identity: () ==> seq of char
  identity () == return "PatternBind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternBind(self);

end OmlPatternBind
\end{vdm_al}
\begin{vdm_al}
class OmlPatternBindExpression is subclass of IOmlPatternBindExpression
operations
  public identity: () ==> seq of char
  identity () == return "PatternBindExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternBindExpression(self);

  public OmlPatternBindExpression:
    (IOmlPatternBind) *
    (IOmlExpression) ==> OmlPatternBindExpression
  OmlPatternBindExpression (p1,p2) == 
    ( setPatternBind(p1);
      setExpression(p2) );

  public OmlPatternBindExpression:
    (IOmlPatternBind) *
    (IOmlExpression) *
    nat *
    nat ==> OmlPatternBindExpression
  OmlPatternBindExpression (p1,p2,line,column) == 
    ( setPatternBind(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlPatternBindExpression
\end{vdm_al}

\begin{vdm_al}
class OmlPatternIdentifier is subclass of IOmlPatternIdentifier
operations
  public identity: () ==> seq of char
  identity () == return "PatternIdentifier";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternIdentifier(self);

  public OmlPatternIdentifier:
    (seq of char) ==> OmlPatternIdentifier
  OmlPatternIdentifier (p1) == 
    ( setIdentifier(p1) );

  public OmlPatternIdentifier:
    (seq of char) *
    nat *
    nat ==> OmlPatternIdentifier
  OmlPatternIdentifier (p1,line,column) == 
    ( setIdentifier(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlPatternIdentifier
\end{vdm_al}

\begin{vdm_al}
class OmlPatternTypePair is subclass of IOmlPatternTypePair
operations
  public identity: () ==> seq of char
  identity () == return "PatternTypePair";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPatternTypePair(self);

  public OmlPatternTypePair:
    (seq of IOmlPattern) *
    (IOmlType) ==> OmlPatternTypePair
  OmlPatternTypePair (p1,p2) == 
    ( setPatternList(p1);
      setType(p2) );

  public OmlPatternTypePair:
    (seq of IOmlPattern) *
    (IOmlType) *
    nat *
    nat ==> OmlPatternTypePair
  OmlPatternTypePair (p1,p2,line,column) == 
    ( setPatternList(p1);
      setType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlPatternTypePair
\end{vdm_al}

\begin{vdm_al}
class OmlPeriodicThread is subclass of IOmlPeriodicThread
operations
  public identity: () ==> seq of char
  identity () == return "PeriodicThread";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPeriodicThread(self);

  public OmlPeriodicThread:
    (seq of IOmlExpression) *
    (IOmlName) ==> OmlPeriodicThread
  OmlPeriodicThread (p1,p2) == 
    ( setArgs(p1);
      setName(p2) );

  public OmlPeriodicThread:
    (seq of IOmlExpression) *
    (IOmlName) *
    nat *
    nat ==> OmlPeriodicThread
  OmlPeriodicThread (p1,p2,line,column) == 
    ( setArgs(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "args" in
        if fname in set dom data
        then setArgs(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivArgs : seq of IOmlExpression := []

operations
  public getArgs: () ==> seq of IOmlExpression
  getArgs() == return ivArgs;

  public setArgs: seq of IOmlExpression ==> ()
  setArgs(parg) == ivArgs := parg;

  public addArgs: IOmlNode ==> ()
  addArgs (parg) == ivArgs := ivArgs ^ [parg];

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlPeriodicThread
\end{vdm_al}

\begin{vdm_al}
class OmlPermissionPredicate is subclass of IOmlPermissionPredicate
operations
  public identity: () ==> seq of char
  identity () == return "PermissionPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPermissionPredicate(self);

  public OmlPermissionPredicate:
    (IOmlName) *
    (IOmlExpression) ==> OmlPermissionPredicate
  OmlPermissionPredicate (p1,p2) == 
    ( setName(p1);
      setExpression(p2) );

  public OmlPermissionPredicate:
    (IOmlName) *
    (IOmlExpression) *
    nat *
    nat ==> OmlPermissionPredicate
  OmlPermissionPredicate (p1,p2,line,column) == 
    ( setName(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlPermissionPredicate
\end{vdm_al}

\begin{vdm_al}
class OmlPreconditionExpression is subclass of IOmlPreconditionExpression
operations
  public identity: () ==> seq of char
  identity () == return "PreconditionExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitPreconditionExpression(self);

  public OmlPreconditionExpression:
    (seq of IOmlExpression) ==> OmlPreconditionExpression
  OmlPreconditionExpression (p1) == 
    ( setExpressionList(p1) );

  public OmlPreconditionExpression:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlPreconditionExpression
  OmlPreconditionExpression (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlPreconditionExpression
\end{vdm_al}

\begin{vdm_al}
class OmlProcedureThread is subclass of IOmlProcedureThread
operations
  public identity: () ==> seq of char
  identity () == return "ProcedureThread";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitProcedureThread(self);

  public OmlProcedureThread:
    (IOmlStatement) ==> OmlProcedureThread
  OmlProcedureThread (p1) == 
    ( setStatement(p1) );

  public OmlProcedureThread:
    (IOmlStatement) *
    nat *
    nat ==> OmlProcedureThread
  OmlProcedureThread (p1,line,column) == 
    ( setStatement(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlProcedureThread
\end{vdm_al}

\begin{vdm_al}
class OmlProductType is subclass of IOmlProductType
operations
  public identity: () ==> seq of char
  identity () == return "ProductType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitProductType(self);

  public OmlProductType:
    (IOmlType) *
    (IOmlType) ==> OmlProductType
  OmlProductType (p1,p2) == 
    ( setLhsType(p1);
      setRhsType(p2) );

  public OmlProductType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlProductType
  OmlProductType (p1,p2,line,column) == 
    ( setLhsType(p1);
      setRhsType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_type" in
        if fname in set dom data
        then setLhsType(data(fname));
      let fname = "rhs_type" in
        if fname in set dom data
        then setRhsType(data(fname)) );

instance variables
  private ivLhsType : [IOmlType] := nil

operations
  public getLhsType: () ==> IOmlType
  getLhsType() == return ivLhsType;

  public setLhsType: IOmlType ==> ()
  setLhsType(parg) == ivLhsType := parg;

instance variables
  private ivRhsType : [IOmlType] := nil

operations
  public getRhsType: () ==> IOmlType
  getRhsType() == return ivRhsType;

  public setRhsType: IOmlType ==> ()
  setRhsType(parg) == ivRhsType := parg;

end OmlProductType
\end{vdm_al}

\begin{vdm_al}
class OmlQuoteLiteral is subclass of IOmlQuoteLiteral
operations
  public identity: () ==> seq of char
  identity () == return "QuoteLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitQuoteLiteral(self);

  public OmlQuoteLiteral:
    (seq of char) ==> OmlQuoteLiteral
  OmlQuoteLiteral (p1) == 
    ( setVal(p1) );

  public OmlQuoteLiteral:
    (seq of char) *
    nat *
    nat ==> OmlQuoteLiteral
  OmlQuoteLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : seq of char := []

operations
  public getVal: () ==> seq of char
  getVal() == return ivVal;

  public setVal: seq of char ==> ()
  setVal(parg) == ivVal := parg;

end OmlQuoteLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlQuoteType is subclass of IOmlQuoteType
operations
  public identity: () ==> seq of char
  identity () == return "QuoteType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitQuoteType(self);

  public OmlQuoteType:
    (IOmlQuoteLiteral) ==> OmlQuoteType
  OmlQuoteType (p1) == 
    ( setQuoteLiteral(p1) );

  public OmlQuoteType:
    (IOmlQuoteLiteral) *
    nat *
    nat ==> OmlQuoteType
  OmlQuoteType (p1,line,column) == 
    ( setQuoteLiteral(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "quote_literal" in
        if fname in set dom data
        then setQuoteLiteral(data(fname)) );

instance variables
  private ivQuoteLiteral : [IOmlQuoteLiteral] := nil

operations
  public getQuoteLiteral: () ==> IOmlQuoteLiteral
  getQuoteLiteral() == return ivQuoteLiteral;

  public setQuoteLiteral: IOmlQuoteLiteral ==> ()
  setQuoteLiteral(parg) == ivQuoteLiteral := parg;

end OmlQuoteType
\end{vdm_al}

\begin{vdm_al}
class OmlRatType is subclass of IOmlRatType
operations
  public identity: () ==> seq of char
  identity () == return "RatType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRatType(self);

  public OmlRatType:
    () ==> OmlRatType
  OmlRatType () == 
    skip;

  public OmlRatType:
    nat *
    nat ==> OmlRatType
  OmlRatType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlRatType
\end{vdm_al}

\begin{vdm_al}
class OmlRealLiteral is subclass of IOmlRealLiteral
operations
  public identity: () ==> seq of char
  identity () == return "RealLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRealLiteral(self);

  public OmlRealLiteral:
    (real) ==> OmlRealLiteral
  OmlRealLiteral (p1) == 
    ( setVal(p1) );

  public OmlRealLiteral:
    (real) *
    nat *
    nat ==> OmlRealLiteral
  OmlRealLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : [real] := nil

operations
  public getVal: () ==> real
  getVal() == return ivVal;

  public setVal: real ==> ()
  setVal(parg) == ivVal := parg;

end OmlRealLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlRealType is subclass of IOmlRealType
operations
  public identity: () ==> seq of char
  identity () == return "RealType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRealType(self);

  public OmlRealType:
    () ==> OmlRealType
  OmlRealType () == 
    skip;

  public OmlRealType:
    nat *
    nat ==> OmlRealType
  OmlRealType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlRealType
\end{vdm_al}

\begin{vdm_al}
class OmlRecordConstructor is subclass of IOmlRecordConstructor
operations
  public identity: () ==> seq of char
  identity () == return "RecordConstructor";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecordConstructor(self);

  public OmlRecordConstructor:
    (IOmlName) *
    (seq of IOmlExpression) ==> OmlRecordConstructor
  OmlRecordConstructor (p1,p2) == 
    ( setName(p1);
      setExpressionList(p2) );

  public OmlRecordConstructor:
    (IOmlName) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlRecordConstructor
  OmlRecordConstructor (p1,p2,line,column) == 
    ( setName(p1);
      setExpressionList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlRecordConstructor
\end{vdm_al}

\begin{vdm_al}
class OmlRecordModifier is subclass of IOmlRecordModifier
operations
  public identity: () ==> seq of char
  identity () == return "RecordModifier";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecordModifier(self);

  public OmlRecordModifier:
    (seq of char) *
    (IOmlExpression) ==> OmlRecordModifier
  OmlRecordModifier (p1,p2) == 
    ( setIdentifier(p1);
      setExpression(p2) );

  public OmlRecordModifier:
    (seq of char) *
    (IOmlExpression) *
    nat *
    nat ==> OmlRecordModifier
  OmlRecordModifier (p1,p2,line,column) == 
    ( setIdentifier(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlRecordModifier
\end{vdm_al}

\begin{vdm_al}
class OmlRecordPattern is subclass of IOmlRecordPattern
operations
  public identity: () ==> seq of char
  identity () == return "RecordPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecordPattern(self);

  public OmlRecordPattern:
    (IOmlName) *
    (seq of IOmlPattern) ==> OmlRecordPattern
  OmlRecordPattern (p1,p2) == 
    ( setName(p1);
      setPatternList(p2) );

  public OmlRecordPattern:
    (IOmlName) *
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlRecordPattern
  OmlRecordPattern (p1,p2,line,column) == 
    ( setName(p1);
      setPatternList(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname));
      let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlRecordPattern
\end{vdm_al}

\begin{vdm_al}
class OmlRecursiveTrapStatement is subclass of IOmlRecursiveTrapStatement
operations
  public identity: () ==> seq of char
  identity () == return "RecursiveTrapStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitRecursiveTrapStatement(self);

  public OmlRecursiveTrapStatement:
    (seq of IOmlTrapDefinition) *
    (IOmlStatement) ==> OmlRecursiveTrapStatement
  OmlRecursiveTrapStatement (p1,p2) == 
    ( setTrapList(p1);
      setInPart(p2) );

  public OmlRecursiveTrapStatement:
    (seq of IOmlTrapDefinition) *
    (IOmlStatement) *
    nat *
    nat ==> OmlRecursiveTrapStatement
  OmlRecursiveTrapStatement (p1,p2,line,column) == 
    ( setTrapList(p1);
      setInPart(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "trap_list" in
        if fname in set dom data
        then setTrapList(data(fname));
      let fname = "in_part" in
        if fname in set dom data
        then setInPart(data(fname)) );

instance variables
  private ivTrapList : seq of IOmlTrapDefinition := []

operations
  public getTrapList: () ==> seq of IOmlTrapDefinition
  getTrapList() == return ivTrapList;

  public setTrapList: seq of IOmlTrapDefinition ==> ()
  setTrapList(parg) == ivTrapList := parg;

  public addTrapList: IOmlNode ==> ()
  addTrapList (parg) == ivTrapList := ivTrapList ^ [parg];

instance variables
  private ivInPart : [IOmlStatement] := nil

operations
  public getInPart: () ==> IOmlStatement
  getInPart() == return ivInPart;

  public setInPart: IOmlStatement ==> ()
  setInPart(parg) == ivInPart := parg;

end OmlRecursiveTrapStatement
\end{vdm_al}

\begin{vdm_al}
class OmlReqExpression is subclass of IOmlReqExpression
operations
  public identity: () ==> seq of char
  identity () == return "ReqExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitReqExpression(self);

  public OmlReqExpression:
    (seq of IOmlName) ==> OmlReqExpression
  OmlReqExpression (p1) == 
    ( setNameList(p1) );

  public OmlReqExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlReqExpression
  OmlReqExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlReqExpression
\end{vdm_al}

\begin{vdm_al}
class OmlReturnStatement is subclass of IOmlReturnStatement
operations
  public identity: () ==> seq of char
  identity () == return "ReturnStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitReturnStatement(self);

  public OmlReturnStatement:
    [IOmlExpression] ==> OmlReturnStatement
  OmlReturnStatement (p1) == 
    ( setExpression(p1) );

  public OmlReturnStatement:
    [IOmlExpression] *
    nat *
    nat ==> OmlReturnStatement
  OmlReturnStatement (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression
    pre hasExpression();

  public hasExpression: () ==> bool
  hasExpression () == return ivExpression <> nil;

  public setExpression: [ IOmlExpression ] ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlReturnStatement
\end{vdm_al}

\begin{vdm_al}
class OmlSamebaseclassExpression is subclass of IOmlSamebaseclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "SamebaseclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSamebaseclassExpression(self);

  public OmlSamebaseclassExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSamebaseclassExpression
  OmlSamebaseclassExpression (p1,p2) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2) );

  public OmlSamebaseclassExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSamebaseclassExpression
  OmlSamebaseclassExpression (p1,p2,line,column) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_expression" in
        if fname in set dom data
        then setLhsExpression(data(fname));
      let fname = "rhs_expression" in
        if fname in set dom data
        then setRhsExpression(data(fname)) );

instance variables
  private ivLhsExpression : [IOmlExpression] := nil

operations
  public getLhsExpression: () ==> IOmlExpression
  getLhsExpression() == return ivLhsExpression;

  public setLhsExpression: IOmlExpression ==> ()
  setLhsExpression(parg) == ivLhsExpression := parg;

instance variables
  private ivRhsExpression : [IOmlExpression] := nil

operations
  public getRhsExpression: () ==> IOmlExpression
  getRhsExpression() == return ivRhsExpression;

  public setRhsExpression: IOmlExpression ==> ()
  setRhsExpression(parg) == ivRhsExpression := parg;

end OmlSamebaseclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSameclassExpression is subclass of IOmlSameclassExpression
operations
  public identity: () ==> seq of char
  identity () == return "SameclassExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSameclassExpression(self);

  public OmlSameclassExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSameclassExpression
  OmlSameclassExpression (p1,p2) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2) );

  public OmlSameclassExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSameclassExpression
  OmlSameclassExpression (p1,p2,line,column) == 
    ( setLhsExpression(p1);
      setRhsExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_expression" in
        if fname in set dom data
        then setLhsExpression(data(fname));
      let fname = "rhs_expression" in
        if fname in set dom data
        then setRhsExpression(data(fname)) );

instance variables
  private ivLhsExpression : [IOmlExpression] := nil

operations
  public getLhsExpression: () ==> IOmlExpression
  getLhsExpression() == return ivLhsExpression;

  public setLhsExpression: IOmlExpression ==> ()
  setLhsExpression(parg) == ivLhsExpression := parg;

instance variables
  private ivRhsExpression : [IOmlExpression] := nil

operations
  public getRhsExpression: () ==> IOmlExpression
  getRhsExpression() == return ivRhsExpression;

  public setRhsExpression: IOmlExpression ==> ()
  setRhsExpression(parg) == ivRhsExpression := parg;

end OmlSameclassExpression
\end{vdm_al}

\begin{vdm_al}
class OmlScope is subclass of IOmlScope
operations
  public identity: () ==> seq of char
  identity () == return "Scope";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitScope(self);

  public OmlScope: nat ==> OmlScope
  OmlScope (pv) == setValue(pv);

  public OmlScope: nat * nat * nat ==> OmlScope
  OmlScope (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlScopeQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlScopeQuotes`getQuoteName(val)
    pre val <> nil;

end OmlScope
\end{vdm_al}
\begin{vdm_al}
class OmlScopeQuotes
instance variables
  static public IQPROTECTED : nat := 0;
  static public IQPRIVATE : nat := 1;
  static public IQPUBLIC : nat := 2;
  static public IQDEFAULT : nat := 3;

  static private qmap : map nat to seq of char :=
    { IQPROTECTED |-> "<PROTECTED>",
      IQPRIVATE |-> "<PRIVATE>",
      IQPUBLIC |-> "<PUBLIC>",
      IQDEFAULT |-> "<DEFAULT>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlScopeQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlSelfExpression is subclass of IOmlSelfExpression
operations
  public identity: () ==> seq of char
  identity () == return "SelfExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSelfExpression(self);

  public OmlSelfExpression:
    () ==> OmlSelfExpression
  OmlSelfExpression () == 
    skip;

  public OmlSelfExpression:
    nat *
    nat ==> OmlSelfExpression
  OmlSelfExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlSelfExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSeq0Type is subclass of IOmlSeq0Type
operations
  public identity: () ==> seq of char
  identity () == return "Seq0Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeq0Type(self);

  public OmlSeq0Type:
    (IOmlType) ==> OmlSeq0Type
  OmlSeq0Type (p1) == 
    ( setType(p1) );

  public OmlSeq0Type:
    (IOmlType) *
    nat *
    nat ==> OmlSeq0Type
  OmlSeq0Type (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlSeq0Type
\end{vdm_al}

\begin{vdm_al}
class OmlSeq1Type is subclass of IOmlSeq1Type
operations
  public identity: () ==> seq of char
  identity () == return "Seq1Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeq1Type(self);

  public OmlSeq1Type:
    (IOmlType) ==> OmlSeq1Type
  OmlSeq1Type (p1) == 
    ( setType(p1) );

  public OmlSeq1Type:
    (IOmlType) *
    nat *
    nat ==> OmlSeq1Type
  OmlSeq1Type (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlSeq1Type
\end{vdm_al}

\begin{vdm_al}
class OmlSeqConcPattern is subclass of IOmlSeqConcPattern
operations
  public identity: () ==> seq of char
  identity () == return "SeqConcPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeqConcPattern(self);

  public OmlSeqConcPattern:
    (IOmlPattern) *
    (IOmlPattern) ==> OmlSeqConcPattern
  OmlSeqConcPattern (p1,p2) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2) );

  public OmlSeqConcPattern:
    (IOmlPattern) *
    (IOmlPattern) *
    nat *
    nat ==> OmlSeqConcPattern
  OmlSeqConcPattern (p1,p2,line,column) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_pattern" in
        if fname in set dom data
        then setLhsPattern(data(fname));
      let fname = "rhs_pattern" in
        if fname in set dom data
        then setRhsPattern(data(fname)) );

instance variables
  private ivLhsPattern : [IOmlPattern] := nil

operations
  public getLhsPattern: () ==> IOmlPattern
  getLhsPattern() == return ivLhsPattern;

  public setLhsPattern: IOmlPattern ==> ()
  setLhsPattern(parg) == ivLhsPattern := parg;

instance variables
  private ivRhsPattern : [IOmlPattern] := nil

operations
  public getRhsPattern: () ==> IOmlPattern
  getRhsPattern() == return ivRhsPattern;

  public setRhsPattern: IOmlPattern ==> ()
  setRhsPattern(parg) == ivRhsPattern := parg;

end OmlSeqConcPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSeqEnumPattern is subclass of IOmlSeqEnumPattern
operations
  public identity: () ==> seq of char
  identity () == return "SeqEnumPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSeqEnumPattern(self);

  public OmlSeqEnumPattern:
    (seq of IOmlPattern) ==> OmlSeqEnumPattern
  OmlSeqEnumPattern (p1) == 
    ( setPatternList(p1) );

  public OmlSeqEnumPattern:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlSeqEnumPattern
  OmlSeqEnumPattern (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlSeqEnumPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSequenceComprehension is subclass of IOmlSequenceComprehension
operations
  public identity: () ==> seq of char
  identity () == return "SequenceComprehension";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSequenceComprehension(self);

  public OmlSequenceComprehension:
    (IOmlExpression) *
    (IOmlSetBind) *
    [IOmlExpression] ==> OmlSequenceComprehension
  OmlSequenceComprehension (p1,p2,p3) == 
    ( setExpression(p1);
      setSetBind(p2);
      setGuard(p3) );

  public OmlSequenceComprehension:
    (IOmlExpression) *
    (IOmlSetBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlSequenceComprehension
  OmlSequenceComprehension (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setSetBind(p2);
      setGuard(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "set_bind" in
        if fname in set dom data
        then setSetBind(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivSetBind : [IOmlSetBind] := nil

operations
  public getSetBind: () ==> IOmlSetBind
  getSetBind() == return ivSetBind;

  public setSetBind: IOmlSetBind ==> ()
  setSetBind(parg) == ivSetBind := parg;

instance variables
  private ivGuard : [IOmlExpression] := nil

operations
  public getGuard: () ==> IOmlExpression
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IOmlExpression ] ==> ()
  setGuard(parg) == ivGuard := parg;

end OmlSequenceComprehension
\end{vdm_al}

\begin{vdm_al}
class OmlSequenceEnumeration is subclass of IOmlSequenceEnumeration
operations
  public identity: () ==> seq of char
  identity () == return "SequenceEnumeration";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSequenceEnumeration(self);

  public OmlSequenceEnumeration:
    (seq of IOmlExpression) ==> OmlSequenceEnumeration
  OmlSequenceEnumeration (p1) == 
    ( setExpressionList(p1) );

  public OmlSequenceEnumeration:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlSequenceEnumeration
  OmlSequenceEnumeration (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlSequenceEnumeration
\end{vdm_al}

\begin{vdm_al}
class OmlSequenceForLoop is subclass of IOmlSequenceForLoop
operations
  public identity: () ==> seq of char
  identity () == return "SequenceForLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSequenceForLoop(self);

  public OmlSequenceForLoop:
    (IOmlPatternBind) *
    (bool) *
    (IOmlExpression) *
    (IOmlStatement) ==> OmlSequenceForLoop
  OmlSequenceForLoop (p1,p2,p3,p4) == 
    ( setPatternBind(p1);
      setInReverse(p2);
      setExpression(p3);
      setStatement(p4) );

  public OmlSequenceForLoop:
    (IOmlPatternBind) *
    (bool) *
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlSequenceForLoop
  OmlSequenceForLoop (p1,p2,p3,p4,line,column) == 
    ( setPatternBind(p1);
      setInReverse(p2);
      setExpression(p3);
      setStatement(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "in_reverse" in
        if fname in set dom data
        then setInReverse(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivInReverse : [bool] := nil

operations
  public getInReverse: () ==> bool
  getInReverse() == return ivInReverse;

  public setInReverse: bool ==> ()
  setInReverse(parg) == ivInReverse := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlSequenceForLoop
\end{vdm_al}

\begin{vdm_al}
class OmlSetBind is subclass of IOmlSetBind
operations
  public identity: () ==> seq of char
  identity () == return "SetBind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetBind(self);

  public OmlSetBind:
    (seq of IOmlPattern) *
    (IOmlExpression) ==> OmlSetBind
  OmlSetBind (p1,p2) == 
    ( setPattern(p1);
      setExpression(p2) );

  public OmlSetBind:
    (seq of IOmlPattern) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSetBind
  OmlSetBind (p1,p2,line,column) == 
    ( setPattern(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPattern : seq of IOmlPattern := []

operations
  public getPattern: () ==> seq of IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: seq of IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

  public addPattern: IOmlNode ==> ()
  addPattern (parg) == ivPattern := ivPattern ^ [parg];

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlSetBind
\end{vdm_al}

\begin{vdm_al}
class OmlSetComprehension is subclass of IOmlSetComprehension
operations
  public identity: () ==> seq of char
  identity () == return "SetComprehension";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetComprehension(self);

  public OmlSetComprehension:
    (IOmlExpression) *
    (seq of IOmlBind) *
    [IOmlExpression] ==> OmlSetComprehension
  OmlSetComprehension (p1,p2,p3) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3) );

  public OmlSetComprehension:
    (IOmlExpression) *
    (seq of IOmlBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlSetComprehension
  OmlSetComprehension (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setBindList(p2);
      setGuard(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "bind_list" in
        if fname in set dom data
        then setBindList(data(fname));
      let fname = "guard" in
        if fname in set dom data
        then setGuard(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivBindList : seq of IOmlBind := []

operations
  public getBindList: () ==> seq of IOmlBind
  getBindList() == return ivBindList;

  public setBindList: seq of IOmlBind ==> ()
  setBindList(parg) == ivBindList := parg;

  public addBindList: IOmlNode ==> ()
  addBindList (parg) == ivBindList := ivBindList ^ [parg];

instance variables
  private ivGuard : [IOmlExpression] := nil

operations
  public getGuard: () ==> IOmlExpression
  getGuard() == return ivGuard
    pre hasGuard();

  public hasGuard: () ==> bool
  hasGuard () == return ivGuard <> nil;

  public setGuard: [ IOmlExpression ] ==> ()
  setGuard(parg) == ivGuard := parg;

end OmlSetComprehension
\end{vdm_al}

\begin{vdm_al}
class OmlSetEnumPattern is subclass of IOmlSetEnumPattern
operations
  public identity: () ==> seq of char
  identity () == return "SetEnumPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetEnumPattern(self);

  public OmlSetEnumPattern:
    (seq of IOmlPattern) ==> OmlSetEnumPattern
  OmlSetEnumPattern (p1) == 
    ( setPatternList(p1) );

  public OmlSetEnumPattern:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlSetEnumPattern
  OmlSetEnumPattern (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlSetEnumPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSetEnumeration is subclass of IOmlSetEnumeration
operations
  public identity: () ==> seq of char
  identity () == return "SetEnumeration";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetEnumeration(self);

  public OmlSetEnumeration:
    (seq of IOmlExpression) ==> OmlSetEnumeration
  OmlSetEnumeration (p1) == 
    ( setExpressionList(p1) );

  public OmlSetEnumeration:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlSetEnumeration
  OmlSetEnumeration (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlSetEnumeration
\end{vdm_al}

\begin{vdm_al}
class OmlSetForLoop is subclass of IOmlSetForLoop
operations
  public identity: () ==> seq of char
  identity () == return "SetForLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetForLoop(self);

  public OmlSetForLoop:
    (IOmlPattern) *
    (IOmlExpression) *
    (IOmlStatement) ==> OmlSetForLoop
  OmlSetForLoop (p1,p2,p3) == 
    ( setPattern(p1);
      setExpression(p2);
      setStatement(p3) );

  public OmlSetForLoop:
    (IOmlPattern) *
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlSetForLoop
  OmlSetForLoop (p1,p2,p3,line,column) == 
    ( setPattern(p1);
      setExpression(p2);
      setStatement(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPattern : [IOmlPattern] := nil

operations
  public getPattern: () ==> IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlSetForLoop
\end{vdm_al}

\begin{vdm_al}
class OmlSetRangeExpression is subclass of IOmlSetRangeExpression
operations
  public identity: () ==> seq of char
  identity () == return "SetRangeExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetRangeExpression(self);

  public OmlSetRangeExpression:
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSetRangeExpression
  OmlSetRangeExpression (p1,p2) == 
    ( setLower(p1);
      setUpper(p2) );

  public OmlSetRangeExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSetRangeExpression
  OmlSetRangeExpression (p1,p2,line,column) == 
    ( setLower(p1);
      setUpper(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivLower : [IOmlExpression] := nil

operations
  public getLower: () ==> IOmlExpression
  getLower() == return ivLower;

  public setLower: IOmlExpression ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [IOmlExpression] := nil

operations
  public getUpper: () ==> IOmlExpression
  getUpper() == return ivUpper;

  public setUpper: IOmlExpression ==> ()
  setUpper(parg) == ivUpper := parg;

end OmlSetRangeExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSetType is subclass of IOmlSetType
operations
  public identity: () ==> seq of char
  identity () == return "SetType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetType(self);

  public OmlSetType:
    (IOmlType) ==> OmlSetType
  OmlSetType (p1) == 
    ( setType(p1) );

  public OmlSetType:
    (IOmlType) *
    nat *
    nat ==> OmlSetType
  OmlSetType (p1,line,column) == 
    ( setType(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlSetType
\end{vdm_al}

\begin{vdm_al}
class OmlSetUnionPattern is subclass of IOmlSetUnionPattern
operations
  public identity: () ==> seq of char
  identity () == return "SetUnionPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSetUnionPattern(self);

  public OmlSetUnionPattern:
    (IOmlPattern) *
    (IOmlPattern) ==> OmlSetUnionPattern
  OmlSetUnionPattern (p1,p2) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2) );

  public OmlSetUnionPattern:
    (IOmlPattern) *
    (IOmlPattern) *
    nat *
    nat ==> OmlSetUnionPattern
  OmlSetUnionPattern (p1,p2,line,column) == 
    ( setLhsPattern(p1);
      setRhsPattern(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_pattern" in
        if fname in set dom data
        then setLhsPattern(data(fname));
      let fname = "rhs_pattern" in
        if fname in set dom data
        then setRhsPattern(data(fname)) );

instance variables
  private ivLhsPattern : [IOmlPattern] := nil

operations
  public getLhsPattern: () ==> IOmlPattern
  getLhsPattern() == return ivLhsPattern;

  public setLhsPattern: IOmlPattern ==> ()
  setLhsPattern(parg) == ivLhsPattern := parg;

instance variables
  private ivRhsPattern : [IOmlPattern] := nil

operations
  public getRhsPattern: () ==> IOmlPattern
  getRhsPattern() == return ivRhsPattern;

  public setRhsPattern: IOmlPattern ==> ()
  setRhsPattern(parg) == ivRhsPattern := parg;

end OmlSetUnionPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSimpleType is subclass of IOmlSimpleType
operations
  public identity: () ==> seq of char
  identity () == return "SimpleType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSimpleType(self);

  public OmlSimpleType:
    (seq of char) *
    (IOmlType) *
    [IOmlInvariant] ==> OmlSimpleType
  OmlSimpleType (p1,p2,p3) == 
    ( setIdentifier(p1);
      setType(p2);
      setInvariant(p3) );

  public OmlSimpleType:
    (seq of char) *
    (IOmlType) *
    [IOmlInvariant] *
    nat *
    nat ==> OmlSimpleType
  OmlSimpleType (p1,p2,p3,line,column) == 
    ( setIdentifier(p1);
      setType(p2);
      setInvariant(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "invariant" in
        if fname in set dom data
        then setInvariant(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivInvariant : [IOmlInvariant] := nil

operations
  public getInvariant: () ==> IOmlInvariant
  getInvariant() == return ivInvariant
    pre hasInvariant();

  public hasInvariant: () ==> bool
  hasInvariant () == return ivInvariant <> nil;

  public setInvariant: [ IOmlInvariant ] ==> ()
  setInvariant(parg) == ivInvariant := parg;

end OmlSimpleType
\end{vdm_al}

\begin{vdm_al}
class OmlSkipStatement is subclass of IOmlSkipStatement
operations
  public identity: () ==> seq of char
  identity () == return "SkipStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSkipStatement(self);

  public OmlSkipStatement:
    () ==> OmlSkipStatement
  OmlSkipStatement () == 
    skip;

  public OmlSkipStatement:
    nat *
    nat ==> OmlSkipStatement
  OmlSkipStatement (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlSkipStatement
\end{vdm_al}

\begin{vdm_al}
class OmlSpecificationStatement is subclass of IOmlSpecificationStatement
operations
  public identity: () ==> seq of char
  identity () == return "SpecificationStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSpecificationStatement(self);

  public OmlSpecificationStatement:
    [IOmlExternals] *
    [IOmlExpression] *
    (IOmlExpression) *
    [IOmlExceptions] ==> OmlSpecificationStatement
  OmlSpecificationStatement (p1,p2,p3,p4) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4) );

  public OmlSpecificationStatement:
    [IOmlExternals] *
    [IOmlExpression] *
    (IOmlExpression) *
    [IOmlExceptions] *
    nat *
    nat ==> OmlSpecificationStatement
  OmlSpecificationStatement (p1,p2,p3,p4,line,column) == 
    ( setExternals(p1);
      setPreExpression(p2);
      setPostExpression(p3);
      setExceptions(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "externals" in
        if fname in set dom data
        then setExternals(data(fname));
      let fname = "pre_expression" in
        if fname in set dom data
        then setPreExpression(data(fname));
      let fname = "post_expression" in
        if fname in set dom data
        then setPostExpression(data(fname));
      let fname = "exceptions" in
        if fname in set dom data
        then setExceptions(data(fname)) );

instance variables
  private ivExternals : [IOmlExternals] := nil

operations
  public getExternals: () ==> IOmlExternals
  getExternals() == return ivExternals
    pre hasExternals();

  public hasExternals: () ==> bool
  hasExternals () == return ivExternals <> nil;

  public setExternals: [ IOmlExternals ] ==> ()
  setExternals(parg) == ivExternals := parg;

instance variables
  private ivPreExpression : [IOmlExpression] := nil

operations
  public getPreExpression: () ==> IOmlExpression
  getPreExpression() == return ivPreExpression
    pre hasPreExpression();

  public hasPreExpression: () ==> bool
  hasPreExpression () == return ivPreExpression <> nil;

  public setPreExpression: [ IOmlExpression ] ==> ()
  setPreExpression(parg) == ivPreExpression := parg;

instance variables
  private ivPostExpression : [IOmlExpression] := nil

operations
  public getPostExpression: () ==> IOmlExpression
  getPostExpression() == return ivPostExpression;

  public setPostExpression: IOmlExpression ==> ()
  setPostExpression(parg) == ivPostExpression := parg;

instance variables
  private ivExceptions : [IOmlExceptions] := nil

operations
  public getExceptions: () ==> IOmlExceptions
  getExceptions() == return ivExceptions
    pre hasExceptions();

  public hasExceptions: () ==> bool
  hasExceptions () == return ivExceptions <> nil;

  public setExceptions: [ IOmlExceptions ] ==> ()
  setExceptions(parg) == ivExceptions := parg;

end OmlSpecificationStatement
\end{vdm_al}

\begin{vdm_al}
class OmlSpecifications is subclass of IOmlSpecifications
operations
  public identity: () ==> seq of char
  identity () == return "Specifications";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSpecifications(self);

  public OmlSpecifications:
    (seq of IOmlClass) ==> OmlSpecifications
  OmlSpecifications (p1) == 
    ( setClassList(p1) );

  public OmlSpecifications:
    (seq of IOmlClass) *
    nat *
    nat ==> OmlSpecifications
  OmlSpecifications (p1,line,column) == 
    ( setClassList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "class_list" in
        if fname in set dom data
        then setClassList(data(fname)) );

instance variables
  private ivClassList : seq of IOmlClass := []

operations
  public getClassList: () ==> seq of IOmlClass
  getClassList() == return ivClassList;

  public setClassList: seq of IOmlClass ==> ()
  setClassList(parg) == ivClassList := parg;

  public addClassList: IOmlNode ==> ()
  addClassList (parg) == ivClassList := ivClassList ^ [parg];

end OmlSpecifications
\end{vdm_al}

\begin{vdm_al}
class OmlSporadicThread is subclass of IOmlSporadicThread
operations
  public identity: () ==> seq of char
  identity () == return "SporadicThread";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSporadicThread(self);

  public OmlSporadicThread:
    (seq of IOmlExpression) *
    (IOmlName) ==> OmlSporadicThread
  OmlSporadicThread (p1,p2) == 
    ( setArgs(p1);
      setName(p2) );

  public OmlSporadicThread:
    (seq of IOmlExpression) *
    (IOmlName) *
    nat *
    nat ==> OmlSporadicThread
  OmlSporadicThread (p1,p2,line,column) == 
    ( setArgs(p1);
      setName(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "args" in
        if fname in set dom data
        then setArgs(data(fname));
      let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivArgs : seq of IOmlExpression := []

operations
  public getArgs: () ==> seq of IOmlExpression
  getArgs() == return ivArgs;

  public setArgs: seq of IOmlExpression ==> ()
  setArgs(parg) == ivArgs := parg;

  public addArgs: IOmlNode ==> ()
  addArgs (parg) == ivArgs := ivArgs ^ [parg];

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlSporadicThread
\end{vdm_al}

\begin{vdm_al}
class OmlStartStatement is subclass of IOmlStartStatement
operations
  public identity: () ==> seq of char
  identity () == return "StartStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStartStatement(self);

  public OmlStartStatement:
    (IOmlExpression) ==> OmlStartStatement
  OmlStartStatement (p1) == 
    ( setExpression(p1) );

  public OmlStartStatement:
    (IOmlExpression) *
    nat *
    nat ==> OmlStartStatement
  OmlStartStatement (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlStartStatement
\end{vdm_al}

\begin{vdm_al}
class OmlStateDesignator is subclass of IOmlStateDesignator
operations
  public identity: () ==> seq of char
  identity () == return "StateDesignator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStateDesignator(self);

end OmlStateDesignator
\end{vdm_al}
\begin{vdm_al}
class OmlStateDesignatorName is subclass of IOmlStateDesignatorName
operations
  public identity: () ==> seq of char
  identity () == return "StateDesignatorName";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStateDesignatorName(self);

  public OmlStateDesignatorName:
    (IOmlName) ==> OmlStateDesignatorName
  OmlStateDesignatorName (p1) == 
    ( setName(p1) );

  public OmlStateDesignatorName:
    (IOmlName) *
    nat *
    nat ==> OmlStateDesignatorName
  OmlStateDesignatorName (p1,line,column) == 
    ( setName(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlStateDesignatorName
\end{vdm_al}

\begin{vdm_al}
class OmlStatement is subclass of IOmlStatement
operations
  public identity: () ==> seq of char
  identity () == return "Statement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitStatement(self);

end OmlStatement
\end{vdm_al}
\begin{vdm_al}
class OmlSubsequenceExpression is subclass of IOmlSubsequenceExpression
operations
  public identity: () ==> seq of char
  identity () == return "SubsequenceExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSubsequenceExpression(self);

  public OmlSubsequenceExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (IOmlExpression) ==> OmlSubsequenceExpression
  OmlSubsequenceExpression (p1,p2,p3) == 
    ( setExpression(p1);
      setLower(p2);
      setUpper(p3) );

  public OmlSubsequenceExpression:
    (IOmlExpression) *
    (IOmlExpression) *
    (IOmlExpression) *
    nat *
    nat ==> OmlSubsequenceExpression
  OmlSubsequenceExpression (p1,p2,p3,line,column) == 
    ( setExpression(p1);
      setLower(p2);
      setUpper(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivLower : [IOmlExpression] := nil

operations
  public getLower: () ==> IOmlExpression
  getLower() == return ivLower;

  public setLower: IOmlExpression ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [IOmlExpression] := nil

operations
  public getUpper: () ==> IOmlExpression
  getUpper() == return ivUpper;

  public setUpper: IOmlExpression ==> ()
  setUpper(parg) == ivUpper := parg;

end OmlSubsequenceExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSymbolicLiteralExpression is subclass of IOmlSymbolicLiteralExpression
operations
  public identity: () ==> seq of char
  identity () == return "SymbolicLiteralExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSymbolicLiteralExpression(self);

  public OmlSymbolicLiteralExpression:
    (IOmlLiteral) ==> OmlSymbolicLiteralExpression
  OmlSymbolicLiteralExpression (p1) == 
    ( setLiteral(p1) );

  public OmlSymbolicLiteralExpression:
    (IOmlLiteral) *
    nat *
    nat ==> OmlSymbolicLiteralExpression
  OmlSymbolicLiteralExpression (p1,line,column) == 
    ( setLiteral(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "literal" in
        if fname in set dom data
        then setLiteral(data(fname)) );

instance variables
  private ivLiteral : [IOmlLiteral] := nil

operations
  public getLiteral: () ==> IOmlLiteral
  getLiteral() == return ivLiteral;

  public setLiteral: IOmlLiteral ==> ()
  setLiteral(parg) == ivLiteral := parg;

end OmlSymbolicLiteralExpression
\end{vdm_al}

\begin{vdm_al}
class OmlSymbolicLiteralPattern is subclass of IOmlSymbolicLiteralPattern
operations
  public identity: () ==> seq of char
  identity () == return "SymbolicLiteralPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSymbolicLiteralPattern(self);

  public OmlSymbolicLiteralPattern:
    (IOmlLiteral) ==> OmlSymbolicLiteralPattern
  OmlSymbolicLiteralPattern (p1) == 
    ( setLiteral(p1) );

  public OmlSymbolicLiteralPattern:
    (IOmlLiteral) *
    nat *
    nat ==> OmlSymbolicLiteralPattern
  OmlSymbolicLiteralPattern (p1,line,column) == 
    ( setLiteral(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "literal" in
        if fname in set dom data
        then setLiteral(data(fname)) );

instance variables
  private ivLiteral : [IOmlLiteral] := nil

operations
  public getLiteral: () ==> IOmlLiteral
  getLiteral() == return ivLiteral;

  public setLiteral: IOmlLiteral ==> ()
  setLiteral(parg) == ivLiteral := parg;

end OmlSymbolicLiteralPattern
\end{vdm_al}

\begin{vdm_al}
class OmlSyncPredicate is subclass of IOmlSyncPredicate
operations
  public identity: () ==> seq of char
  identity () == return "SyncPredicate";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSyncPredicate(self);

end OmlSyncPredicate
\end{vdm_al}
\begin{vdm_al}
class OmlSynchronizationDefinitions is subclass of IOmlSynchronizationDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "SynchronizationDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitSynchronizationDefinitions(self);

  public OmlSynchronizationDefinitions:
    (seq of IOmlSyncPredicate) ==> OmlSynchronizationDefinitions
  OmlSynchronizationDefinitions (p1) == 
    ( setSyncList(p1) );

  public OmlSynchronizationDefinitions:
    (seq of IOmlSyncPredicate) *
    nat *
    nat ==> OmlSynchronizationDefinitions
  OmlSynchronizationDefinitions (p1,line,column) == 
    ( setSyncList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "sync_list" in
        if fname in set dom data
        then setSyncList(data(fname)) );

instance variables
  private ivSyncList : seq of IOmlSyncPredicate := []

operations
  public getSyncList: () ==> seq of IOmlSyncPredicate
  getSyncList() == return ivSyncList;

  public setSyncList: seq of IOmlSyncPredicate ==> ()
  setSyncList(parg) == ivSyncList := parg;

  public addSyncList: IOmlNode ==> ()
  addSyncList (parg) == ivSyncList := ivSyncList ^ [parg];

end OmlSynchronizationDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlTextLiteral is subclass of IOmlTextLiteral
operations
  public identity: () ==> seq of char
  identity () == return "TextLiteral";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTextLiteral(self);

  public OmlTextLiteral:
    (seq of char) ==> OmlTextLiteral
  OmlTextLiteral (p1) == 
    ( setVal(p1) );

  public OmlTextLiteral:
    (seq of char) *
    nat *
    nat ==> OmlTextLiteral
  OmlTextLiteral (p1,line,column) == 
    ( setVal(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "val" in
        if fname in set dom data
        then setVal(data(fname)) );

instance variables
  private ivVal : seq of char := []

operations
  public getVal: () ==> seq of char
  getVal() == return ivVal;

  public setVal: seq of char ==> ()
  setVal(parg) == ivVal := parg;

end OmlTextLiteral
\end{vdm_al}

\begin{vdm_al}
class OmlThreadDefinition is subclass of IOmlThreadDefinition
operations
  public identity: () ==> seq of char
  identity () == return "ThreadDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitThreadDefinition(self);

  public OmlThreadDefinition:
    [IOmlThreadSpecification] ==> OmlThreadDefinition
  OmlThreadDefinition (p1) == 
    ( setThreadSpecification(p1) );

  public OmlThreadDefinition:
    [IOmlThreadSpecification] *
    nat *
    nat ==> OmlThreadDefinition
  OmlThreadDefinition (p1,line,column) == 
    ( setThreadSpecification(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "thread_specification" in
        if fname in set dom data
        then setThreadSpecification(data(fname)) );

instance variables
  private ivThreadSpecification : [IOmlThreadSpecification] := nil

operations
  public getThreadSpecification: () ==> IOmlThreadSpecification
  getThreadSpecification() == return ivThreadSpecification
    pre hasThreadSpecification();

  public hasThreadSpecification: () ==> bool
  hasThreadSpecification () == return ivThreadSpecification <> nil;

  public setThreadSpecification: [ IOmlThreadSpecification ] ==> ()
  setThreadSpecification(parg) == ivThreadSpecification := parg;

end OmlThreadDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlThreadIdExpression is subclass of IOmlThreadIdExpression
operations
  public identity: () ==> seq of char
  identity () == return "ThreadIdExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitThreadIdExpression(self);

  public OmlThreadIdExpression:
    () ==> OmlThreadIdExpression
  OmlThreadIdExpression () == 
    skip;

  public OmlThreadIdExpression:
    nat *
    nat ==> OmlThreadIdExpression
  OmlThreadIdExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlThreadIdExpression
\end{vdm_al}

\begin{vdm_al}
class OmlThreadSpecification is subclass of IOmlThreadSpecification
operations
  public identity: () ==> seq of char
  identity () == return "ThreadSpecification";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitThreadSpecification(self);

end OmlThreadSpecification
\end{vdm_al}
\begin{vdm_al}
class OmlTimeExpression is subclass of IOmlTimeExpression
operations
  public identity: () ==> seq of char
  identity () == return "TimeExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTimeExpression(self);

  public OmlTimeExpression:
    () ==> OmlTimeExpression
  OmlTimeExpression () == 
    skip;

  public OmlTimeExpression:
    nat *
    nat ==> OmlTimeExpression
  OmlTimeExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTimeExpression
\end{vdm_al}

\begin{vdm_al}
class OmlTokenExpression is subclass of IOmlTokenExpression
operations
  public identity: () ==> seq of char
  identity () == return "TokenExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTokenExpression(self);

  public OmlTokenExpression:
    (IOmlExpression) ==> OmlTokenExpression
  OmlTokenExpression (p1) == 
    ( setExpression(p1) );

  public OmlTokenExpression:
    (IOmlExpression) *
    nat *
    nat ==> OmlTokenExpression
  OmlTokenExpression (p1,line,column) == 
    ( setExpression(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlTokenExpression
\end{vdm_al}

\begin{vdm_al}
class OmlTokenType is subclass of IOmlTokenType
operations
  public identity: () ==> seq of char
  identity () == return "TokenType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTokenType(self);

  public OmlTokenType:
    () ==> OmlTokenType
  OmlTokenType () == 
    skip;

  public OmlTokenType:
    nat *
    nat ==> OmlTokenType
  OmlTokenType (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTokenType
\end{vdm_al}

\begin{vdm_al}
class OmlTotalFunctionType is subclass of IOmlTotalFunctionType
operations
  public identity: () ==> seq of char
  identity () == return "TotalFunctionType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTotalFunctionType(self);

  public OmlTotalFunctionType:
    (IOmlType) *
    (IOmlType) ==> OmlTotalFunctionType
  OmlTotalFunctionType (p1,p2) == 
    ( setDomType(p1);
      setRngType(p2) );

  public OmlTotalFunctionType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlTotalFunctionType
  OmlTotalFunctionType (p1,p2,line,column) == 
    ( setDomType(p1);
      setRngType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "dom_type" in
        if fname in set dom data
        then setDomType(data(fname));
      let fname = "rng_type" in
        if fname in set dom data
        then setRngType(data(fname)) );

instance variables
  private ivDomType : [IOmlType] := nil

operations
  public getDomType: () ==> IOmlType
  getDomType() == return ivDomType;

  public setDomType: IOmlType ==> ()
  setDomType(parg) == ivDomType := parg;

instance variables
  private ivRngType : [IOmlType] := nil

operations
  public getRngType: () ==> IOmlType
  getRngType() == return ivRngType;

  public setRngType: IOmlType ==> ()
  setRngType(parg) == ivRngType := parg;

end OmlTotalFunctionType
\end{vdm_al}

\begin{vdm_al}
class OmlTraceBinding is subclass of IOmlTraceBinding
operations
  public identity: () ==> seq of char
  identity () == return "TraceBinding";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceBinding(self);

end OmlTraceBinding
\end{vdm_al}
\begin{vdm_al}
class OmlTraceBracketedDefinition is subclass of IOmlTraceBracketedDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceBracketedDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceBracketedDefinition(self);

  public OmlTraceBracketedDefinition:
    (IOmlTraceDefinition) ==> OmlTraceBracketedDefinition
  OmlTraceBracketedDefinition (p1) == 
    ( setDefinition(p1) );

  public OmlTraceBracketedDefinition:
    (IOmlTraceDefinition) *
    nat *
    nat ==> OmlTraceBracketedDefinition
  OmlTraceBracketedDefinition (p1,line,column) == 
    ( setDefinition(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition" in
        if fname in set dom data
        then setDefinition(data(fname)) );

instance variables
  private ivDefinition : [IOmlTraceDefinition] := nil

operations
  public getDefinition: () ==> IOmlTraceDefinition
  getDefinition() == return ivDefinition;

  public setDefinition: IOmlTraceDefinition ==> ()
  setDefinition(parg) == ivDefinition := parg;

end OmlTraceBracketedDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTraceChoiceDefinition is subclass of IOmlTraceChoiceDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceChoiceDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceChoiceDefinition(self);

  public OmlTraceChoiceDefinition:
    (seq of IOmlTraceDefinition) ==> OmlTraceChoiceDefinition
  OmlTraceChoiceDefinition (p1) == 
    ( setDefs(p1) );

  public OmlTraceChoiceDefinition:
    (seq of IOmlTraceDefinition) *
    nat *
    nat ==> OmlTraceChoiceDefinition
  OmlTraceChoiceDefinition (p1,line,column) == 
    ( setDefs(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "defs" in
        if fname in set dom data
        then setDefs(data(fname)) );

instance variables
  private ivDefs : seq of IOmlTraceDefinition := []

operations
  public getDefs: () ==> seq of IOmlTraceDefinition
  getDefs() == return ivDefs;

  public setDefs: seq of IOmlTraceDefinition ==> ()
  setDefs(parg) == ivDefs := parg;

  public addDefs: IOmlNode ==> ()
  addDefs (parg) == ivDefs := ivDefs ^ [parg];

end OmlTraceChoiceDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTraceCoreDefinition is subclass of IOmlTraceCoreDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceCoreDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceCoreDefinition(self);

end OmlTraceCoreDefinition
\end{vdm_al}
\begin{vdm_al}
class OmlTraceDefinition is subclass of IOmlTraceDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceDefinition(self);

end OmlTraceDefinition
\end{vdm_al}
\begin{vdm_al}
class OmlTraceDefinitionItem is subclass of IOmlTraceDefinitionItem
operations
  public identity: () ==> seq of char
  identity () == return "TraceDefinitionItem";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceDefinitionItem(self);

  public OmlTraceDefinitionItem:
    (seq of IOmlTraceBinding) *
    (IOmlTraceCoreDefinition) *
    [IOmlTraceRepeatPattern] ==> OmlTraceDefinitionItem
  OmlTraceDefinitionItem (p1,p2,p3) == 
    ( setBind(p1);
      setTest(p2);
      setRegexpr(p3) );

  public OmlTraceDefinitionItem:
    (seq of IOmlTraceBinding) *
    (IOmlTraceCoreDefinition) *
    [IOmlTraceRepeatPattern] *
    nat *
    nat ==> OmlTraceDefinitionItem
  OmlTraceDefinitionItem (p1,p2,p3,line,column) == 
    ( setBind(p1);
      setTest(p2);
      setRegexpr(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "test" in
        if fname in set dom data
        then setTest(data(fname));
      let fname = "regexpr" in
        if fname in set dom data
        then setRegexpr(data(fname)) );

instance variables
  private ivBind : seq of IOmlTraceBinding := []

operations
  public getBind: () ==> seq of IOmlTraceBinding
  getBind() == return ivBind;

  public setBind: seq of IOmlTraceBinding ==> ()
  setBind(parg) == ivBind := parg;

  public addBind: IOmlNode ==> ()
  addBind (parg) == ivBind := ivBind ^ [parg];

instance variables
  private ivTest : [IOmlTraceCoreDefinition] := nil

operations
  public getTest: () ==> IOmlTraceCoreDefinition
  getTest() == return ivTest;

  public setTest: IOmlTraceCoreDefinition ==> ()
  setTest(parg) == ivTest := parg;

instance variables
  private ivRegexpr : [IOmlTraceRepeatPattern] := nil

operations
  public getRegexpr: () ==> IOmlTraceRepeatPattern
  getRegexpr() == return ivRegexpr
    pre hasRegexpr();

  public hasRegexpr: () ==> bool
  hasRegexpr () == return ivRegexpr <> nil;

  public setRegexpr: [ IOmlTraceRepeatPattern ] ==> ()
  setRegexpr(parg) == ivRegexpr := parg;

end OmlTraceDefinitionItem
\end{vdm_al}

\begin{vdm_al}
class OmlTraceDefinitions is subclass of IOmlTraceDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "TraceDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceDefinitions(self);

  public OmlTraceDefinitions:
    (seq of IOmlNamedTrace) ==> OmlTraceDefinitions
  OmlTraceDefinitions (p1) == 
    ( setTraces(p1) );

  public OmlTraceDefinitions:
    (seq of IOmlNamedTrace) *
    nat *
    nat ==> OmlTraceDefinitions
  OmlTraceDefinitions (p1,line,column) == 
    ( setTraces(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "traces" in
        if fname in set dom data
        then setTraces(data(fname)) );

instance variables
  private ivTraces : seq of IOmlNamedTrace := []

operations
  public getTraces: () ==> seq of IOmlNamedTrace
  getTraces() == return ivTraces;

  public setTraces: seq of IOmlNamedTrace ==> ()
  setTraces(parg) == ivTraces := parg;

  public addTraces: IOmlNode ==> ()
  addTraces (parg) == ivTraces := ivTraces ^ [parg];

end OmlTraceDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlTraceLetBeBinding is subclass of IOmlTraceLetBeBinding
operations
  public identity: () ==> seq of char
  identity () == return "TraceLetBeBinding";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceLetBeBinding(self);

  public OmlTraceLetBeBinding:
    (IOmlBind) *
    [IOmlExpression] ==> OmlTraceLetBeBinding
  OmlTraceLetBeBinding (p1,p2) == 
    ( setBind(p1);
      setBest(p2) );

  public OmlTraceLetBeBinding:
    (IOmlBind) *
    [IOmlExpression] *
    nat *
    nat ==> OmlTraceLetBeBinding
  OmlTraceLetBeBinding (p1,p2,line,column) == 
    ( setBind(p1);
      setBest(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "bind" in
        if fname in set dom data
        then setBind(data(fname));
      let fname = "best" in
        if fname in set dom data
        then setBest(data(fname)) );

instance variables
  private ivBind : [IOmlBind] := nil

operations
  public getBind: () ==> IOmlBind
  getBind() == return ivBind;

  public setBind: IOmlBind ==> ()
  setBind(parg) == ivBind := parg;

instance variables
  private ivBest : [IOmlExpression] := nil

operations
  public getBest: () ==> IOmlExpression
  getBest() == return ivBest
    pre hasBest();

  public hasBest: () ==> bool
  hasBest () == return ivBest <> nil;

  public setBest: [ IOmlExpression ] ==> ()
  setBest(parg) == ivBest := parg;

end OmlTraceLetBeBinding
\end{vdm_al}

\begin{vdm_al}
class OmlTraceLetBinding is subclass of IOmlTraceLetBinding
operations
  public identity: () ==> seq of char
  identity () == return "TraceLetBinding";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceLetBinding(self);

  public OmlTraceLetBinding:
    (seq of IOmlValueShape) ==> OmlTraceLetBinding
  OmlTraceLetBinding (p1) == 
    ( setDefinitionList(p1) );

  public OmlTraceLetBinding:
    (seq of IOmlValueShape) *
    nat *
    nat ==> OmlTraceLetBinding
  OmlTraceLetBinding (p1,line,column) == 
    ( setDefinitionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "definition_list" in
        if fname in set dom data
        then setDefinitionList(data(fname)) );

instance variables
  private ivDefinitionList : seq of IOmlValueShape := []

operations
  public getDefinitionList: () ==> seq of IOmlValueShape
  getDefinitionList() == return ivDefinitionList;

  public setDefinitionList: seq of IOmlValueShape ==> ()
  setDefinitionList(parg) == ivDefinitionList := parg;

  public addDefinitionList: IOmlNode ==> ()
  addDefinitionList (parg) == ivDefinitionList := ivDefinitionList ^ [parg];

end OmlTraceLetBinding
\end{vdm_al}

\begin{vdm_al}
class OmlTraceMethodApply is subclass of IOmlTraceMethodApply
operations
  public identity: () ==> seq of char
  identity () == return "TraceMethodApply";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceMethodApply(self);

  public OmlTraceMethodApply:
    (seq of char) *
    (seq of char) *
    (seq of IOmlExpression) ==> OmlTraceMethodApply
  OmlTraceMethodApply (p1,p2,p3) == 
    ( setVariableName(p1);
      setMethodName(p2);
      setArgs(p3) );

  public OmlTraceMethodApply:
    (seq of char) *
    (seq of char) *
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlTraceMethodApply
  OmlTraceMethodApply (p1,p2,p3,line,column) == 
    ( setVariableName(p1);
      setMethodName(p2);
      setArgs(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "variable_name" in
        if fname in set dom data
        then setVariableName(data(fname));
      let fname = "method_name" in
        if fname in set dom data
        then setMethodName(data(fname));
      let fname = "args" in
        if fname in set dom data
        then setArgs(data(fname)) );

instance variables
  private ivVariableName : seq of char := []

operations
  public getVariableName: () ==> seq of char
  getVariableName() == return ivVariableName;

  public setVariableName: seq of char ==> ()
  setVariableName(parg) == ivVariableName := parg;

instance variables
  private ivMethodName : seq of char := []

operations
  public getMethodName: () ==> seq of char
  getMethodName() == return ivMethodName;

  public setMethodName: seq of char ==> ()
  setMethodName(parg) == ivMethodName := parg;

instance variables
  private ivArgs : seq of IOmlExpression := []

operations
  public getArgs: () ==> seq of IOmlExpression
  getArgs() == return ivArgs;

  public setArgs: seq of IOmlExpression ==> ()
  setArgs(parg) == ivArgs := parg;

  public addArgs: IOmlNode ==> ()
  addArgs (parg) == ivArgs := ivArgs ^ [parg];

end OmlTraceMethodApply
\end{vdm_al}

\begin{vdm_al}
class OmlTraceOneOrMore is subclass of IOmlTraceOneOrMore
operations
  public identity: () ==> seq of char
  identity () == return "TraceOneOrMore";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceOneOrMore(self);

  public OmlTraceOneOrMore:
    () ==> OmlTraceOneOrMore
  OmlTraceOneOrMore () == 
    skip;

  public OmlTraceOneOrMore:
    nat *
    nat ==> OmlTraceOneOrMore
  OmlTraceOneOrMore (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTraceOneOrMore
\end{vdm_al}

\begin{vdm_al}
class OmlTraceRange is subclass of IOmlTraceRange
operations
  public identity: () ==> seq of char
  identity () == return "TraceRange";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceRange(self);

  public OmlTraceRange:
    (IOmlNumericLiteral) *
    [IOmlNumericLiteral] ==> OmlTraceRange
  OmlTraceRange (p1,p2) == 
    ( setLower(p1);
      setUpper(p2) );

  public OmlTraceRange:
    (IOmlNumericLiteral) *
    [IOmlNumericLiteral] *
    nat *
    nat ==> OmlTraceRange
  OmlTraceRange (p1,p2,line,column) == 
    ( setLower(p1);
      setUpper(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lower" in
        if fname in set dom data
        then setLower(data(fname));
      let fname = "upper" in
        if fname in set dom data
        then setUpper(data(fname)) );

instance variables
  private ivLower : [IOmlNumericLiteral] := nil

operations
  public getLower: () ==> IOmlNumericLiteral
  getLower() == return ivLower;

  public setLower: IOmlNumericLiteral ==> ()
  setLower(parg) == ivLower := parg;

instance variables
  private ivUpper : [IOmlNumericLiteral] := nil

operations
  public getUpper: () ==> IOmlNumericLiteral
  getUpper() == return ivUpper
    pre hasUpper();

  public hasUpper: () ==> bool
  hasUpper () == return ivUpper <> nil;

  public setUpper: [ IOmlNumericLiteral ] ==> ()
  setUpper(parg) == ivUpper := parg;

end OmlTraceRange
\end{vdm_al}

\begin{vdm_al}
class OmlTraceRepeatPattern is subclass of IOmlTraceRepeatPattern
operations
  public identity: () ==> seq of char
  identity () == return "TraceRepeatPattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceRepeatPattern(self);

end OmlTraceRepeatPattern
\end{vdm_al}
\begin{vdm_al}
class OmlTraceSequenceDefinition is subclass of IOmlTraceSequenceDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TraceSequenceDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceSequenceDefinition(self);

  public OmlTraceSequenceDefinition:
    (seq of IOmlTraceDefinition) ==> OmlTraceSequenceDefinition
  OmlTraceSequenceDefinition (p1) == 
    ( setDefs(p1) );

  public OmlTraceSequenceDefinition:
    (seq of IOmlTraceDefinition) *
    nat *
    nat ==> OmlTraceSequenceDefinition
  OmlTraceSequenceDefinition (p1,line,column) == 
    ( setDefs(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "defs" in
        if fname in set dom data
        then setDefs(data(fname)) );

instance variables
  private ivDefs : seq of IOmlTraceDefinition := []

operations
  public getDefs: () ==> seq of IOmlTraceDefinition
  getDefs() == return ivDefs;

  public setDefs: seq of IOmlTraceDefinition ==> ()
  setDefs(parg) == ivDefs := parg;

  public addDefs: IOmlNode ==> ()
  addDefs (parg) == ivDefs := ivDefs ^ [parg];

end OmlTraceSequenceDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTraceZeroOrMore is subclass of IOmlTraceZeroOrMore
operations
  public identity: () ==> seq of char
  identity () == return "TraceZeroOrMore";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceZeroOrMore(self);

  public OmlTraceZeroOrMore:
    () ==> OmlTraceZeroOrMore
  OmlTraceZeroOrMore () == 
    skip;

  public OmlTraceZeroOrMore:
    nat *
    nat ==> OmlTraceZeroOrMore
  OmlTraceZeroOrMore (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTraceZeroOrMore
\end{vdm_al}

\begin{vdm_al}
class OmlTraceZeroOrOne is subclass of IOmlTraceZeroOrOne
operations
  public identity: () ==> seq of char
  identity () == return "TraceZeroOrOne";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTraceZeroOrOne(self);

  public OmlTraceZeroOrOne:
    () ==> OmlTraceZeroOrOne
  OmlTraceZeroOrOne () == 
    skip;

  public OmlTraceZeroOrOne:
    nat *
    nat ==> OmlTraceZeroOrOne
  OmlTraceZeroOrOne (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlTraceZeroOrOne
\end{vdm_al}

\begin{vdm_al}
class OmlTrapDefinition is subclass of IOmlTrapDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TrapDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTrapDefinition(self);

  public OmlTrapDefinition:
    (IOmlPatternBind) *
    (IOmlStatement) ==> OmlTrapDefinition
  OmlTrapDefinition (p1,p2) == 
    ( setPatternBind(p1);
      setStatement(p2) );

  public OmlTrapDefinition:
    (IOmlPatternBind) *
    (IOmlStatement) *
    nat *
    nat ==> OmlTrapDefinition
  OmlTrapDefinition (p1,p2,line,column) == 
    ( setPatternBind(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlTrapDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTrapStatement is subclass of IOmlTrapStatement
operations
  public identity: () ==> seq of char
  identity () == return "TrapStatement";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTrapStatement(self);

  public OmlTrapStatement:
    (IOmlPatternBind) *
    (IOmlStatement) *
    (IOmlStatement) ==> OmlTrapStatement
  OmlTrapStatement (p1,p2,p3) == 
    ( setPatternBind(p1);
      setWithPart(p2);
      setInPart(p3) );

  public OmlTrapStatement:
    (IOmlPatternBind) *
    (IOmlStatement) *
    (IOmlStatement) *
    nat *
    nat ==> OmlTrapStatement
  OmlTrapStatement (p1,p2,p3,line,column) == 
    ( setPatternBind(p1);
      setWithPart(p2);
      setInPart(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_bind" in
        if fname in set dom data
        then setPatternBind(data(fname));
      let fname = "with_part" in
        if fname in set dom data
        then setWithPart(data(fname));
      let fname = "in_part" in
        if fname in set dom data
        then setInPart(data(fname)) );

instance variables
  private ivPatternBind : [IOmlPatternBind] := nil

operations
  public getPatternBind: () ==> IOmlPatternBind
  getPatternBind() == return ivPatternBind;

  public setPatternBind: IOmlPatternBind ==> ()
  setPatternBind(parg) == ivPatternBind := parg;

instance variables
  private ivWithPart : [IOmlStatement] := nil

operations
  public getWithPart: () ==> IOmlStatement
  getWithPart() == return ivWithPart;

  public setWithPart: IOmlStatement ==> ()
  setWithPart(parg) == ivWithPart := parg;

instance variables
  private ivInPart : [IOmlStatement] := nil

operations
  public getInPart: () ==> IOmlStatement
  getInPart() == return ivInPart;

  public setInPart: IOmlStatement ==> ()
  setInPart(parg) == ivInPart := parg;

end OmlTrapStatement
\end{vdm_al}

\begin{vdm_al}
class OmlTupleConstructor is subclass of IOmlTupleConstructor
operations
  public identity: () ==> seq of char
  identity () == return "TupleConstructor";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTupleConstructor(self);

  public OmlTupleConstructor:
    (seq of IOmlExpression) ==> OmlTupleConstructor
  OmlTupleConstructor (p1) == 
    ( setExpressionList(p1) );

  public OmlTupleConstructor:
    (seq of IOmlExpression) *
    nat *
    nat ==> OmlTupleConstructor
  OmlTupleConstructor (p1,line,column) == 
    ( setExpressionList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression_list" in
        if fname in set dom data
        then setExpressionList(data(fname)) );

instance variables
  private ivExpressionList : seq of IOmlExpression := []

operations
  public getExpressionList: () ==> seq of IOmlExpression
  getExpressionList() == return ivExpressionList;

  public setExpressionList: seq of IOmlExpression ==> ()
  setExpressionList(parg) == ivExpressionList := parg;

  public addExpressionList: IOmlNode ==> ()
  addExpressionList (parg) == ivExpressionList := ivExpressionList ^ [parg];

end OmlTupleConstructor
\end{vdm_al}

\begin{vdm_al}
class OmlTuplePattern is subclass of IOmlTuplePattern
operations
  public identity: () ==> seq of char
  identity () == return "TuplePattern";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTuplePattern(self);

  public OmlTuplePattern:
    (seq of IOmlPattern) ==> OmlTuplePattern
  OmlTuplePattern (p1) == 
    ( setPatternList(p1) );

  public OmlTuplePattern:
    (seq of IOmlPattern) *
    nat *
    nat ==> OmlTuplePattern
  OmlTuplePattern (p1,line,column) == 
    ( setPatternList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern_list" in
        if fname in set dom data
        then setPatternList(data(fname)) );

instance variables
  private ivPatternList : seq of IOmlPattern := []

operations
  public getPatternList: () ==> seq of IOmlPattern
  getPatternList() == return ivPatternList;

  public setPatternList: seq of IOmlPattern ==> ()
  setPatternList(parg) == ivPatternList := parg;

  public addPatternList: IOmlNode ==> ()
  addPatternList (parg) == ivPatternList := ivPatternList ^ [parg];

end OmlTuplePattern
\end{vdm_al}

\begin{vdm_al}
class OmlType is subclass of IOmlType
operations
  public identity: () ==> seq of char
  identity () == return "Type";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitType(self);

end OmlType
\end{vdm_al}
\begin{vdm_al}
class OmlTypeBind is subclass of IOmlTypeBind
operations
  public identity: () ==> seq of char
  identity () == return "TypeBind";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeBind(self);

  public OmlTypeBind:
    (seq of IOmlPattern) *
    (IOmlType) ==> OmlTypeBind
  OmlTypeBind (p1,p2) == 
    ( setPattern(p1);
      setType(p2) );

  public OmlTypeBind:
    (seq of IOmlPattern) *
    (IOmlType) *
    nat *
    nat ==> OmlTypeBind
  OmlTypeBind (p1,p2,line,column) == 
    ( setPattern(p1);
      setType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivPattern : seq of IOmlPattern := []

operations
  public getPattern: () ==> seq of IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: seq of IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

  public addPattern: IOmlNode ==> ()
  addPattern (parg) == ivPattern := ivPattern ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType;

  public setType: IOmlType ==> ()
  setType(parg) == ivType := parg;

end OmlTypeBind
\end{vdm_al}

\begin{vdm_al}
class OmlTypeDefinition is subclass of IOmlTypeDefinition
operations
  public identity: () ==> seq of char
  identity () == return "TypeDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeDefinition(self);

  public OmlTypeDefinition:
    (IOmlAccessDefinition) *
    (IOmlTypeShape) ==> OmlTypeDefinition
  OmlTypeDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlTypeDefinition:
    (IOmlAccessDefinition) *
    (IOmlTypeShape) *
    nat *
    nat ==> OmlTypeDefinition
  OmlTypeDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlTypeShape] := nil

operations
  public getShape: () ==> IOmlTypeShape
  getShape() == return ivShape;

  public setShape: IOmlTypeShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlTypeDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlTypeDefinitions is subclass of IOmlTypeDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "TypeDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeDefinitions(self);

  public OmlTypeDefinitions:
    (seq of IOmlTypeDefinition) ==> OmlTypeDefinitions
  OmlTypeDefinitions (p1) == 
    ( setTypeList(p1) );

  public OmlTypeDefinitions:
    (seq of IOmlTypeDefinition) *
    nat *
    nat ==> OmlTypeDefinitions
  OmlTypeDefinitions (p1,line,column) == 
    ( setTypeList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "type_list" in
        if fname in set dom data
        then setTypeList(data(fname)) );

instance variables
  private ivTypeList : seq of IOmlTypeDefinition := []

operations
  public getTypeList: () ==> seq of IOmlTypeDefinition
  getTypeList() == return ivTypeList;

  public setTypeList: seq of IOmlTypeDefinition ==> ()
  setTypeList(parg) == ivTypeList := parg;

  public addTypeList: IOmlNode ==> ()
  addTypeList (parg) == ivTypeList := ivTypeList ^ [parg];

end OmlTypeDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlTypeName is subclass of IOmlTypeName
operations
  public identity: () ==> seq of char
  identity () == return "TypeName";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeName(self);

  public OmlTypeName:
    (IOmlName) ==> OmlTypeName
  OmlTypeName (p1) == 
    ( setName(p1) );

  public OmlTypeName:
    (IOmlName) *
    nat *
    nat ==> OmlTypeName
  OmlTypeName (p1,line,column) == 
    ( setName(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name" in
        if fname in set dom data
        then setName(data(fname)) );

instance variables
  private ivName : [IOmlName] := nil

operations
  public getName: () ==> IOmlName
  getName() == return ivName;

  public setName: IOmlName ==> ()
  setName(parg) == ivName := parg;

end OmlTypeName
\end{vdm_al}

\begin{vdm_al}
class OmlTypeShape is subclass of IOmlTypeShape
operations
  public identity: () ==> seq of char
  identity () == return "TypeShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeShape(self);

end OmlTypeShape
\end{vdm_al}
\begin{vdm_al}
class OmlTypeVariable is subclass of IOmlTypeVariable
operations
  public identity: () ==> seq of char
  identity () == return "TypeVariable";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypeVariable(self);

  public OmlTypeVariable:
    (seq of char) ==> OmlTypeVariable
  OmlTypeVariable (p1) == 
    ( setIdentifier(p1) );

  public OmlTypeVariable:
    (seq of char) *
    nat *
    nat ==> OmlTypeVariable
  OmlTypeVariable (p1,line,column) == 
    ( setIdentifier(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

end OmlTypeVariable
\end{vdm_al}

\begin{vdm_al}
class OmlTypelessExplicitFunction is subclass of IOmlTypelessExplicitFunction
operations
  public identity: () ==> seq of char
  identity () == return "TypelessExplicitFunction";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitTypelessExplicitFunction(self);

  public OmlTypelessExplicitFunction:
    (seq of char) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) ==> OmlTypelessExplicitFunction
  OmlTypelessExplicitFunction (p1,p2,p3,p4) == 
    ( setIdentifier(p1);
      setParameterList(p2);
      setBody(p3);
      setTrailer(p4) );

  public OmlTypelessExplicitFunction:
    (seq of char) *
    (seq of IOmlParameter) *
    (IOmlFunctionBody) *
    (IOmlFunctionTrailer) *
    nat *
    nat ==> OmlTypelessExplicitFunction
  OmlTypelessExplicitFunction (p1,p2,p3,p4,line,column) == 
    ( setIdentifier(p1);
      setParameterList(p2);
      setBody(p3);
      setTrailer(p4);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "identifier" in
        if fname in set dom data
        then setIdentifier(data(fname));
      let fname = "parameter_list" in
        if fname in set dom data
        then setParameterList(data(fname));
      let fname = "body" in
        if fname in set dom data
        then setBody(data(fname));
      let fname = "trailer" in
        if fname in set dom data
        then setTrailer(data(fname)) );

instance variables
  private ivIdentifier : seq of char := []

operations
  public getIdentifier: () ==> seq of char
  getIdentifier() == return ivIdentifier;

  public setIdentifier: seq of char ==> ()
  setIdentifier(parg) == ivIdentifier := parg;

instance variables
  private ivParameterList : seq of IOmlParameter := []

operations
  public getParameterList: () ==> seq of IOmlParameter
  getParameterList() == return ivParameterList;

  public setParameterList: seq of IOmlParameter ==> ()
  setParameterList(parg) == ivParameterList := parg;

  public addParameterList: IOmlNode ==> ()
  addParameterList (parg) == ivParameterList := ivParameterList ^ [parg];

instance variables
  private ivBody : [IOmlFunctionBody] := nil

operations
  public getBody: () ==> IOmlFunctionBody
  getBody() == return ivBody;

  public setBody: IOmlFunctionBody ==> ()
  setBody(parg) == ivBody := parg;

instance variables
  private ivTrailer : [IOmlFunctionTrailer] := nil

operations
  public getTrailer: () ==> IOmlFunctionTrailer
  getTrailer() == return ivTrailer;

  public setTrailer: IOmlFunctionTrailer ==> ()
  setTrailer(parg) == ivTrailer := parg;

end OmlTypelessExplicitFunction
\end{vdm_al}

\begin{vdm_al}
class OmlUnaryExpression is subclass of IOmlUnaryExpression
operations
  public identity: () ==> seq of char
  identity () == return "UnaryExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnaryExpression(self);

  public OmlUnaryExpression:
    (IOmlUnaryOperator) *
    (IOmlExpression) ==> OmlUnaryExpression
  OmlUnaryExpression (p1,p2) == 
    ( setOperator(p1);
      setExpression(p2) );

  public OmlUnaryExpression:
    (IOmlUnaryOperator) *
    (IOmlExpression) *
    nat *
    nat ==> OmlUnaryExpression
  OmlUnaryExpression (p1,p2,line,column) == 
    ( setOperator(p1);
      setExpression(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "operator" in
        if fname in set dom data
        then setOperator(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivOperator : [IOmlUnaryOperator] := nil

operations
  public getOperator: () ==> IOmlUnaryOperator
  getOperator() == return ivOperator;

  public setOperator: IOmlUnaryOperator ==> ()
  setOperator(parg) == ivOperator := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlUnaryExpression
\end{vdm_al}

\begin{vdm_al}
class OmlUnaryOperator is subclass of IOmlUnaryOperator
operations
  public identity: () ==> seq of char
  identity () == return "UnaryOperator";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnaryOperator(self);

  public OmlUnaryOperator: nat ==> OmlUnaryOperator
  OmlUnaryOperator (pv) == setValue(pv);

  public OmlUnaryOperator: nat * nat * nat ==> OmlUnaryOperator
  OmlUnaryOperator (pv, pline, pcolumn) == ( setValue(pv); setPosition(pline, pcolumn) );

instance variables
  private val : [nat] := nil

operations
  public setValue: nat ==> ()
  setValue (pval) == val := pval
    pre val = nil and OmlUnaryOperatorQuotes`validQuote(pval);

  public getValue: () ==> nat
  getValue () == return val
    pre val <> nil;

  public getStringValue: () ==> seq of char
  getStringValue() == return OmlUnaryOperatorQuotes`getQuoteName(val)
    pre val <> nil;

end OmlUnaryOperator
\end{vdm_al}
\begin{vdm_al}
class OmlUnaryOperatorQuotes
instance variables
  static public IQABS : nat := 0;
  static public IQINVERSE : nat := 1;
  static public IQHD : nat := 2;
  static public IQELEMS : nat := 3;
  static public IQINDS : nat := 4;
  static public IQTL : nat := 5;
  static public IQCARD : nat := 6;
  static public IQDUNION : nat := 7;
  static public IQPOWER : nat := 8;
  static public IQLEN : nat := 9;
  static public IQPLUS : nat := 10;
  static public IQDOM : nat := 11;
  static public IQDMERGE : nat := 12;
  static public IQDINTER : nat := 13;
  static public IQNOT : nat := 14;
  static public IQMINUS : nat := 15;
  static public IQRNG : nat := 16;
  static public IQFLOOR : nat := 17;
  static public IQDCONC : nat := 18;

  static private qmap : map nat to seq of char :=
    { IQABS |-> "<ABS>",
      IQINVERSE |-> "<INVERSE>",
      IQHD |-> "<HD>",
      IQELEMS |-> "<ELEMS>",
      IQINDS |-> "<INDS>",
      IQTL |-> "<TL>",
      IQCARD |-> "<CARD>",
      IQDUNION |-> "<DUNION>",
      IQPOWER |-> "<POWER>",
      IQLEN |-> "<LEN>",
      IQPLUS |-> "<PLUS>",
      IQDOM |-> "<DOM>",
      IQDMERGE |-> "<DMERGE>",
      IQDINTER |-> "<DINTER>",
      IQNOT |-> "<NOT>",
      IQMINUS |-> "<MINUS>",
      IQRNG |-> "<RNG>",
      IQFLOOR |-> "<FLOOR>",
      IQDCONC |-> "<DCONC>" }

operations
  static public getQuoteName: nat ==> seq of char
  getQuoteName (pid) ==
    return qmap(pid)
    pre validQuote(pid);

  static public validQuote: nat ==> bool
  validQuote (pid) == return pid in set dom qmap

end OmlUnaryOperatorQuotes
\end{vdm_al}
\begin{vdm_al}
class OmlUndefinedExpression is subclass of IOmlUndefinedExpression
operations
  public identity: () ==> seq of char
  identity () == return "UndefinedExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUndefinedExpression(self);

  public OmlUndefinedExpression:
    () ==> OmlUndefinedExpression
  OmlUndefinedExpression () == 
    skip;

  public OmlUndefinedExpression:
    nat *
    nat ==> OmlUndefinedExpression
  OmlUndefinedExpression (line,column) == 
    setPosition(line, column);

  public init: map seq of char to [FieldValue] ==> ()
  init (-) == skip;

end OmlUndefinedExpression
\end{vdm_al}

\begin{vdm_al}
class OmlUnionType is subclass of IOmlUnionType
operations
  public identity: () ==> seq of char
  identity () == return "UnionType";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitUnionType(self);

  public OmlUnionType:
    (IOmlType) *
    (IOmlType) ==> OmlUnionType
  OmlUnionType (p1,p2) == 
    ( setLhsType(p1);
      setRhsType(p2) );

  public OmlUnionType:
    (IOmlType) *
    (IOmlType) *
    nat *
    nat ==> OmlUnionType
  OmlUnionType (p1,p2,line,column) == 
    ( setLhsType(p1);
      setRhsType(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "lhs_type" in
        if fname in set dom data
        then setLhsType(data(fname));
      let fname = "rhs_type" in
        if fname in set dom data
        then setRhsType(data(fname)) );

instance variables
  private ivLhsType : [IOmlType] := nil

operations
  public getLhsType: () ==> IOmlType
  getLhsType() == return ivLhsType;

  public setLhsType: IOmlType ==> ()
  setLhsType(parg) == ivLhsType := parg;

instance variables
  private ivRhsType : [IOmlType] := nil

operations
  public getRhsType: () ==> IOmlType
  getRhsType() == return ivRhsType;

  public setRhsType: IOmlType ==> ()
  setRhsType(parg) == ivRhsType := parg;

end OmlUnionType
\end{vdm_al}

\begin{vdm_al}
class OmlValueDefinition is subclass of IOmlValueDefinition
operations
  public identity: () ==> seq of char
  identity () == return "ValueDefinition";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueDefinition(self);

  public OmlValueDefinition:
    (IOmlAccessDefinition) *
    (IOmlValueShape) ==> OmlValueDefinition
  OmlValueDefinition (p1,p2) == 
    ( setAccess(p1);
      setShape(p2) );

  public OmlValueDefinition:
    (IOmlAccessDefinition) *
    (IOmlValueShape) *
    nat *
    nat ==> OmlValueDefinition
  OmlValueDefinition (p1,p2,line,column) == 
    ( setAccess(p1);
      setShape(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "access" in
        if fname in set dom data
        then setAccess(data(fname));
      let fname = "shape" in
        if fname in set dom data
        then setShape(data(fname)) );

instance variables
  private ivAccess : [IOmlAccessDefinition] := nil

operations
  public getAccess: () ==> IOmlAccessDefinition
  getAccess() == return ivAccess;

  public setAccess: IOmlAccessDefinition ==> ()
  setAccess(parg) == ivAccess := parg;

instance variables
  private ivShape : [IOmlValueShape] := nil

operations
  public getShape: () ==> IOmlValueShape
  getShape() == return ivShape;

  public setShape: IOmlValueShape ==> ()
  setShape(parg) == ivShape := parg;

end OmlValueDefinition
\end{vdm_al}

\begin{vdm_al}
class OmlValueDefinitions is subclass of IOmlValueDefinitions
operations
  public identity: () ==> seq of char
  identity () == return "ValueDefinitions";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueDefinitions(self);

  public OmlValueDefinitions:
    (seq of IOmlValueDefinition) ==> OmlValueDefinitions
  OmlValueDefinitions (p1) == 
    ( setValueList(p1) );

  public OmlValueDefinitions:
    (seq of IOmlValueDefinition) *
    nat *
    nat ==> OmlValueDefinitions
  OmlValueDefinitions (p1,line,column) == 
    ( setValueList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "value_list" in
        if fname in set dom data
        then setValueList(data(fname)) );

instance variables
  private ivValueList : seq of IOmlValueDefinition := []

operations
  public getValueList: () ==> seq of IOmlValueDefinition
  getValueList() == return ivValueList;

  public setValueList: seq of IOmlValueDefinition ==> ()
  setValueList(parg) == ivValueList := parg;

  public addValueList: IOmlNode ==> ()
  addValueList (parg) == ivValueList := ivValueList ^ [parg];

end OmlValueDefinitions
\end{vdm_al}

\begin{vdm_al}
class OmlValueShape is subclass of IOmlValueShape
operations
  public identity: () ==> seq of char
  identity () == return "ValueShape";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitValueShape(self);

  public OmlValueShape:
    (IOmlPattern) *
    [IOmlType] *
    (IOmlExpression) ==> OmlValueShape
  OmlValueShape (p1,p2,p3) == 
    ( setPattern(p1);
      setType(p2);
      setExpression(p3) );

  public OmlValueShape:
    (IOmlPattern) *
    [IOmlType] *
    (IOmlExpression) *
    nat *
    nat ==> OmlValueShape
  OmlValueShape (p1,p2,p3,line,column) == 
    ( setPattern(p1);
      setType(p2);
      setExpression(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "pattern" in
        if fname in set dom data
        then setPattern(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname));
      let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname)) );

instance variables
  private ivPattern : [IOmlPattern] := nil

operations
  public getPattern: () ==> IOmlPattern
  getPattern() == return ivPattern;

  public setPattern: IOmlPattern ==> ()
  setPattern(parg) == ivPattern := parg;

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType
    pre hasType();

  public hasType: () ==> bool
  hasType () == return ivType <> nil;

  public setType: [ IOmlType ] ==> ()
  setType(parg) == ivType := parg;

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

end OmlValueShape
\end{vdm_al}

\begin{vdm_al}
class OmlVarInformation is subclass of IOmlVarInformation
operations
  public identity: () ==> seq of char
  identity () == return "VarInformation";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitVarInformation(self);

  public OmlVarInformation:
    (IOmlMode) *
    (seq of IOmlName) *
    [IOmlType] ==> OmlVarInformation
  OmlVarInformation (p1,p2,p3) == 
    ( setMode(p1);
      setNameList(p2);
      setType(p3) );

  public OmlVarInformation:
    (IOmlMode) *
    (seq of IOmlName) *
    [IOmlType] *
    nat *
    nat ==> OmlVarInformation
  OmlVarInformation (p1,p2,p3,line,column) == 
    ( setMode(p1);
      setNameList(p2);
      setType(p3);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "mode" in
        if fname in set dom data
        then setMode(data(fname));
      let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname));
      let fname = "type" in
        if fname in set dom data
        then setType(data(fname)) );

instance variables
  private ivMode : [IOmlMode] := nil

operations
  public getMode: () ==> IOmlMode
  getMode() == return ivMode;

  public setMode: IOmlMode ==> ()
  setMode(parg) == ivMode := parg;

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

instance variables
  private ivType : [IOmlType] := nil

operations
  public getType: () ==> IOmlType
  getType() == return ivType
    pre hasType();

  public hasType: () ==> bool
  hasType () == return ivType <> nil;

  public setType: [ IOmlType ] ==> ()
  setType(parg) == ivType := parg;

end OmlVarInformation
\end{vdm_al}

\begin{vdm_al}
class OmlVisitor is subclass of IOmlVisitor
operations
  public visitDocument: IOmlDocument ==> ()
  visitDocument (-) == skip;

  public visitLexem: IOmlLexem ==> ()
  visitLexem (-) == skip;

  public visitOldName: IOmlOldName ==> ()
  visitOldName (-) == skip;

  public visitIntType: IOmlIntType ==> ()
  visitIntType (-) == skip;

  public visitSeqConcPattern: IOmlSeqConcPattern ==> ()
  visitSeqConcPattern (-) == skip;

  public visitSkipStatement: IOmlSkipStatement ==> ()
  visitSkipStatement (-) == skip;

  public visitPeriodicThread: IOmlPeriodicThread ==> ()
  visitPeriodicThread (-) == skip;

  public visitCallStatement: IOmlCallStatement ==> ()
  visitCallStatement (-) == skip;

  public visitIsofclassExpression: IOmlIsofclassExpression ==> ()
  visitIsofclassExpression (-) == skip;

  public visitIndexForLoop: IOmlIndexForLoop ==> ()
  visitIndexForLoop (-) == skip;

  public visitTextLiteral: IOmlTextLiteral ==> ()
  visitTextLiteral (-) == skip;

  public visitSymbolicLiteralExpression: IOmlSymbolicLiteralExpression ==> ()
  visitSymbolicLiteralExpression (-) == skip;

  public visitReqExpression: IOmlReqExpression ==> ()
  visitReqExpression (-) == skip;

  public visitPermissionPredicate: IOmlPermissionPredicate ==> ()
  visitPermissionPredicate (-) == skip;

  public visitProcedureThread: IOmlProcedureThread ==> ()
  visitProcedureThread (-) == skip;

  public visitSetType: IOmlSetType ==> ()
  visitSetType (-) == skip;

  public visitMapEnumeration: IOmlMapEnumeration ==> ()
  visitMapEnumeration (-) == skip;

  public visitNewExpression: IOmlNewExpression ==> ()
  visitNewExpression (-) == skip;

  public visitAtomicStatement: IOmlAtomicStatement ==> ()
  visitAtomicStatement (-) == skip;

  public visitFieldReference: IOmlFieldReference ==> ()
  visitFieldReference (-) == skip;

  public visitClass: IOmlClass ==> ()
  visitClass (-) == skip;

  public visitBlockStatement: IOmlBlockStatement ==> ()
  visitBlockStatement (-) == skip;

  public visitUnaryExpression: IOmlUnaryExpression ==> ()
  visitUnaryExpression (-) == skip;

  public visitInjectiveMapType: IOmlInjectiveMapType ==> ()
  visitInjectiveMapType (-) == skip;

  public visitNumericLiteral: IOmlNumericLiteral ==> ()
  visitNumericLiteral (-) == skip;

  public visitMatchValue: IOmlMatchValue ==> ()
  visitMatchValue (-) == skip;

  public visitOperationTrailer: IOmlOperationTrailer ==> ()
  visitOperationTrailer (-) == skip;

  public visitTypeDefinitions: IOmlTypeDefinitions ==> ()
  visitTypeDefinitions (-) == skip;

  public visitTypeBind: IOmlTypeBind ==> ()
  visitTypeBind (-) == skip;

  public visitRecordModifier: IOmlRecordModifier ==> ()
  visitRecordModifier (-) == skip;

  public visitObjectDesignatorExpression: IOmlObjectDesignatorExpression ==> ()
  visitObjectDesignatorExpression (-) == skip;

  public visitTraceLetBinding: IOmlTraceLetBinding ==> ()
  visitTraceLetBinding (-) == skip;

  public visitIdentifierTypePair: IOmlIdentifierTypePair ==> ()
  visitIdentifierTypePair (-) == skip;

  public visitRealLiteral: IOmlRealLiteral ==> ()
  visitRealLiteral (-) == skip;

  public visitPatternBindExpression: IOmlPatternBindExpression ==> ()
  visitPatternBindExpression (-) == skip;

  public visitTrapDefinition: IOmlTrapDefinition ==> ()
  visitTrapDefinition (-) == skip;

  public visitSelfExpression: IOmlSelfExpression ==> ()
  visitSelfExpression (-) == skip;

  public visitRecursiveTrapStatement: IOmlRecursiveTrapStatement ==> ()
  visitRecursiveTrapStatement (-) == skip;

  public visitOperationDefinition: IOmlOperationDefinition ==> ()
  visitOperationDefinition (-) == skip;

  public visitWhileLoop: IOmlWhileLoop ==> ()
  visitWhileLoop (-) == skip;

  public visitDefStatement: IOmlDefStatement ==> ()
  visitDefStatement (-) == skip;

  public visitSeq0Type: IOmlSeq0Type ==> ()
  visitSeq0Type (-) == skip;

  public visitSetForLoop: IOmlSetForLoop ==> ()
  visitSetForLoop (-) == skip;

  public visitDefExpression: IOmlDefExpression ==> ()
  visitDefExpression (-) == skip;

  public visitDurationStatement: IOmlDurationStatement ==> ()
  visitDurationStatement (-) == skip;

  public visitImplicitOperation: IOmlImplicitOperation ==> ()
  visitImplicitOperation (-) == skip;

  public visitTypeVariable: IOmlTypeVariable ==> ()
  visitTypeVariable (-) == skip;

  public visitCompositeType: IOmlCompositeType ==> ()
  visitCompositeType (-) == skip;

  public visitTraceChoiceDefinition: IOmlTraceChoiceDefinition ==> ()
  visitTraceChoiceDefinition (-) == skip;

  public visitOperationType: IOmlOperationType ==> ()
  visitOperationType (-) == skip;

  public visitBooleanLiteral: IOmlBooleanLiteral ==> ()
  visitBooleanLiteral (-) == skip;

  public visitCasesStatementAlternative: IOmlCasesStatementAlternative ==> ()
  visitCasesStatementAlternative (-) == skip;

  public visitActiveExpression: IOmlActiveExpression ==> ()
  visitActiveExpression (-) == skip;

  public visitForAllExpression: IOmlForAllExpression ==> ()
  visitForAllExpression (-) == skip;

  public visitSpecifications: IOmlSpecifications ==> ()
  visitSpecifications (-) == skip;

  public visitCasesExpression: IOmlCasesExpression ==> ()
  visitCasesExpression (-) == skip;

  public visitIfExpression: IOmlIfExpression ==> ()
  visitIfExpression (-) == skip;

  public visitValueDefinitions: IOmlValueDefinitions ==> ()
  visitValueDefinitions (-) == skip;

  public visitCasesStatement: IOmlCasesStatement ==> ()
  visitCasesStatement (-) == skip;

  public visitErrorStatement: IOmlErrorStatement ==> ()
  visitErrorStatement (-) == skip;

  public visitImplicitFunction: IOmlImplicitFunction ==> ()
  visitImplicitFunction (-) == skip;

  public visitNatType: IOmlNatType ==> ()
  visitNatType (-) == skip;

  public visitSamebaseclassExpression: IOmlSamebaseclassExpression ==> ()
  visitSamebaseclassExpression (-) == skip;

  public visitComplexType: IOmlComplexType ==> ()
  visitComplexType (-) == skip;

  public visitExternals: IOmlExternals ==> ()
  visitExternals (-) == skip;

  public visitSubsequenceExpression: IOmlSubsequenceExpression ==> ()
  visitSubsequenceExpression (-) == skip;

  public visitElseIfStatement: IOmlElseIfStatement ==> ()
  visitElseIfStatement (-) == skip;

  public visitGeneralMapType: IOmlGeneralMapType ==> ()
  visitGeneralMapType (-) == skip;

  public visitSpecificationStatement: IOmlSpecificationStatement ==> ()
  visitSpecificationStatement (-) == skip;

  public visitTuplePattern: IOmlTuplePattern ==> ()
  visitTuplePattern (-) == skip;

  public visitTraceBracketedDefinition: IOmlTraceBracketedDefinition ==> ()
  visitTraceBracketedDefinition (-) == skip;

  public visitField: IOmlField ==> ()
  visitField (-) == skip;

  public visitNamedTrace: IOmlNamedTrace ==> ()
  visitNamedTrace (-) == skip;

  public visitTraceSequenceDefinition: IOmlTraceSequenceDefinition ==> ()
  visitTraceSequenceDefinition (-) == skip;

  public visitTokenType: IOmlTokenType ==> ()
  visitTokenType (-) == skip;

  public visitTraceRange: IOmlTraceRange ==> ()
  visitTraceRange (-) == skip;

  public visitTypeName: IOmlTypeName ==> ()
  visitTypeName (-) == skip;

  public visitTypeDefinition: IOmlTypeDefinition ==> ()
  visitTypeDefinition (-) == skip;

  public visitExplicitOperation: IOmlExplicitOperation ==> ()
  visitExplicitOperation (-) == skip;

  public visitAssignmentDefinition: IOmlAssignmentDefinition ==> ()
  visitAssignmentDefinition (-) == skip;

  public visitSameclassExpression: IOmlSameclassExpression ==> ()
  visitSameclassExpression (-) == skip;

  public visitExitStatement: IOmlExitStatement ==> ()
  visitExitStatement (-) == skip;

  public visitExistsExpression: IOmlExistsExpression ==> ()
  visitExistsExpression (-) == skip;

  public visitParameter: IOmlParameter ==> ()
  visitParameter (-) == skip;

  public visitFunctionTypeInstantiation: IOmlFunctionTypeInstantiation ==> ()
  visitFunctionTypeInstantiation (-) == skip;

  public visitSequenceEnumeration: IOmlSequenceEnumeration ==> ()
  visitSequenceEnumeration (-) == skip;

  public visitObjectApply: IOmlObjectApply ==> ()
  visitObjectApply (-) == skip;

  public visitSetUnionPattern: IOmlSetUnionPattern ==> ()
  visitSetUnionPattern (-) == skip;

  public visitTraceOneOrMore: IOmlTraceOneOrMore ==> ()
  visitTraceOneOrMore (-) == skip;

  public visitStartStatement: IOmlStartStatement ==> ()
  visitStartStatement (-) == skip;

  public visitError: IOmlError ==> ()
  visitError (-) == skip;

  public visitIfStatement: IOmlIfStatement ==> ()
  visitIfStatement (-) == skip;

  public visitLetBeExpression: IOmlLetBeExpression ==> ()
  visitLetBeExpression (-) == skip;

  public visitTotalFunctionType: IOmlTotalFunctionType ==> ()
  visitTotalFunctionType (-) == skip;

  public visitNilLiteral: IOmlNilLiteral ==> ()
  visitNilLiteral (-) == skip;

  public visitSporadicThread: IOmlSporadicThread ==> ()
  visitSporadicThread (-) == skip;

  public visitMapComprehension: IOmlMapComprehension ==> ()
  visitMapComprehension (-) == skip;

  public visitFunctionDefinition: IOmlFunctionDefinition ==> ()
  visitFunctionDefinition (-) == skip;

  public visitRecordConstructor: IOmlRecordConstructor ==> ()
  visitRecordConstructor (-) == skip;

  public visitBoolType: IOmlBoolType ==> ()
  visitBoolType (-) == skip;

  public visitSetBind: IOmlSetBind ==> ()
  visitSetBind (-) == skip;

  public visitNondeterministicStatement: IOmlNondeterministicStatement ==> ()
  visitNondeterministicStatement (-) == skip;

  public visitInstanceVariable: IOmlInstanceVariable ==> ()
  visitInstanceVariable (-) == skip;

  public visitLetExpression: IOmlLetExpression ==> ()
  visitLetExpression (-) == skip;

  public visitPatternIdentifier: IOmlPatternIdentifier ==> ()
  visitPatternIdentifier (-) == skip;

  public visitSymbolicLiteralPattern: IOmlSymbolicLiteralPattern ==> ()
  visitSymbolicLiteralPattern (-) == skip;

  public visitTupleConstructor: IOmlTupleConstructor ==> ()
  visitTupleConstructor (-) == skip;

  public visitTraceZeroOrMore: IOmlTraceZeroOrMore ==> ()
  visitTraceZeroOrMore (-) == skip;

  public visitOptionalType: IOmlOptionalType ==> ()
  visitOptionalType (-) == skip;

  public visitMutexAllPredicate: IOmlMutexAllPredicate ==> ()
  visitMutexAllPredicate (-) == skip;

  public visitAccessDefinition: IOmlAccessDefinition ==> ()
  visitAccessDefinition (-) == skip;

  public visitSequenceComprehension: IOmlSequenceComprehension ==> ()
  visitSequenceComprehension (-) == skip;

  public visitEqualsDefinition: IOmlEqualsDefinition ==> ()
  visitEqualsDefinition (-) == skip;

  public visitMaplet: IOmlMaplet ==> ()
  visitMaplet (-) == skip;

  public visitExistsUniqueExpression: IOmlExistsUniqueExpression ==> ()
  visitExistsUniqueExpression (-) == skip;

  public visitThreadIdExpression: IOmlThreadIdExpression ==> ()
  visitThreadIdExpression (-) == skip;

  public visitExtendedExplicitOperation: IOmlExtendedExplicitOperation ==> ()
  visitExtendedExplicitOperation (-) == skip;

  public visitSetComprehension: IOmlSetComprehension ==> ()
  visitSetComprehension (-) == skip;

  public visitIotaExpression: IOmlIotaExpression ==> ()
  visitIotaExpression (-) == skip;

  public visitReturnStatement: IOmlReturnStatement ==> ()
  visitReturnStatement (-) == skip;

  public visitTraceZeroOrOne: IOmlTraceZeroOrOne ==> ()
  visitTraceZeroOrOne (-) == skip;

  public visitSetEnumPattern: IOmlSetEnumPattern ==> ()
  visitSetEnumPattern (-) == skip;

  public visitFunctionDefinitions: IOmlFunctionDefinitions ==> ()
  visitFunctionDefinitions (-) == skip;

  public visitTrapStatement: IOmlTrapStatement ==> ()
  visitTrapStatement (-) == skip;

  public visitFieldSelect: IOmlFieldSelect ==> ()
  visitFieldSelect (-) == skip;

  public visitFunctionTypeSelect: IOmlFunctionTypeSelect ==> ()
  visitFunctionTypeSelect (-) == skip;

  public visitSeq1Type: IOmlSeq1Type ==> ()
  visitSeq1Type (-) == skip;

  public visitOperationBody: IOmlOperationBody ==> ()
  visitOperationBody (-) == skip;

  public visitClassTypeInstantiation: IOmlClassTypeInstantiation ==> ()
  visitClassTypeInstantiation (-) == skip;

  public visitApplyExpression: IOmlApplyExpression ==> ()
  visitApplyExpression (-) == skip;

  public visitValueShape: IOmlValueShape ==> ()
  visitValueShape (-) == skip;

  public visitCyclesStatement: IOmlCyclesStatement ==> ()
  visitCyclesStatement (-) == skip;

  public visitOperationDefinitions: IOmlOperationDefinitions ==> ()
  visitOperationDefinitions (-) == skip;

  public visitExplicitFunction: IOmlExplicitFunction ==> ()
  visitExplicitFunction (-) == skip;

  public visitPreconditionExpression: IOmlPreconditionExpression ==> ()
  visitPreconditionExpression (-) == skip;

  public visitTraceLetBeBinding: IOmlTraceLetBeBinding ==> ()
  visitTraceLetBeBinding (-) == skip;

  public visitQuoteLiteral: IOmlQuoteLiteral ==> ()
  visitQuoteLiteral (-) == skip;

  public visitVarInformation: IOmlVarInformation ==> ()
  visitVarInformation (-) == skip;

  public visitIsofbaseclassExpression: IOmlIsofbaseclassExpression ==> ()
  visitIsofbaseclassExpression (-) == skip;

  public visitLetStatement: IOmlLetStatement ==> ()
  visitLetStatement (-) == skip;

  public visitActExpression: IOmlActExpression ==> ()
  visitActExpression (-) == skip;

  public visitExceptions: IOmlExceptions ==> ()
  visitExceptions (-) == skip;

  public visitIsExpression: IOmlIsExpression ==> ()
  visitIsExpression (-) == skip;

  public visitTraceDefinitions: IOmlTraceDefinitions ==> ()
  visitTraceDefinitions (-) == skip;

  public visitValueDefinition: IOmlValueDefinition ==> ()
  visitValueDefinition (-) == skip;

  public visitCasesExpressionAlternative: IOmlCasesExpressionAlternative ==> ()
  visitCasesExpressionAlternative (-) == skip;

  public visitLetBeStatement: IOmlLetBeStatement ==> ()
  visitLetBeStatement (-) == skip;

  public visitMutexPredicate: IOmlMutexPredicate ==> ()
  visitMutexPredicate (-) == skip;

  public visitUndefinedExpression: IOmlUndefinedExpression ==> ()
  visitUndefinedExpression (-) == skip;

  public visitSetEnumeration: IOmlSetEnumeration ==> ()
  visitSetEnumeration (-) == skip;

  public visitCharacterLiteral: IOmlCharacterLiteral ==> ()
  visitCharacterLiteral (-) == skip;

  public visitAssignStatement: IOmlAssignStatement ==> ()
  visitAssignStatement (-) == skip;

  public visitProductType: IOmlProductType ==> ()
  visitProductType (-) == skip;

  public visitSequenceForLoop: IOmlSequenceForLoop ==> ()
  visitSequenceForLoop (-) == skip;

  public visitInstanceVariableDefinitions: IOmlInstanceVariableDefinitions ==> ()
  visitInstanceVariableDefinitions (-) == skip;

  public visitRealType: IOmlRealType ==> ()
  visitRealType (-) == skip;

  public visitCharType: IOmlCharType ==> ()
  visitCharType (-) == skip;

  public visitTraceMethodApply: IOmlTraceMethodApply ==> ()
  visitTraceMethodApply (-) == skip;

  public visitWaitingExpression: IOmlWaitingExpression ==> ()
  visitWaitingExpression (-) == skip;

  public visitInvariant: IOmlInvariant ==> ()
  visitInvariant (-) == skip;

  public visitObjectFieldReference: IOmlObjectFieldReference ==> ()
  visitObjectFieldReference (-) == skip;

  public visitEmptyType: IOmlEmptyType ==> ()
  visitEmptyType (-) == skip;

  public visitBracketedType: IOmlBracketedType ==> ()
  visitBracketedType (-) == skip;

  public visitFinExpression: IOmlFinExpression ==> ()
  visitFinExpression (-) == skip;

  public visitSetRangeExpression: IOmlSetRangeExpression ==> ()
  visitSetRangeExpression (-) == skip;

  public visitSimpleType: IOmlSimpleType ==> ()
  visitSimpleType (-) == skip;

  public visitTokenExpression: IOmlTokenExpression ==> ()
  visitTokenExpression (-) == skip;

  public visitBracketedExpression: IOmlBracketedExpression ==> ()
  visitBracketedExpression (-) == skip;

  public visitFunctionBody: IOmlFunctionBody ==> ()
  visitFunctionBody (-) == skip;

  public visitLambdaExpression: IOmlLambdaExpression ==> ()
  visitLambdaExpression (-) == skip;

  public visitInstanceVariableInvariant: IOmlInstanceVariableInvariant ==> ()
  visitInstanceVariableInvariant (-) == skip;

  public visitPartialFunctionType: IOmlPartialFunctionType ==> ()
  visitPartialFunctionType (-) == skip;

  public visitInheritanceClause: IOmlInheritanceClause ==> ()
  visitInheritanceClause (-) == skip;

  public visitDontCarePattern: IOmlDontCarePattern ==> ()
  visitDontCarePattern (-) == skip;

  public visitSeqEnumPattern: IOmlSeqEnumPattern ==> ()
  visitSeqEnumPattern (-) == skip;

  public visitUnionType: IOmlUnionType ==> ()
  visitUnionType (-) == skip;

  public visitTraceDefinitionItem: IOmlTraceDefinitionItem ==> ()
  visitTraceDefinitionItem (-) == skip;

  public visitTypelessExplicitFunction: IOmlTypelessExplicitFunction ==> ()
  visitTypelessExplicitFunction (-) == skip;

  public visitThreadDefinition: IOmlThreadDefinition ==> ()
  visitThreadDefinition (-) == skip;

  public visitAlwaysStatement: IOmlAlwaysStatement ==> ()
  visitAlwaysStatement (-) == skip;

  public visitRecordPattern: IOmlRecordPattern ==> ()
  visitRecordPattern (-) == skip;

  public visitQuoteType: IOmlQuoteType ==> ()
  visitQuoteType (-) == skip;

  public visitDclStatement: IOmlDclStatement ==> ()
  visitDclStatement (-) == skip;

  public visitBinaryExpression: IOmlBinaryExpression ==> ()
  visitBinaryExpression (-) == skip;

  public visitPatternTypePair: IOmlPatternTypePair ==> ()
  visitPatternTypePair (-) == skip;

  public visitMapOrSequenceReference: IOmlMapOrSequenceReference ==> ()
  visitMapOrSequenceReference (-) == skip;

  public visitElseIfExpression: IOmlElseIfExpression ==> ()
  visitElseIfExpression (-) == skip;

  public visitName: IOmlName ==> ()
  visitName (-) == skip;

  public visitNat1Type: IOmlNat1Type ==> ()
  visitNat1Type (-) == skip;

  public visitSynchronizationDefinitions: IOmlSynchronizationDefinitions ==> ()
  visitSynchronizationDefinitions (-) == skip;

  public visitMuExpression: IOmlMuExpression ==> ()
  visitMuExpression (-) == skip;

  public visitFunctionTrailer: IOmlFunctionTrailer ==> ()
  visitFunctionTrailer (-) == skip;

  public visitTimeExpression: IOmlTimeExpression ==> ()
  visitTimeExpression (-) == skip;

  public visitRatType: IOmlRatType ==> ()
  visitRatType (-) == skip;

  public visitStateDesignatorName: IOmlStateDesignatorName ==> ()
  visitStateDesignatorName (-) == skip;

  public visitExtendedExplicitFunction: IOmlExtendedExplicitFunction ==> ()
  visitExtendedExplicitFunction (-) == skip;

  public visitContextInfo: IOmlContextInfo ==> ()
  visitContextInfo (-) == skip;

  public visitNode: IOmlNode ==> ()
  visitNode (pNode) ==
    ( if isofclass(IOmlTraceCoreDefinition,pNode) then visitTraceCoreDefinition(pNode)
      elseif isofclass(IOmlOldName,pNode) then visitOldName(pNode)
      elseif isofclass(IOmlIntType,pNode) then visitIntType(pNode)
      elseif isofclass(IOmlSeqConcPattern,pNode) then visitSeqConcPattern(pNode)
      elseif isofclass(IOmlSkipStatement,pNode) then visitSkipStatement(pNode)
      elseif isofclass(IOmlPeriodicThread,pNode) then visitPeriodicThread(pNode)
      elseif isofclass(IOmlCallStatement,pNode) then visitCallStatement(pNode)
      elseif isofclass(IOmlIsofclassExpression,pNode) then visitIsofclassExpression(pNode)
      elseif isofclass(IOmlIndexForLoop,pNode) then visitIndexForLoop(pNode)
      elseif isofclass(IOmlTraceDefinition,pNode) then visitTraceDefinition(pNode)
      elseif isofclass(IOmlSymbolicLiteralExpression,pNode) then visitSymbolicLiteralExpression(pNode)
      elseif isofclass(IOmlTextLiteral,pNode) then visitTextLiteral(pNode)
      elseif isofclass(IOmlDefinitionBlock,pNode) then visitDefinitionBlock(pNode)
      elseif isofclass(IOmlReqExpression,pNode) then visitReqExpression(pNode)
      elseif isofclass(IOmlPermissionPredicate,pNode) then visitPermissionPredicate(pNode)
      elseif isofclass(IOmlProcedureThread,pNode) then visitProcedureThread(pNode)
      elseif isofclass(IOmlMode,pNode) then visitMode(pNode)
      elseif isofclass(IOmlSetType,pNode) then visitSetType(pNode)
      elseif isofclass(IOmlMapEnumeration,pNode) then visitMapEnumeration(pNode)
      elseif isofclass(IOmlNewExpression,pNode) then visitNewExpression(pNode)
      elseif isofclass(IOmlFieldReference,pNode) then visitFieldReference(pNode)
      elseif isofclass(IOmlAtomicStatement,pNode) then visitAtomicStatement(pNode)
      elseif isofclass(IOmlClass,pNode) then visitClass(pNode)
      elseif isofclass(IOmlBlockStatement,pNode) then visitBlockStatement(pNode)
      elseif isofclass(IOmlUnaryExpression,pNode) then visitUnaryExpression(pNode)
      elseif isofclass(IOmlTraceBinding,pNode) then visitTraceBinding(pNode)
      elseif isofclass(IOmlSyncPredicate,pNode) then visitSyncPredicate(pNode)
      elseif isofclass(IOmlInjectiveMapType,pNode) then visitInjectiveMapType(pNode)
      elseif isofclass(IOmlMatchValue,pNode) then visitMatchValue(pNode)
      elseif isofclass(IOmlNumericLiteral,pNode) then visitNumericLiteral(pNode)
      elseif isofclass(IOmlThreadSpecification,pNode) then visitThreadSpecification(pNode)
      elseif isofclass(IOmlOperationTrailer,pNode) then visitOperationTrailer(pNode)
      elseif isofclass(IOmlTypeDefinitions,pNode) then visitTypeDefinitions(pNode)
      elseif isofclass(IOmlTypeBind,pNode) then visitTypeBind(pNode)
      elseif isofclass(IOmlRecordModifier,pNode) then visitRecordModifier(pNode)
      elseif isofclass(IOmlObjectDesignatorExpression,pNode) then visitObjectDesignatorExpression(pNode)
      elseif isofclass(IOmlIdentifierTypePair,pNode) then visitIdentifierTypePair(pNode)
      elseif isofclass(IOmlTraceLetBinding,pNode) then visitTraceLetBinding(pNode)
      elseif isofclass(IOmlTrapDefinition,pNode) then visitTrapDefinition(pNode)
      elseif isofclass(IOmlRealLiteral,pNode) then visitRealLiteral(pNode)
      elseif isofclass(IOmlPatternBindExpression,pNode) then visitPatternBindExpression(pNode)
      elseif isofclass(IOmlSelfExpression,pNode) then visitSelfExpression(pNode)
      elseif isofclass(IOmlExpression,pNode) then visitExpression(pNode)
      elseif isofclass(IOmlRecursiveTrapStatement,pNode) then visitRecursiveTrapStatement(pNode)
      elseif isofclass(IOmlOperationDefinition,pNode) then visitOperationDefinition(pNode)
      elseif isofclass(IOmlScope,pNode) then visitScope(pNode)
      elseif isofclass(IOmlWhileLoop,pNode) then visitWhileLoop(pNode)
      elseif isofclass(IOmlDefStatement,pNode) then visitDefStatement(pNode)
      elseif isofclass(IOmlSeq0Type,pNode) then visitSeq0Type(pNode)
      elseif isofclass(IOmlSetForLoop,pNode) then visitSetForLoop(pNode)
      elseif isofclass(IOmlDefExpression,pNode) then visitDefExpression(pNode)
      elseif isofclass(IOmlDurationStatement,pNode) then visitDurationStatement(pNode)
      elseif isofclass(IOmlImplicitOperation,pNode) then visitImplicitOperation(pNode)
      elseif isofclass(IOmlTypeVariable,pNode) then visitTypeVariable(pNode)
      elseif isofclass(IOmlCompositeType,pNode) then visitCompositeType(pNode)
      elseif isofclass(IOmlTraceChoiceDefinition,pNode) then visitTraceChoiceDefinition(pNode)
      elseif isofclass(IOmlBooleanLiteral,pNode) then visitBooleanLiteral(pNode)
      elseif isofclass(IOmlOperationType,pNode) then visitOperationType(pNode)
      elseif isofclass(IOmlCasesStatementAlternative,pNode) then visitCasesStatementAlternative(pNode)
      elseif isofclass(IOmlActiveExpression,pNode) then visitActiveExpression(pNode)
      elseif isofclass(IOmlForAllExpression,pNode) then visitForAllExpression(pNode)
      elseif isofclass(IOmlSpecifications,pNode) then visitSpecifications(pNode)
      elseif isofclass(IOmlCasesExpression,pNode) then visitCasesExpression(pNode)
      elseif isofclass(IOmlIfExpression,pNode) then visitIfExpression(pNode)
      elseif isofclass(IOmlValueDefinitions,pNode) then visitValueDefinitions(pNode)
      elseif isofclass(IOmlCasesStatement,pNode) then visitCasesStatement(pNode)
      elseif isofclass(IOmlInstanceVariableShape,pNode) then visitInstanceVariableShape(pNode)
      elseif isofclass(IOmlErrorStatement,pNode) then visitErrorStatement(pNode)
      elseif isofclass(IOmlImplicitFunction,pNode) then visitImplicitFunction(pNode)
      elseif isofclass(IOmlNatType,pNode) then visitNatType(pNode)
      elseif isofclass(IOmlSamebaseclassExpression,pNode) then visitSamebaseclassExpression(pNode)
      elseif isofclass(IOmlComplexType,pNode) then visitComplexType(pNode)
      elseif isofclass(IOmlLiteral,pNode) then visitLiteral(pNode)
      elseif isofclass(IOmlExternals,pNode) then visitExternals(pNode)
      elseif isofclass(IOmlSubsequenceExpression,pNode) then visitSubsequenceExpression(pNode)
      elseif isofclass(IOmlElseIfStatement,pNode) then visitElseIfStatement(pNode)
      elseif isofclass(IOmlGeneralMapType,pNode) then visitGeneralMapType(pNode)
      elseif isofclass(IOmlSpecificationStatement,pNode) then visitSpecificationStatement(pNode)
      elseif isofclass(IOmlPattern,pNode) then visitPattern(pNode)
      elseif isofclass(IOmlTuplePattern,pNode) then visitTuplePattern(pNode)
      elseif isofclass(IOmlTraceBracketedDefinition,pNode) then visitTraceBracketedDefinition(pNode)
      elseif isofclass(IOmlField,pNode) then visitField(pNode)
      elseif isofclass(IOmlNamedTrace,pNode) then visitNamedTrace(pNode)
      elseif isofclass(IOmlTraceSequenceDefinition,pNode) then visitTraceSequenceDefinition(pNode)
      elseif isofclass(IOmlStatement,pNode) then visitStatement(pNode)
      elseif isofclass(IOmlTokenType,pNode) then visitTokenType(pNode)
      elseif isofclass(IOmlTraceRange,pNode) then visitTraceRange(pNode)
      elseif isofclass(IOmlTypeName,pNode) then visitTypeName(pNode)
      elseif isofclass(IOmlTypeDefinition,pNode) then visitTypeDefinition(pNode)
      elseif isofclass(IOmlExplicitOperation,pNode) then visitExplicitOperation(pNode)
      elseif isofclass(IOmlAssignmentDefinition,pNode) then visitAssignmentDefinition(pNode)
      elseif isofclass(IOmlSameclassExpression,pNode) then visitSameclassExpression(pNode)
      elseif isofclass(IOmlExitStatement,pNode) then visitExitStatement(pNode)
      elseif isofclass(IOmlExistsExpression,pNode) then visitExistsExpression(pNode)
      elseif isofclass(IOmlParameter,pNode) then visitParameter(pNode)
      elseif isofclass(IOmlFunctionTypeInstantiation,pNode) then visitFunctionTypeInstantiation(pNode)
      elseif isofclass(IOmlObjectApply,pNode) then visitObjectApply(pNode)
      elseif isofclass(IOmlSequenceEnumeration,pNode) then visitSequenceEnumeration(pNode)
      elseif isofclass(IOmlSetUnionPattern,pNode) then visitSetUnionPattern(pNode)
      elseif isofclass(IOmlTraceOneOrMore,pNode) then visitTraceOneOrMore(pNode)
      elseif isofclass(IOmlStartStatement,pNode) then visitStartStatement(pNode)
      elseif isofclass(IOmlError,pNode) then visitError(pNode)
      elseif isofclass(IOmlFunctionShape,pNode) then visitFunctionShape(pNode)
      elseif isofclass(IOmlIfStatement,pNode) then visitIfStatement(pNode)
      elseif isofclass(IOmlLetBeExpression,pNode) then visitLetBeExpression(pNode)
      elseif isofclass(IOmlTotalFunctionType,pNode) then visitTotalFunctionType(pNode)
      elseif isofclass(IOmlNilLiteral,pNode) then visitNilLiteral(pNode)
      elseif isofclass(IOmlSporadicThread,pNode) then visitSporadicThread(pNode)
      elseif isofclass(IOmlBind,pNode) then visitBind(pNode)
      elseif isofclass(IOmlMapComprehension,pNode) then visitMapComprehension(pNode)
      elseif isofclass(IOmlFunctionDefinition,pNode) then visitFunctionDefinition(pNode)
      elseif isofclass(IOmlRecordConstructor,pNode) then visitRecordConstructor(pNode)
      elseif isofclass(IOmlBoolType,pNode) then visitBoolType(pNode)
      elseif isofclass(IOmlSetBind,pNode) then visitSetBind(pNode)
      elseif isofclass(IOmlNondeterministicStatement,pNode) then visitNondeterministicStatement(pNode)
      elseif isofclass(IOmlInstanceVariable,pNode) then visitInstanceVariable(pNode)
      elseif isofclass(IOmlLetExpression,pNode) then visitLetExpression(pNode)
      elseif isofclass(IOmlPatternIdentifier,pNode) then visitPatternIdentifier(pNode)
      elseif isofclass(IOmlTupleConstructor,pNode) then visitTupleConstructor(pNode)
      elseif isofclass(IOmlSymbolicLiteralPattern,pNode) then visitSymbolicLiteralPattern(pNode)
      elseif isofclass(IOmlOptionalType,pNode) then visitOptionalType(pNode)
      elseif isofclass(IOmlTraceZeroOrMore,pNode) then visitTraceZeroOrMore(pNode)
      elseif isofclass(IOmlMutexAllPredicate,pNode) then visitMutexAllPredicate(pNode)
      elseif isofclass(IOmlAccessDefinition,pNode) then visitAccessDefinition(pNode)
      elseif isofclass(IOmlPatternBind,pNode) then visitPatternBind(pNode)
      elseif isofclass(IOmlSequenceComprehension,pNode) then visitSequenceComprehension(pNode)
      elseif isofclass(IOmlEqualsDefinition,pNode) then visitEqualsDefinition(pNode)
      elseif isofclass(IOmlMaplet,pNode) then visitMaplet(pNode)
      elseif isofclass(IOmlExistsUniqueExpression,pNode) then visitExistsUniqueExpression(pNode)
      elseif isofclass(IOmlThreadIdExpression,pNode) then visitThreadIdExpression(pNode)
      elseif isofclass(IOmlExtendedExplicitOperation,pNode) then visitExtendedExplicitOperation(pNode)
      elseif isofclass(IOmlSetComprehension,pNode) then visitSetComprehension(pNode)
      elseif isofclass(IOmlIotaExpression,pNode) then visitIotaExpression(pNode)
      elseif isofclass(IOmlReturnStatement,pNode) then visitReturnStatement(pNode)
      elseif isofclass(IOmlTraceZeroOrOne,pNode) then visitTraceZeroOrOne(pNode)
      elseif isofclass(IOmlSetEnumPattern,pNode) then visitSetEnumPattern(pNode)
      elseif isofclass(IOmlTrapStatement,pNode) then visitTrapStatement(pNode)
      elseif isofclass(IOmlFunctionDefinitions,pNode) then visitFunctionDefinitions(pNode)
      elseif isofclass(IOmlFieldSelect,pNode) then visitFieldSelect(pNode)
      elseif isofclass(IOmlFunctionTypeSelect,pNode) then visitFunctionTypeSelect(pNode)
      elseif isofclass(IOmlSeq1Type,pNode) then visitSeq1Type(pNode)
      elseif isofclass(IOmlOperationBody,pNode) then visitOperationBody(pNode)
      elseif isofclass(IOmlClassTypeInstantiation,pNode) then visitClassTypeInstantiation(pNode)
      elseif isofclass(IOmlApplyExpression,pNode) then visitApplyExpression(pNode)
      elseif isofclass(IOmlCyclesStatement,pNode) then visitCyclesStatement(pNode)
      elseif isofclass(IOmlValueShape,pNode) then visitValueShape(pNode)
      elseif isofclass(IOmlTraceRepeatPattern,pNode) then visitTraceRepeatPattern(pNode)
      elseif isofclass(IOmlOperationDefinitions,pNode) then visitOperationDefinitions(pNode)
      elseif isofclass(IOmlExplicitFunction,pNode) then visitExplicitFunction(pNode)
      elseif isofclass(IOmlPreconditionExpression,pNode) then visitPreconditionExpression(pNode)
      elseif isofclass(IOmlTraceLetBeBinding,pNode) then visitTraceLetBeBinding(pNode)
      elseif isofclass(IOmlQuoteLiteral,pNode) then visitQuoteLiteral(pNode)
      elseif isofclass(IOmlVarInformation,pNode) then visitVarInformation(pNode)
      elseif isofclass(IOmlIsofbaseclassExpression,pNode) then visitIsofbaseclassExpression(pNode)
      elseif isofclass(IOmlLetStatement,pNode) then visitLetStatement(pNode)
      elseif isofclass(IOmlActExpression,pNode) then visitActExpression(pNode)
      elseif isofclass(IOmlExceptions,pNode) then visitExceptions(pNode)
      elseif isofclass(IOmlIsExpression,pNode) then visitIsExpression(pNode)
      elseif isofclass(IOmlBinaryOperator,pNode) then visitBinaryOperator(pNode)
      elseif isofclass(IOmlTraceDefinitions,pNode) then visitTraceDefinitions(pNode)
      elseif isofclass(IOmlValueDefinition,pNode) then visitValueDefinition(pNode)
      elseif isofclass(IOmlCasesExpressionAlternative,pNode) then visitCasesExpressionAlternative(pNode)
      elseif isofclass(IOmlLetBeStatement,pNode) then visitLetBeStatement(pNode)
      elseif isofclass(IOmlMutexPredicate,pNode) then visitMutexPredicate(pNode)
      elseif isofclass(IOmlUndefinedExpression,pNode) then visitUndefinedExpression(pNode)
      elseif isofclass(IOmlSetEnumeration,pNode) then visitSetEnumeration(pNode)
      elseif isofclass(IOmlCharacterLiteral,pNode) then visitCharacterLiteral(pNode)
      elseif isofclass(IOmlAssignStatement,pNode) then visitAssignStatement(pNode)
      elseif isofclass(IOmlProductType,pNode) then visitProductType(pNode)
      elseif isofclass(IOmlSequenceForLoop,pNode) then visitSequenceForLoop(pNode)
      elseif isofclass(IOmlInstanceVariableDefinitions,pNode) then visitInstanceVariableDefinitions(pNode)
      elseif isofclass(IOmlRealType,pNode) then visitRealType(pNode)
      elseif isofclass(IOmlCharType,pNode) then visitCharType(pNode)
      elseif isofclass(IOmlTraceMethodApply,pNode) then visitTraceMethodApply(pNode)
      elseif isofclass(IOmlWaitingExpression,pNode) then visitWaitingExpression(pNode)
      elseif isofclass(IOmlInvariant,pNode) then visitInvariant(pNode)
      elseif isofclass(IOmlObjectFieldReference,pNode) then visitObjectFieldReference(pNode)
      elseif isofclass(IOmlUnaryOperator,pNode) then visitUnaryOperator(pNode)
      elseif isofclass(IOmlTypeShape,pNode) then visitTypeShape(pNode)
      elseif isofclass(IOmlEmptyType,pNode) then visitEmptyType(pNode)
      elseif isofclass(IOmlBracketedType,pNode) then visitBracketedType(pNode)
      elseif isofclass(IOmlFinExpression,pNode) then visitFinExpression(pNode)
      elseif isofclass(IOmlSetRangeExpression,pNode) then visitSetRangeExpression(pNode)
      elseif isofclass(IOmlSimpleType,pNode) then visitSimpleType(pNode)
      elseif isofclass(IOmlTokenExpression,pNode) then visitTokenExpression(pNode)
      elseif isofclass(IOmlBracketedExpression,pNode) then visitBracketedExpression(pNode)
      elseif isofclass(IOmlType,pNode) then visitType(pNode)
      elseif isofclass(IOmlFunctionBody,pNode) then visitFunctionBody(pNode)
      elseif isofclass(IOmlPartialFunctionType,pNode) then visitPartialFunctionType(pNode)
      elseif isofclass(IOmlLambdaExpression,pNode) then visitLambdaExpression(pNode)
      elseif isofclass(IOmlInstanceVariableInvariant,pNode) then visitInstanceVariableInvariant(pNode)
      elseif isofclass(IOmlInheritanceClause,pNode) then visitInheritanceClause(pNode)
      elseif isofclass(IOmlSeqEnumPattern,pNode) then visitSeqEnumPattern(pNode)
      elseif isofclass(IOmlDontCarePattern,pNode) then visitDontCarePattern(pNode)
      elseif isofclass(IOmlUnionType,pNode) then visitUnionType(pNode)
      elseif isofclass(IOmlTraceDefinitionItem,pNode) then visitTraceDefinitionItem(pNode)
      elseif isofclass(IOmlOperationShape,pNode) then visitOperationShape(pNode)
      elseif isofclass(IOmlTypelessExplicitFunction,pNode) then visitTypelessExplicitFunction(pNode)
      elseif isofclass(IOmlThreadDefinition,pNode) then visitThreadDefinition(pNode)
      elseif isofclass(IOmlAlwaysStatement,pNode) then visitAlwaysStatement(pNode)
      elseif isofclass(IOmlRecordPattern,pNode) then visitRecordPattern(pNode)
      elseif isofclass(IOmlQuoteType,pNode) then visitQuoteType(pNode)
      elseif isofclass(IOmlDclStatement,pNode) then visitDclStatement(pNode)
      elseif isofclass(IOmlObjectDesignator,pNode) then visitObjectDesignator(pNode)
      elseif isofclass(IOmlPatternTypePair,pNode) then visitPatternTypePair(pNode)
      elseif isofclass(IOmlBinaryExpression,pNode) then visitBinaryExpression(pNode)
      elseif isofclass(IOmlMapOrSequenceReference,pNode) then visitMapOrSequenceReference(pNode)
      elseif isofclass(IOmlElseIfExpression,pNode) then visitElseIfExpression(pNode)
      elseif isofclass(IOmlName,pNode) then visitName(pNode)
      elseif isofclass(IOmlNat1Type,pNode) then visitNat1Type(pNode)
      elseif isofclass(IOmlStateDesignator,pNode) then visitStateDesignator(pNode)
      elseif isofclass(IOmlSynchronizationDefinitions,pNode) then visitSynchronizationDefinitions(pNode)
      elseif isofclass(IOmlFunctionTrailer,pNode) then visitFunctionTrailer(pNode)
      elseif isofclass(IOmlMuExpression,pNode) then visitMuExpression(pNode)
      elseif isofclass(IOmlTimeExpression,pNode) then visitTimeExpression(pNode)
      elseif isofclass(IOmlRatType,pNode) then visitRatType(pNode)
      elseif isofclass(IOmlExtendedExplicitFunction,pNode) then visitExtendedExplicitFunction(pNode)
      elseif isofclass(IOmlStateDesignatorName,pNode) then visitStateDesignatorName(pNode)
      else error );

  public visitType: IOmlType ==> ()
  visitType (pNode) ==
    ( if isofclass(IOmlSeq1Type,pNode) then visitSeq1Type(pNode)
      elseif isofclass(IOmlPartialFunctionType,pNode) then visitPartialFunctionType(pNode)
      elseif isofclass(IOmlClassTypeInstantiation,pNode) then visitClassTypeInstantiation(pNode)
      elseif isofclass(IOmlTokenType,pNode) then visitTokenType(pNode)
      elseif isofclass(IOmlTypeName,pNode) then visitTypeName(pNode)
      elseif isofclass(IOmlUnionType,pNode) then visitUnionType(pNode)
      elseif isofclass(IOmlBoolType,pNode) then visitBoolType(pNode)
      elseif isofclass(IOmlProductType,pNode) then visitProductType(pNode)
      elseif isofclass(IOmlQuoteType,pNode) then visitQuoteType(pNode)
      elseif isofclass(IOmlIntType,pNode) then visitIntType(pNode)
      elseif isofclass(IOmlNatType,pNode) then visitNatType(pNode)
      elseif isofclass(IOmlRealType,pNode) then visitRealType(pNode)
      elseif isofclass(IOmlCharType,pNode) then visitCharType(pNode)
      elseif isofclass(IOmlSeq0Type,pNode) then visitSeq0Type(pNode)
      elseif isofclass(IOmlOptionalType,pNode) then visitOptionalType(pNode)
      elseif isofclass(IOmlSetType,pNode) then visitSetType(pNode)
      elseif isofclass(IOmlGeneralMapType,pNode) then visitGeneralMapType(pNode)
      elseif isofclass(IOmlCompositeType,pNode) then visitCompositeType(pNode)
      elseif isofclass(IOmlTypeVariable,pNode) then visitTypeVariable(pNode)
      elseif isofclass(IOmlNat1Type,pNode) then visitNat1Type(pNode)
      elseif isofclass(IOmlTotalFunctionType,pNode) then visitTotalFunctionType(pNode)
      elseif isofclass(IOmlRatType,pNode) then visitRatType(pNode)
      elseif isofclass(IOmlEmptyType,pNode) then visitEmptyType(pNode)
      elseif isofclass(IOmlBracketedType,pNode) then visitBracketedType(pNode)
      elseif isofclass(IOmlOperationType,pNode) then visitOperationType(pNode)
      elseif isofclass(IOmlInjectiveMapType,pNode) then visitInjectiveMapType(pNode)
      else error );

  public visitStatement: IOmlStatement ==> ()
  visitStatement (pNode) ==
    ( if isofclass(IOmlCyclesStatement,pNode) then visitCyclesStatement(pNode)
      elseif isofclass(IOmlAlwaysStatement,pNode) then visitAlwaysStatement(pNode)
      elseif isofclass(IOmlAssignStatement,pNode) then visitAssignStatement(pNode)
      elseif isofclass(IOmlCasesStatement,pNode) then visitCasesStatement(pNode)
      elseif isofclass(IOmlNondeterministicStatement,pNode) then visitNondeterministicStatement(pNode)
      elseif isofclass(IOmlExitStatement,pNode) then visitExitStatement(pNode)
      elseif isofclass(IOmlDclStatement,pNode) then visitDclStatement(pNode)
      elseif isofclass(IOmlRecursiveTrapStatement,pNode) then visitRecursiveTrapStatement(pNode)
      elseif isofclass(IOmlSkipStatement,pNode) then visitSkipStatement(pNode)
      elseif isofclass(IOmlSequenceForLoop,pNode) then visitSequenceForLoop(pNode)
      elseif isofclass(IOmlErrorStatement,pNode) then visitErrorStatement(pNode)
      elseif isofclass(IOmlCallStatement,pNode) then visitCallStatement(pNode)
      elseif isofclass(IOmlWhileLoop,pNode) then visitWhileLoop(pNode)
      elseif isofclass(IOmlIndexForLoop,pNode) then visitIndexForLoop(pNode)
      elseif isofclass(IOmlDefStatement,pNode) then visitDefStatement(pNode)
      elseif isofclass(IOmlLetStatement,pNode) then visitLetStatement(pNode)
      elseif isofclass(IOmlSetForLoop,pNode) then visitSetForLoop(pNode)
      elseif isofclass(IOmlStartStatement,pNode) then visitStartStatement(pNode)
      elseif isofclass(IOmlDurationStatement,pNode) then visitDurationStatement(pNode)
      elseif isofclass(IOmlAtomicStatement,pNode) then visitAtomicStatement(pNode)
      elseif isofclass(IOmlSpecificationStatement,pNode) then visitSpecificationStatement(pNode)
      elseif isofclass(IOmlReturnStatement,pNode) then visitReturnStatement(pNode)
      elseif isofclass(IOmlIfStatement,pNode) then visitIfStatement(pNode)
      elseif isofclass(IOmlBlockStatement,pNode) then visitBlockStatement(pNode)
      elseif isofclass(IOmlTrapStatement,pNode) then visitTrapStatement(pNode)
      elseif isofclass(IOmlLetBeStatement,pNode) then visitLetBeStatement(pNode)
      else error );

  public visitThreadSpecification: IOmlThreadSpecification ==> ()
  visitThreadSpecification (pNode) ==
    ( if isofclass(IOmlPeriodicThread,pNode) then visitPeriodicThread(pNode)
      elseif isofclass(IOmlSporadicThread,pNode) then visitSporadicThread(pNode)
      elseif isofclass(IOmlProcedureThread,pNode) then visitProcedureThread(pNode)
      else error );

  public visitBind: IOmlBind ==> ()
  visitBind (pNode) ==
    ( if isofclass(IOmlSetBind,pNode) then visitSetBind(pNode)
      elseif isofclass(IOmlTypeBind,pNode) then visitTypeBind(pNode)
      else error );

  public visitOperationShape: IOmlOperationShape ==> ()
  visitOperationShape (pNode) ==
    ( if isofclass(IOmlExtendedExplicitOperation,pNode) then visitExtendedExplicitOperation(pNode)
      elseif isofclass(IOmlExplicitOperation,pNode) then visitExplicitOperation(pNode)
      elseif isofclass(IOmlImplicitOperation,pNode) then visitImplicitOperation(pNode)
      else error );

  public visitTraceCoreDefinition: IOmlTraceCoreDefinition ==> ()
  visitTraceCoreDefinition (pNode) ==
    ( if isofclass(IOmlTraceBracketedDefinition,pNode) then visitTraceBracketedDefinition(pNode)
      elseif isofclass(IOmlTraceMethodApply,pNode) then visitTraceMethodApply(pNode)
      else error );

  public visitTraceRepeatPattern: IOmlTraceRepeatPattern ==> ()
  visitTraceRepeatPattern (pNode) ==
    ( if isofclass(IOmlTraceZeroOrOne,pNode) then visitTraceZeroOrOne(pNode)
      elseif isofclass(IOmlTraceZeroOrMore,pNode) then visitTraceZeroOrMore(pNode)
      elseif isofclass(IOmlTraceOneOrMore,pNode) then visitTraceOneOrMore(pNode)
      elseif isofclass(IOmlTraceRange,pNode) then visitTraceRange(pNode)
      else error );

  public visitInstanceVariableShape: IOmlInstanceVariableShape ==> ()
  visitInstanceVariableShape (pNode) ==
    ( if isofclass(IOmlInstanceVariableInvariant,pNode) then visitInstanceVariableInvariant(pNode)
      elseif isofclass(IOmlInstanceVariable,pNode) then visitInstanceVariable(pNode)
      else error );

  public visitExpression: IOmlExpression ==> ()
  visitExpression (pNode) ==
    ( if isofclass(IOmlFunctionTypeSelect,pNode) then visitFunctionTypeSelect(pNode)
      elseif isofclass(IOmlTokenExpression,pNode) then visitTokenExpression(pNode)
      elseif isofclass(IOmlUndefinedExpression,pNode) then visitUndefinedExpression(pNode)
      elseif isofclass(IOmlBracketedExpression,pNode) then visitBracketedExpression(pNode)
      elseif isofclass(IOmlActiveExpression,pNode) then visitActiveExpression(pNode)
      elseif isofclass(IOmlForAllExpression,pNode) then visitForAllExpression(pNode)
      elseif isofclass(IOmlLambdaExpression,pNode) then visitLambdaExpression(pNode)
      elseif isofclass(IOmlSetEnumeration,pNode) then visitSetEnumeration(pNode)
      elseif isofclass(IOmlMapComprehension,pNode) then visitMapComprehension(pNode)
      elseif isofclass(IOmlApplyExpression,pNode) then visitApplyExpression(pNode)
      elseif isofclass(IOmlCasesExpression,pNode) then visitCasesExpression(pNode)
      elseif isofclass(IOmlRecordConstructor,pNode) then visitRecordConstructor(pNode)
      elseif isofclass(IOmlIfExpression,pNode) then visitIfExpression(pNode)
      elseif isofclass(IOmlOldName,pNode) then visitOldName(pNode)
      elseif isofclass(IOmlPreconditionExpression,pNode) then visitPreconditionExpression(pNode)
      elseif isofclass(IOmlSameclassExpression,pNode) then visitSameclassExpression(pNode)
      elseif isofclass(IOmlSelfExpression,pNode) then visitSelfExpression(pNode)
      elseif isofclass(IOmlExistsExpression,pNode) then visitExistsExpression(pNode)
      elseif isofclass(IOmlSamebaseclassExpression,pNode) then visitSamebaseclassExpression(pNode)
      elseif isofclass(IOmlFunctionTypeInstantiation,pNode) then visitFunctionTypeInstantiation(pNode)
      elseif isofclass(IOmlIsofclassExpression,pNode) then visitIsofclassExpression(pNode)
      elseif isofclass(IOmlSequenceEnumeration,pNode) then visitSequenceEnumeration(pNode)
      elseif isofclass(IOmlLetExpression,pNode) then visitLetExpression(pNode)
      elseif isofclass(IOmlBinaryExpression,pNode) then visitBinaryExpression(pNode)
      elseif isofclass(IOmlTupleConstructor,pNode) then visitTupleConstructor(pNode)
      elseif isofclass(IOmlIsofbaseclassExpression,pNode) then visitIsofbaseclassExpression(pNode)
      elseif isofclass(IOmlSymbolicLiteralExpression,pNode) then visitSymbolicLiteralExpression(pNode)
      elseif isofclass(IOmlSubsequenceExpression,pNode) then visitSubsequenceExpression(pNode)
      elseif isofclass(IOmlReqExpression,pNode) then visitReqExpression(pNode)
      elseif isofclass(IOmlSequenceComprehension,pNode) then visitSequenceComprehension(pNode)
      elseif isofclass(IOmlExistsUniqueExpression,pNode) then visitExistsUniqueExpression(pNode)
      elseif isofclass(IOmlThreadIdExpression,pNode) then visitThreadIdExpression(pNode)
      elseif isofclass(IOmlDefExpression,pNode) then visitDefExpression(pNode)
      elseif isofclass(IOmlActExpression,pNode) then visitActExpression(pNode)
      elseif isofclass(IOmlName,pNode) then visitName(pNode)
      elseif isofclass(IOmlSetComprehension,pNode) then visitSetComprehension(pNode)
      elseif isofclass(IOmlIotaExpression,pNode) then visitIotaExpression(pNode)
      elseif isofclass(IOmlMapEnumeration,pNode) then visitMapEnumeration(pNode)
      elseif isofclass(IOmlNewExpression,pNode) then visitNewExpression(pNode)
      elseif isofclass(IOmlIsExpression,pNode) then visitIsExpression(pNode)
      elseif isofclass(IOmlWaitingExpression,pNode) then visitWaitingExpression(pNode)
      elseif isofclass(IOmlLetBeExpression,pNode) then visitLetBeExpression(pNode)
      elseif isofclass(IOmlMuExpression,pNode) then visitMuExpression(pNode)
      elseif isofclass(IOmlFieldSelect,pNode) then visitFieldSelect(pNode)
      elseif isofclass(IOmlUnaryExpression,pNode) then visitUnaryExpression(pNode)
      elseif isofclass(IOmlTimeExpression,pNode) then visitTimeExpression(pNode)
      elseif isofclass(IOmlFinExpression,pNode) then visitFinExpression(pNode)
      elseif isofclass(IOmlSetRangeExpression,pNode) then visitSetRangeExpression(pNode)
      else error );

  public visitObjectDesignator: IOmlObjectDesignator ==> ()
  visitObjectDesignator (pNode) ==
    ( if isofclass(IOmlObjectApply,pNode) then visitObjectApply(pNode)
      elseif isofclass(IOmlObjectDesignatorExpression,pNode) then visitObjectDesignatorExpression(pNode)
      elseif isofclass(IOmlObjectFieldReference,pNode) then visitObjectFieldReference(pNode)
      else error );

  public visitScope: IOmlScope ==> ()
  visitScope (-) == skip;

  public visitLiteral: IOmlLiteral ==> ()
  visitLiteral (pNode) ==
    ( if isofclass(IOmlNumericLiteral,pNode) then visitNumericLiteral(pNode)
      elseif isofclass(IOmlRealLiteral,pNode) then visitRealLiteral(pNode)
      elseif isofclass(IOmlTextLiteral,pNode) then visitTextLiteral(pNode)
      elseif isofclass(IOmlNilLiteral,pNode) then visitNilLiteral(pNode)
      elseif isofclass(IOmlCharacterLiteral,pNode) then visitCharacterLiteral(pNode)
      elseif isofclass(IOmlBooleanLiteral,pNode) then visitBooleanLiteral(pNode)
      elseif isofclass(IOmlQuoteLiteral,pNode) then visitQuoteLiteral(pNode)
      else error );

  public visitTraceDefinition: IOmlTraceDefinition ==> ()
  visitTraceDefinition (pNode) ==
    ( if isofclass(IOmlTraceSequenceDefinition,pNode) then visitTraceSequenceDefinition(pNode)
      elseif isofclass(IOmlTraceDefinitionItem,pNode) then visitTraceDefinitionItem(pNode)
      elseif isofclass(IOmlTraceChoiceDefinition,pNode) then visitTraceChoiceDefinition(pNode)
      else error );

  public visitDefinitionBlock: IOmlDefinitionBlock ==> ()
  visitDefinitionBlock (pNode) ==
    ( if isofclass(IOmlInstanceVariableDefinitions,pNode) then visitInstanceVariableDefinitions(pNode)
      elseif isofclass(IOmlOperationDefinitions,pNode) then visitOperationDefinitions(pNode)
      elseif isofclass(IOmlThreadDefinition,pNode) then visitThreadDefinition(pNode)
      elseif isofclass(IOmlValueDefinitions,pNode) then visitValueDefinitions(pNode)
      elseif isofclass(IOmlSynchronizationDefinitions,pNode) then visitSynchronizationDefinitions(pNode)
      elseif isofclass(IOmlFunctionDefinitions,pNode) then visitFunctionDefinitions(pNode)
      elseif isofclass(IOmlTraceDefinitions,pNode) then visitTraceDefinitions(pNode)
      elseif isofclass(IOmlTypeDefinitions,pNode) then visitTypeDefinitions(pNode)
      else error );

  public visitPatternBind: IOmlPatternBind ==> ()
  visitPatternBind (pNode) ==
    ( if isofclass(IOmlPattern,pNode) then visitPattern(pNode)
      elseif isofclass(IOmlBind,pNode) then visitBind(pNode)
      else error );

  public visitMode: IOmlMode ==> ()
  visitMode (-) == skip;

  public visitFunctionShape: IOmlFunctionShape ==> ()
  visitFunctionShape (pNode) ==
    ( if isofclass(IOmlTypelessExplicitFunction,pNode) then visitTypelessExplicitFunction(pNode)
      elseif isofclass(IOmlExplicitFunction,pNode) then visitExplicitFunction(pNode)
      elseif isofclass(IOmlImplicitFunction,pNode) then visitImplicitFunction(pNode)
      elseif isofclass(IOmlExtendedExplicitFunction,pNode) then visitExtendedExplicitFunction(pNode)
      else error );

  public visitBinaryOperator: IOmlBinaryOperator ==> ()
  visitBinaryOperator (-) == skip;

  public visitStateDesignator: IOmlStateDesignator ==> ()
  visitStateDesignator (pNode) ==
    ( if isofclass(IOmlFieldReference,pNode) then visitFieldReference(pNode)
      elseif isofclass(IOmlMapOrSequenceReference,pNode) then visitMapOrSequenceReference(pNode)
      elseif isofclass(IOmlStateDesignatorName,pNode) then visitStateDesignatorName(pNode)
      else error );

  public visitUnaryOperator: IOmlUnaryOperator ==> ()
  visitUnaryOperator (-) == skip;

  public visitPattern: IOmlPattern ==> ()
  visitPattern (pNode) ==
    ( if isofclass(IOmlTuplePattern,pNode) then visitTuplePattern(pNode)
      elseif isofclass(IOmlSetUnionPattern,pNode) then visitSetUnionPattern(pNode)
      elseif isofclass(IOmlPatternIdentifier,pNode) then visitPatternIdentifier(pNode)
      elseif isofclass(IOmlSymbolicLiteralPattern,pNode) then visitSymbolicLiteralPattern(pNode)
      elseif isofclass(IOmlRecordPattern,pNode) then visitRecordPattern(pNode)
      elseif isofclass(IOmlMatchValue,pNode) then visitMatchValue(pNode)
      elseif isofclass(IOmlSetEnumPattern,pNode) then visitSetEnumPattern(pNode)
      elseif isofclass(IOmlSeqConcPattern,pNode) then visitSeqConcPattern(pNode)
      elseif isofclass(IOmlSeqEnumPattern,pNode) then visitSeqEnumPattern(pNode)
      elseif isofclass(IOmlDontCarePattern,pNode) then visitDontCarePattern(pNode)
      else error );

  public visitTraceBinding: IOmlTraceBinding ==> ()
  visitTraceBinding (pNode) ==
    ( if isofclass(IOmlTraceLetBinding,pNode) then visitTraceLetBinding(pNode)
      elseif isofclass(IOmlTraceLetBeBinding,pNode) then visitTraceLetBeBinding(pNode)
      else error );

  public visitSyncPredicate: IOmlSyncPredicate ==> ()
  visitSyncPredicate (pNode) ==
    ( if isofclass(IOmlMutexAllPredicate,pNode) then visitMutexAllPredicate(pNode)
      elseif isofclass(IOmlPermissionPredicate,pNode) then visitPermissionPredicate(pNode)
      elseif isofclass(IOmlMutexPredicate,pNode) then visitMutexPredicate(pNode)
      else error );

  public visitTypeShape: IOmlTypeShape ==> ()
  visitTypeShape (pNode) ==
    ( if isofclass(IOmlComplexType,pNode) then visitComplexType(pNode)
      elseif isofclass(IOmlSimpleType,pNode) then visitSimpleType(pNode)
      else error );

end OmlVisitor
\end{vdm_al}
\begin{vdm_al}
class OmlWaitingExpression is subclass of IOmlWaitingExpression
operations
  public identity: () ==> seq of char
  identity () == return "WaitingExpression";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitWaitingExpression(self);

  public OmlWaitingExpression:
    (seq of IOmlName) ==> OmlWaitingExpression
  OmlWaitingExpression (p1) == 
    ( setNameList(p1) );

  public OmlWaitingExpression:
    (seq of IOmlName) *
    nat *
    nat ==> OmlWaitingExpression
  OmlWaitingExpression (p1,line,column) == 
    ( setNameList(p1);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "name_list" in
        if fname in set dom data
        then setNameList(data(fname)) );

instance variables
  private ivNameList : seq of IOmlName := []

operations
  public getNameList: () ==> seq of IOmlName
  getNameList() == return ivNameList;

  public setNameList: seq of IOmlName ==> ()
  setNameList(parg) == ivNameList := parg;

  public addNameList: IOmlNode ==> ()
  addNameList (parg) == ivNameList := ivNameList ^ [parg];

end OmlWaitingExpression
\end{vdm_al}

\begin{vdm_al}
class OmlWhileLoop is subclass of IOmlWhileLoop
operations
  public identity: () ==> seq of char
  identity () == return "WhileLoop";

  public accept: IOmlVisitor ==> ()
  accept (pVisitor) == pVisitor.visitWhileLoop(self);

  public OmlWhileLoop:
    (IOmlExpression) *
    (IOmlStatement) ==> OmlWhileLoop
  OmlWhileLoop (p1,p2) == 
    ( setExpression(p1);
      setStatement(p2) );

  public OmlWhileLoop:
    (IOmlExpression) *
    (IOmlStatement) *
    nat *
    nat ==> OmlWhileLoop
  OmlWhileLoop (p1,p2,line,column) == 
    ( setExpression(p1);
      setStatement(p2);
      setPosition(line, column) );

  public init: map seq of char to [FieldValue] ==> ()
  init (data) ==
    ( let fname = "expression" in
        if fname in set dom data
        then setExpression(data(fname));
      let fname = "statement" in
        if fname in set dom data
        then setStatement(data(fname)) );

instance variables
  private ivExpression : [IOmlExpression] := nil

operations
  public getExpression: () ==> IOmlExpression
  getExpression() == return ivExpression;

  public setExpression: IOmlExpression ==> ()
  setExpression(parg) == ivExpression := parg;

instance variables
  private ivStatement : [IOmlStatement] := nil

operations
  public getStatement: () ==> IOmlStatement
  getStatement() == return ivStatement;

  public setStatement: IOmlStatement ==> ()
  setStatement(parg) == ivStatement := parg;

end OmlWhileLoop
\end{vdm_al}

